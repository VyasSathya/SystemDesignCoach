# CODE EXTRACTION - 2025-03-15 03:44:17

# PROJECT STRUCTURE
|-- client
|   |-- components
|   |   |-- coaching
|   |   |   +-- TopicGuidedCoaching.js
|   |   |       |-- module:TopicGuidedCoaching.js
|   |   |       |-- fn: TopicGuidedCoaching({ currentTopic, onSendMessage, onGetMaterials }) [internal]
|   |   |       |-- component:SYSTEM_DESIGN_TOPICS [internal]
|   |   |       |-- component:TopicGuidedCoaching [internal]
|   |   |-- diagram
|   |   |   |-- NodeTypes
|   |   |   |   |-- CacheNode.js
|   |   |   |   |   |-- module:CacheNode.js
|   |   |   |   |   |-- fn: CacheNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:CacheNode [internal]
|   |   |   |   |-- ClientNode.js
|   |   |   |   |   |-- module:ClientNode.js
|   |   |   |   |   |-- fn: ClientNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:ClientNode [internal]
|   |   |   |   |-- CustomNode.js
|   |   |   |   |   |-- module:CustomNode.js
|   |   |   |   |   |-- fn: CustomNode({ data, type }) [internal]
|   |   |   |   |   |-- method: CustomNode({ data, type })
|   |   |   |   |   |-- component:CustomNode [internal]
|   |   |   |   |   |-- component:Icon [internal]
|   |   |   |   |-- DatabaseNode.js
|   |   |   |   |   |-- module:DatabaseNode.js
|   |   |   |   |   |-- fn: DatabaseNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:DatabaseNode [internal]
|   |   |   |   |-- FixedLifelineNode.js
|   |   |   |   |   |-- module:FixedLifelineNode.js
|   |   |   |   |   |-- component:FixedLifelineNode [internal]
|   |   |   |   |   |-- component:FIXED_TOP_POSITION [internal]
|   |   |   |   |-- GatewayNode.js
|   |   |   |   |   |-- module:GatewayNode.js
|   |   |   |   |   |-- fn: GatewayNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:GatewayNode [internal]
|   |   |   |   |-- LoadBalancerNode.js
|   |   |   |   |   |-- module:LoadBalancerNode.js
|   |   |   |   |   |-- fn: LoadBalancerNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:LoadBalancerNode [internal]
|   |   |   |   |-- MessageEdge.js
|   |   |   |   |   |-- fn: MessageEdge({
    id,
    sourceX,
    sourceY,
    targetX,
    targetY,
    data,
    style = {},
  }) [internal]
|   |   |   |   |   |-- component:MessageEdge [internal]
|   |   |   |   |-- nodePresets.js
|   |   |   |   |   |-- module:nodePresets.js
|   |   |   |   |   |-- fn: generateId(type) [internal]
|   |   |   |   |   |-- fn: createNode(type, position, label = '', notes = '') [exported]
|   |   |   |   |   |-- fn: createEdge(sourceId, targetId, label = '') [exported]
|   |   |   |   |   |-- fn: getNodeTypePalette() [exported]
|   |   |   |   |-- QueueNode.js
|   |   |   |   |   |-- module:QueueNode.js
|   |   |   |   |   |-- fn: QueueNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:QueueNode [internal]
|   |   |   |   |-- SequenceDiagramNodeTypes.js
|   |   |   |   |   |-- module:SequenceDiagramNodeTypes.js
|   |   |   |   |   |-- component:ActorNode [exported]
|   |   |   |   |   |-- component:ParticipantNode [exported]
|   |   |   |   |   |-- component:LifelineNode [exported]
|   |   |   |   |   |-- component:CombinedFragmentNode [exported]
|   |   |   |   |   |-- component:NoteNode [exported]
|   |   |   |   |   |-- component:GateNode [exported]
|   |   |   |   |   |-- component:MessageTypes [exported]
|   |   |   |   |   |-- component:FragmentTypes [exported]
|   |   |   |   +-- ServiceNode.js
|   |   |   |       |-- module:ServiceNode.js
|   |   |   |       |-- fn: ServiceNode({ data, isConnectable }) [internal]
|   |   |   |       |-- component:ServiceNode [internal]
|   |   |   |-- styles
|   |   |   |-- utils
|   |   |   |   |-- conversion.js
|   |   |   |   |   |-- module:conversion.js
|   |   |   |   |   |-- fn: getNodeType(mermaidNodeDef) [internal]
|   |   |   |   |   |-- fn: getNodeLabel(nodeText) [internal]
|   |   |   |   |   |-- fn: mermaidToReactFlow(mermaidCode) [exported]
|   |   |   |   |   |-- fn: reactFlowToMermaid({ nodes, edges }) [exported]
|   |   |   |   |   |-- component:MERMAID_NODE_TYPES [internal]
|   |   |   |   |-- nodePositioning.js
|   |   |   |   |   |-- module:nodePositioning.js
|   |   |   |   |   |-- fn: getNodePositionForType(type, bounds, existingNodes) [exported]
|   |   |   |   |   |-- fn: getLoadBalancerPosition(bounds, existingNodes) [internal]
|   |   |   |   |   |-- fn: getCachePosition(bounds, existingNodes) [internal]
|   |   |   |   |   |-- fn: getApiGatewayPosition(bounds, existingNodes) [internal]
|   |   |   |   |   |-- fn: getDatabasePosition(bounds, existingNodes) [internal]
|   |   |   |   |   |-- fn: getDefaultPosition(bounds, existingNodes) [internal]
|   |   |   |   |-- nodePresets.js
|   |   |   |   |   |-- module:nodePresets.js
|   |   |   |   |   |-- fn: getNodeConfig(type) [exported]
|   |   |   |   |   |-- fn: createNode(type, position, label = '', notes = '') [exported]
|   |   |   |   |   |-- fn: createEdge(sourceId, targetId, label = '') [exported]
|   |   |   |   |   |-- fn: getNodeTypePalette() [exported]
|   |   |   |   |   |-- component:NODE_TYPES [exported]
|   |   |   |   +-- sequenceDiagramUtils.js
|   |   |   |       |-- fn: generateMermaidCode(nodes, edges) [internal]
|   |   |   |       |-- fn: mermaidToReactFlow(mermaidCode) [internal]
|   |   |   |       |-- fn: findClosestParticipant(note, participants) [internal]
|   |   |   |       |-- fn: findParticipantsInFragment(fragment, participants) [internal]
|   |   |   |       |-- fn: normalizeSequenceDiagram(nodes, edges) [internal]
|   |   |   |       |-- method: generateMermaidCode(nodes, edges)
|   |   |   |       |-- method: forEach(participant => {
      if (participant.type === 'actor')
|   |   |   |       |-- method: mermaidToReactFlow(mermaidCode)
|   |   |   |       |-- method: findClosestParticipant(note, participants)
|   |   |   |       |-- method: findParticipantsInFragment(fragment, participants)
|   |   |   |       |-- method: normalizeSequenceDiagram(nodes, edges)
|   |   |   |       |-- method: map(node => {
      // Fix participant positions
      if (node.type === 'actor' || node.type === 'participant')
|   |   |   |-- AiSuggestionsPanel.js
|   |   |   |   |-- module:AiSuggestionsPanel.js
|   |   |   |   |-- fn: AiSuggestionsPanel({
  diagram,
  onClose,
  onApplySuggestion,
  sessionId
}) [internal]
|   |   |   |   |-- fn: handleApplySuggestion(change) [internal]
|   |   |   |   |-- fn: renderImmediateActions(actions) [internal]
|   |   |   |   |-- fn: renderAiSuggestions(aiSuggestions) [internal]
|   |   |   |   |-- fn: renderProposedChanges(changes) [internal]
|   |   |   |   |-- component:AiSuggestionsPanel [internal]
|   |   |   |-- CustomNode.js
|   |   |   |   |-- module:CustomNode.js
|   |   |   |   |-- fn: CustomNode({ data }) [internal]
|   |   |   |   |-- component:CustomNode [internal]
|   |   |   |   |-- component:NodeIcon [internal]
|   |   |   |-- DiagramAnalysis.js
|   |   |   |   |-- module:DiagramAnalysis.js
|   |   |   |   |-- fn: AnalysisSection({ title, items, icon: Icon }) [internal]
|   |   |   |   |-- fn: DiagramAnalysis({ analysis, onClose, onApplySuggestion }) [internal]
|   |   |   |   |-- fn: renderSuggestionCard(suggestion) [internal]
|   |   |   |   |-- component:AnalysisSection [internal]
|   |   |   |   |-- component:DiagramAnalysis [internal]
|   |   |   |-- DiagramAnalysisPanel.js
|   |   |   |   |-- module:DiagramAnalysisPanel.js
|   |   |   |   |-- fn: DiagramAnalysisPanel({ 
  nodes, 
  edges, 
  updateNodes, 
  updateEdges,
  onClose,
  sessionId 
}) [internal]
|   |   |   |   |-- fn: renderSuggestionCard(suggestion) [internal]
|   |   |   |   |-- fn: renderAnalysisSection(title, items, icon) [internal]
|   |   |   |   |-- component:DiagramAnalysisPanel [internal]
|   |   |   |-- DiagramEvaluation.js
|   |   |   |   |-- module:DiagramEvaluation.js
|   |   |   |   |-- fn: CriterionCard({ title, score, previousScore, feedback, suggestions }) [internal]
|   |   |   |   |-- fn: ProgressChart({ evaluationHistory }) [internal]
|   |   |   |   |-- fn: DiagramEvaluation({ 
  sessionId, 
  evaluation, 
  previousEvaluation,
  onClose 
}) [internal]
|   |   |   |   |-- component:CriterionCard [internal]
|   |   |   |   |-- component:Arrow [internal]
|   |   |   |   |-- component:ProgressChart [internal]
|   |   |   |   |-- component:DiagramEvaluation [internal]
|   |   |   |-- DiagramEvaluationPanel.js
|   |   |   |   |-- module:DiagramEvaluationPanel.js
|   |   |   |   |-- fn: DiagramEvaluationPanel({
  diagram,
  onClose,
  sessionId
}) [internal]
|   |   |   |   |-- fn: renderScoreCard(criterion, score) [internal]
|   |   |   |   |-- fn: getScoreColor(score) [internal]
|   |   |   |   |-- fn: getScoreIcon(criterion) [internal]
|   |   |   |   |-- fn: renderPatterns(patterns) [internal]
|   |   |   |   |-- fn: renderRecommendations(recommendations) [internal]
|   |   |   |   |-- component:DiagramEvaluationPanel [internal]
|   |   |   |-- DiagramPanel.js
|   |   |   |   |-- module:DiagramPanel.js
|   |   |   |   |-- fn: DiagramPanel({
  hideModes = false,
  sessionId,
  sessionType = 'coaching',
  initialDiagram = null,
  onClose,
  onSave,
  onRefresh,
  onAiSuggest,
  onSaveAndContinue,
}) [internal]
|   |   |   |   |-- component:DiagramPanel [internal]
|   |   |   |-- DiagramProgressView.js
|   |   |   |   |-- module:DiagramProgressView.js
|   |   |   |   |-- fn: DiagramProgressView({ sessionId, diagramId }) [internal]
|   |   |   |   |-- fn: formatSnapshotData(snapshots) [internal]
|   |   |   |   |-- fn: renderScoresChart() [internal]
|   |   |   |   |-- fn: renderPatternProgress() [internal]
|   |   |   |   |-- fn: renderComplexityMetrics() [internal]
|   |   |   |   |-- fn: renderRecommendations() [internal]
|   |   |   |   |-- component:DiagramProgressView [internal]
|   |   |   |-- DiagramSuggestionManager.js
|   |   |   |   |-- class:DiagramSuggestionManager [exported]
|   |   |   |   |-- method: constructor(nodes, edges, updateNodes, updateEdges)
|   |   |   |   |-- method: applySuggestion(suggestion)
|   |   |   |   |-- method: applyComponentSuggestion(suggestion)
|   |   |   |   |-- method: applyPatternSuggestion(suggestion)
|   |   |   |   |-- method: applyScalabilitySuggestion(suggestion)
|   |   |   |   |-- method: applySecuritySuggestion(suggestion)
|   |   |   |   |-- method: calculateOptimalPosition(componentType)
|   |   |   |   |-- method: calculateDiagramBounds()
|   |   |   |   |-- method: getComponentTypeFromSuggestion(suggestion)
|   |   |   |-- DiagramToolbar.js
|   |   |   |   |-- module:DiagramToolbar.js
|   |   |   |   |-- fn: DiagramToolbar({ mode, setMode, onAddNode, hideModes = false }) [internal]
|   |   |   |   |-- component:DiagramToolbar [internal]
|   |   |   |-- ElementTypeIndicator.js
|   |   |   |   |-- module:ElementTypeIndicator.js
|   |   |   |   |-- fn: ElementTypeIndicator({ type, size = 'md', showLabel = false, className = '' }) [internal]
|   |   |   |   |-- component:ElementTypeIndicator [internal]
|   |   |   |-- MermaidRenderer.js
|   |   |   |   |-- module:MermaidRenderer.js
|   |   |   |   |-- fn: MermaidRenderer({ code, onError }) [internal]
|   |   |   |   |-- fn: cleanup() [internal]
|   |   |   |   |-- component:MermaidRenderer [internal]
|   |   |   |-- NodePalette.js
|   |   |   |   |-- module:NodePalette.js
|   |   |   |   |-- fn: NodePalette({ onNodeAdd }) [exported]
|   |   |   |   |-- method: NodePalette({ onNodeAdd })
|   |   |   |   |-- component:NodePalette [internal]
|   |   |   |-- PatternVisualizer.js
|   |   |   |   |-- module:PatternVisualizer.js
|   |   |   |   |-- fn: PatternVisualizer({ patterns, suggestions }) [internal]
|   |   |   |   |-- fn: getPatternStatus(pattern) [internal]
|   |   |   |   |-- component:PatternVisualizer [internal]
|   |   |   |-- ReactFlowDiagram.js
|   |   |   |   |-- module:ReactFlowDiagram.js
|   |   |   |   |-- fn: Flow({ 
  initialNodes, 
  initialEdges, 
  onNodesChange, 
  onEdgesChange, 
  onConnect,
  onDiagramUpdate 
}) [internal]
|   |   |   |   |-- fn: ReactFlowDiagramWithProvider(props) [internal]
|   |   |   |   |-- method: map(n => {
      if (n.id === selectedNode.id)
|   |   |   |   |-- component:Flow [internal]
|   |   |   |   |-- component:ReactFlowDiagramWithProvider [internal]
|   |   |   |-- ScorePanel.js
|   |   |   |   |-- module:ScorePanel.js
|   |   |   |   |-- fn: ScorePanel({ scores, improvements }) [internal]
|   |   |   |   |-- fn: formatScoreData() [internal]
|   |   |   |   |-- component:ScorePanel [internal]
|   |   |   |-- SequenceDiagram.js
|   |   |   |   |-- module:SequenceDiagram.js
|   |   |   |   |-- fn: generateMermaidCode(nodes, edges) [internal]
|   |   |   |   |-- fn: return() [internal]
|   |   |   |   |-- fn: MessageEdge({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  data,
  style = {},
}) [internal]
|   |   |   |   |-- fn: SequenceDiagram({ initialDiagram, onDiagramUpdate }) [internal]
|   |   |   |   |-- fn: SequenceDiagramWrapped(props) [internal]
|   |   |   |   |-- method: generateMermaidCode(nodes, edges)
|   |   |   |   |-- method: forEach(participant => {
    if (participant.type === 'actor')
|   |   |   |   |-- component:ActorNode [internal]
|   |   |   |   |-- component:ParticipantNode [internal]
|   |   |   |   |-- component:LifelineNode [internal]
|   |   |   |   |-- component:MessageEdge [internal]
|   |   |   |   |-- component:SequenceDiagram [internal]
|   |   |   |   |-- component:SequenceDiagramWrapped [internal]
|   |   |   |-- SequenceDiagramManager.js
|   |   |   |   |-- module:SequenceDiagramManager.js
|   |   |   |   |-- fn: SequenceDiagramManager({ initialDiagram, onDiagramUpdate }) [internal]
|   |   |   |   |-- method: map(node => {
      // If this is a lifeline, find its parent and update position
      if (node.type === 'lifeline' && node.data?.participantId)
|   |   |   |   |-- component:SequenceDiagramManager [internal]
|   |   |   |-- SystemArchitectureDiagram.js
|   |   |   |   |-- module:SystemArchitectureDiagram.js
|   |   |   |   |-- fn: SystemArchitectureDiagram({ initialNodes, initialEdges, onNodesChange, onEdgesChange, onConnect }) [exported]
|   |   |   |   |-- method: SystemArchitectureDiagram({ initialNodes, initialEdges, onNodesChange, onEdgesChange, onConnect })
|   |   |   |   |-- component:SystemArchitectureDiagram [internal]
|   |   |   +-- SystemSequenceDiagram.js
|   |   |       |-- module:SystemSequenceDiagram.js
|   |   |       |-- fn: SystemSequenceDiagram({ 
  initialDiagram,
  onDiagramUpdate 
}) [internal]
|   |   |       |-- fn: generateMermaidCode(nodes, edges) [internal]
|   |   |       |-- component:SystemSequenceDiagram [internal]
|   |   |-- evaluation
|   |   |   +-- EvaluationSummary.js
|   |   |       |-- module:EvaluationSummary.js
|   |   |       |-- fn: EvaluationSummary({ evaluation, scores }) [internal]
|   |   |       |-- fn: getScoreColor(score) [internal]
|   |   |       |-- component:EvaluationSummary [internal]
|   |   |-- CoachAgentInterface.js
|   |   |   |-- module:CoachAgentInterface.js
|   |   |   |-- fn: CoachAgentInterface() [exported]
|   |   |   |-- method: CoachAgentInterface()
|   |   |   |-- component:CoachAgentInterface [exported]
|   |   |-- ConciseModeToggle.js
|   |   |   |-- module:ConciseModeToggle.js
|   |   |   |-- fn: ConciseModeToggle({ isEnabled, onToggle }) [internal]
|   |   |   |-- component:ConciseModeToggle [internal]
|   |   |-- ExperienceLevelSelector.js
|   |   |   |-- module:ExperienceLevelSelector.js
|   |   |   |-- fn: ExperienceLevelSelector({ currentLevel, onLevelChange }) [internal]
|   |   |   |-- component:ExperienceLevelSelector [internal]
|   |   |-- MermaidToolbar.js
|   |   |   |-- module:MermaidToolbar.js
|   |   |   |-- fn: ComponentButton({ icon, label, snippet, onInsert }) [internal]
|   |   |   |-- fn: MermaidToolbar({ onInsert }) [internal]
|   |   |   |-- component:ComponentButton [internal]
|   |   |   |-- component:MermaidToolbar [internal]
|   |   |-- MetricCard.js
|   |   |   |-- module:MetricCard.js
|   |   |   |-- fn: MetricCard({ title, value, icon, iconBgColor, progress, subtext }) [internal]
|   |   |   |-- component:MetricCard [internal]
|   |   |-- RealTimeFeedback.js
|   |   |   |-- module:RealTimeFeedback.js
|   |   |   |-- fn: RealTimeFeedback({ section, content, onFeedback }) [internal]
|   |   |   |-- component:RealTimeFeedback [internal]
|   |   |-- Sidebar.js
|   |   |   |-- module:Sidebar.js
|   |   |   |-- fn: Sidebar({ activeTab }) [internal]
|   |   |   |-- component:Sidebar [internal]
|   |   |-- SimpleFlow.js
|   |   |   |-- module:SimpleFlow.js
|   |   |   |-- fn: Flow() [internal]
|   |   |   |-- fn: SimpleFlowWithProvider() [internal]
|   |   |   |-- method: Flow()
|   |   |   |-- method: SimpleFlowWithProvider()
|   |   |   |-- component:Flow [internal]
|   |   |   |-- component:SimpleFlowWithProvider [exported]
|   |   |-- SystemDesignDiagram.tsx
|   |   |   |-- module:SystemDesignDiagram.tsx
|   |   |-- TestConnection.js
|   |   +-- Workbook.js
|   |       |-- module:Workbook.js
|   |       |-- fn: Workbook({ sessionId, userId, initialData }) [internal]
|   |       |-- fn: handleFeedback(section, feedback) [internal]
|   |       |-- component:Workbook [internal]
|   |-- config
|   |   +-- aiConfig.js
|   |       |-- module:aiConfig.js
|   |-- contexts
|   |   +-- AuthContext.js
|   |       |-- module:AuthContext.js
|   |       |-- fn: AuthProvider({ children }) [exported]
|   |       |-- fn: logout() [internal]
|   |       |-- fn: useAuth() [exported]
|   |       |-- component:AuthContext [internal]
|   |       |-- component:AuthProvider [exported]
|   |-- data
|   |   +-- persona
|   |       +-- coachPersona.js
|   |           |-- module:coachPersona.js
|   |-- hooks
|   |   +-- useSession.js
|   |       |-- fn: useSession(sessionId) [internal]
|   |       |-- fn: fetchSession() [internal]
|   |       |-- fn: updateSession(newData) [internal]
|   |       |-- method: useSession(sessionId)
|   |       |-- method: fetchSession()
|   |-- pages
|   |   |-- api
|   |   |   |-- auth
|   |   |   |   |-- login.js
|   |   |   |   |   |-- module:login.js
|   |   |   |   |   |-- fn: handler(req, res) [internal]
|   |   |   |   |   |-- method: handler(req, res)
|   |   |   |   +-- me.js
|   |   |   |       |-- module:me.js
|   |   |   |       |-- fn: handler(req, res) [internal]
|   |   |   |       |-- method: handler(req, res)
|   |   |   |-- coaching
|   |   |   |   +-- message.js
|   |   |   |       |-- module:message.js
|   |   |   |       |-- fn: handler(req, res) [internal]
|   |   |   |       |-- method: handler(req, res)
|   |   |   |-- mock
|   |   |   |   +-- coaching
|   |   |   |       |-- services
|   |   |   |       |   +-- aiService.js
|   |   |   |       |       |-- module:aiService.js
|   |   |   |       |       |-- class:AIService [exported]
|   |   |   |       |       |-- method: constructor(config)
|   |   |   |       |       |-- method: sendMessage(messages, options = {})
|   |   |   |       |-- sessions
|   |   |   |       |   |-- [id]
|   |   |   |       |   +-- [id].js
|   |   |   |       |       |-- module:[id].js
|   |   |   |       |       |-- fn: handler(req, res) [internal]
|   |   |   |       |       |-- method: handler(req, res)
|   |   |   |       |-- [id].js
|   |   |   |       |   |-- module:[id].js
|   |   |   |       |   |-- fn: handler(req, res) [internal]
|   |   |   |       |   |-- method: handler(req, res)
|   |   |   |       |-- message.js
|   |   |   |       |   |-- module:message.js
|   |   |   |       |   |-- fn: handler(req, res) [internal]
|   |   |   |       |   |-- method: handler(req, res)
|   |   |   |       +-- sessions.js
|   |   |   |           |-- module:sessions.js
|   |   |   |           |-- fn: handler(req, res) [internal]
|   |   |   |           |-- method: handler(req, res)
|   |   |   +-- services
|   |   |       +-- aiService.js
|   |   |           |-- module:aiService.js
|   |   |           |-- class:AIService [exported]
|   |   |           |-- method: constructor(config)
|   |   |           |-- method: sendMessage(messages, options = {})
|   |   |-- auth
|   |   |   |-- login.js
|   |   |   |   |-- module:login.js
|   |   |   |   |-- fn: Login() [internal]
|   |   |   |   |-- method: Login()
|   |   |   |   |-- component:Login [exported]
|   |   |   +-- register.js
|   |   |       |-- module:register.js
|   |   |       |-- fn: Register() [internal]
|   |   |       |-- method: Register()
|   |   |       |-- component:Register [exported]
|   |   |-- coaching
|   |   |   |-- [id].js
|   |   |   |   |-- module:[id].js
|   |   |   |   |-- fn: handleClickOutside(event) [internal]
|   |   |   |   |-- fn: CoachingSessionPage() [internal]
|   |   |   |   |-- fn: setActiveDiagramTab(tabId) [internal]
|   |   |   |   |-- fn: updateFormData(section, data) [internal]
|   |   |   |   |-- fn: detectCurrentTopic(conversation) [internal]
|   |   |   |   |-- fn: handleDiagramSuggestions(suggestions) [internal]
|   |   |   |   |-- fn: handleAcceptSuggestions() [internal]
|   |   |   |   |-- fn: handleDiscardSuggestions() [internal]
|   |   |   |   |-- fn: handleDiagramUpdate(diagramData) [internal]
|   |   |   |   |-- fn: renderDiagramEditor() [internal]
|   |   |   |   |-- fn: getActiveWorkbookComponent() [internal]
|   |   |   |   |-- method: handleClickOutside(event)
|   |   |   |   |-- method: code({ node, inline, className, children, ...props })
|   |   |   |   |-- component:MermaidRenderer [internal]
|   |   |   |   |-- component:SystemArchitectureDiagram [internal]
|   |   |   |   |-- component:SystemSequenceDiagram [internal]
|   |   |   |   |-- component:CoachingSessionPage [internal]
|   |   |   +-- index.js
|   |   |       |-- module:index.js
|   |   |       |-- fn: CoachingIndexPage() [internal]
|   |   |       |-- method: CoachingIndexPage()
|   |   |       |-- component:CoachingIndexPage [exported]
|   |   |-- interviews
|   |   |   |-- results
|   |   |   |   +-- [id].js
|   |   |   |       |-- module:[id].js
|   |   |   |       |-- fn: InterviewResultsPage() [internal]
|   |   |   |       |-- fn: getScoreColor(score) [internal]
|   |   |   |       |-- fn: getScoreIcon(score) [internal]
|   |   |   |       |-- method: InterviewResultsPage()
|   |   |   |       |-- component:InterviewResultsPage [exported]
|   |   |   |-- [id].js
|   |   |   |   |-- module:[id].js
|   |   |   |   |-- fn: InterviewPage() [internal]
|   |   |   |   |-- fn: updateTimeRemaining() [internal]
|   |   |   |   |-- fn: formatTime(ms) [internal]
|   |   |   |   |-- method: InterviewPage()
|   |   |   |   |-- component:InterviewPage [exported]
|   |   |   +-- index.js
|   |   |       |-- module:index.js
|   |   |       |-- fn: InterviewsPage() [internal]
|   |   |       |-- fn: openProblemDetails(problem) [internal]
|   |   |       |-- fn: closeProblemDetails() [internal]
|   |   |       |-- method: InterviewsPage()
|   |   |       |-- component:InterviewsPage [exported]
|   |   |-- _app.js
|   |   |   |-- module:_app.js
|   |   |   |-- fn: MyApp(props) [exported]
|   |   |   |-- method: MyApp(props)
|   |   |   |-- component:MyApp [internal]
|   |   |-- APIDesignPage.js
|   |   |   |-- module:APIDesignPage.js
|   |   |   |-- fn: EnhancedAPIDesignPage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: addAPI() [internal]
|   |   |   |-- fn: removeAPI(id) [internal]
|   |   |   |-- fn: updateAPI(id, field, value) [internal]
|   |   |   |-- fn: toggleExpand(id) [internal]
|   |   |   |-- fn: addRequestParam(apiId) [internal]
|   |   |   |-- fn: removeRequestParam(apiId, paramId) [internal]
|   |   |   |-- fn: updateRequestParam(apiId, paramId, field, value) [internal]
|   |   |   |-- fn: updateApiType(type) [internal]
|   |   |   |-- component:EnhancedAPIDesignPage [internal]
|   |   |-- chat.js
|   |   |   |-- module:chat.js
|   |   |   |-- fn: ChatPage() [internal]
|   |   |   |-- method: ChatPage()
|   |   |-- dashboard.js
|   |   |   |-- module:dashboard.js
|   |   |   |-- fn: Dashboard({ onSelectWorkbook }) [internal]
|   |   |   |-- method: Dashboard({ onSelectWorkbook })
|   |   |   |-- component:Dashboard [exported]
|   |   |-- DataModelPage.js
|   |   |   |-- module:DataModelPage.js
|   |   |   |-- fn: EnhancedDataModelPage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: handleChange(e) [internal]
|   |   |   |-- component:EnhancedDataModelPage [internal]
|   |   |-- index.js
|   |   |   |-- module:index.js
|   |   |   |-- fn: Home() [internal]
|   |   |   |-- method: Home()
|   |   |   |-- component:Home [exported]
|   |   |-- ReliabilitySecurityPage.js
|   |   |   |-- module:ReliabilitySecurityPage.js
|   |   |   |-- fn: ReliabilitySecurityPage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: addReliabilityTarget() [internal]
|   |   |   |-- fn: updateReliabilityTarget(id, field, value) [internal]
|   |   |   |-- fn: removeReliabilityTarget(id) [internal]
|   |   |   |-- fn: addFailureScenario() [internal]
|   |   |   |-- fn: updateFailureScenario(id, field, value) [internal]
|   |   |   |-- fn: removeFailureScenario(id) [internal]
|   |   |   |-- fn: updateAuthMethod(method, value) [internal]
|   |   |   |-- fn: updateDataProtection(category, field, value) [internal]
|   |   |   |-- fn: addSecurityMeasure() [internal]
|   |   |   |-- fn: updateSecurityMeasure(id, field, value) [internal]
|   |   |   |-- fn: removeSecurityMeasure(id) [internal]
|   |   |   |-- fn: addComplianceRequirement() [internal]
|   |   |   |-- fn: updateComplianceRequirement(id, field, value) [internal]
|   |   |   |-- fn: removeComplianceRequirement(id) [internal]
|   |   |   |-- fn: toggleSection(section) [internal]
|   |   |   |-- component:ReliabilitySecurityPage [internal]
|   |   |-- RequirementsPage.js
|   |   |   |-- module:RequirementsPage.js
|   |   |   |-- fn: EnhancedRequirementsPage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: updateFunctionalReq(id, text) [internal]
|   |   |   |-- fn: toggleFunctionalReq(id) [internal]
|   |   |   |-- fn: updateNonFunctionalReq(id, text) [internal]
|   |   |   |-- fn: handleAddFunctionalReq() [internal]
|   |   |   |-- fn: handleAddNonFunctionalReq() [internal]
|   |   |   |-- fn: handleDeleteReq(index, type) [internal]
|   |   |   |-- fn: handleDiagramOpen() [internal]
|   |   |   |-- fn: handleDiagramClose() [internal]
|   |   |   |-- component:EnhancedRequirementsPage [internal]
|   |   |-- ScalingStrategyPage.js
|   |   |   |-- module:ScalingStrategyPage.js
|   |   |   |-- fn: EnhancedScalingStrategyPage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: toggleSection(sectionId) [internal]
|   |   |   |-- fn: updateFieldValue(sectionId, fieldId, value) [internal]
|   |   |   |-- fn: toggleStrategy(strategyId) [internal]
|   |   |   |-- fn: updateStrategyDescription(strategyId, description) [internal]
|   |   |   |-- fn: addStrategyComponent(strategyId) [internal]
|   |   |   |-- fn: updateStrategyComponent(strategyId, componentId, field, value) [internal]
|   |   |   |-- fn: removeStrategyComponent(strategyId, componentId) [internal]
|   |   |   |-- fn: addBottleneck() [internal]
|   |   |   |-- fn: updateBottleneck(bottleneckId, field, value) [internal]
|   |   |   |-- fn: removeBottleneck(bottleneckId) [internal]
|   |   |   |-- method: map(strategy => {
      if (strategy.id === strategyId)
|   |   |   |-- component:EnhancedScalingStrategyPage [internal]
|   |   |-- SystemArchitecturePage.js
|   |   |   |-- module:SystemArchitecturePage.js
|   |   |   |-- fn: EnhancedSystemArchitecturePage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: handleChange(e) [internal]
|   |   |   |-- component:EnhancedSystemArchitecturePage [internal]
|   |   |-- test-flow.js
|   |   |   |-- module:test-flow.js
|   |   |   |-- fn: TestPage() [internal]
|   |   |   |-- method: TestPage()
|   |   |   |-- component:SimpleFlow [internal]
|   |   |   |-- component:TestPage [exported]
|   |   |-- WorkbookLayout.js
|   |   |   |-- module:WorkbookLayout.js
|   |   |   |-- fn: getTabStyles(tabId, isActive) [internal]
|   |   |   |-- fn: getMobileTabStyles(tabId, isActive) [internal]
|   |   |   |-- fn: getCoachButtonStyles(tabId) [internal]
|   |   |   |-- fn: getProgressBarStyles(tabId) [internal]
|   |   |   |-- fn: getExportButtonStyles(tabId) [internal]
|   |   |   |-- fn: getCoachPanelBgStyle(tabId) [internal]
|   |   |   |-- fn: getCoachPanelTextStyle(tabId) [internal]
|   |   |   |-- fn: getCoachInputFocusStyle(tabId) [internal]
|   |   |   |-- fn: WorkbookLayout({ onBack, sessionId }) [internal]
|   |   |   |-- fn: updateFormData(section, data) [internal]
|   |   |   |-- fn: getActivePageComponent() [internal]
|   |   |   |-- component:WorkbookLayout [internal]
|   |   +-- WorkbookPageWrapper.js
|   |       |-- module:WorkbookPageWrapper.js
|   |       |-- fn: WorkbookPageWrapper({ children }) [internal]
|   |       |-- component:WorkbookPageWrapper [internal]
|   |-- public
|   |-- src
|   |   +-- config
|   |       +-- api.js
|   |           |-- module:api.js
|   |-- styles
|   |   +-- theme.js
|   |       |-- module:theme.js
|   |-- utils
|   |   |-- api.js
|   |   |   |-- module:api.js
|   |   |-- createEmotionCache.js
|   |   |   |-- module:createEmotionCache.js
|   |   |   |-- fn: createEmotionCache() [internal]
|   |   |   |-- method: createEmotionCache()
|   |   +-- workbookStorage.js
|   |       |-- module:workbookStorage.js
|   |       |-- fn: executedFunction(...args) [internal]
|   |       |-- fn: debounce(func, wait) [internal]
|   |       |-- fn: later() [internal]
|   |       |-- method: executedFunction(...args)
|   |-- next.config.js
|   |   |-- module:next.config.js
|   |   |-- method: rewrites()
|   |-- postcss.config.js
|   |   |-- module:postcss.config.js
|   +-- tailwind.config.js
|       |-- module:tailwind.config.js
|-- components
|   +-- WorkbookLayout.js
|       |-- fn: WorkbookLayout({ sessionId }) [internal]
|-- data
|   |-- knowledge_base
|   |   +-- facebook
|   |       |-- architecture
|   |       |   +-- core_tech.md
|   |       |-- design_questions
|   |       |   |-- messenger.md
|   |       |   |-- news_feed.md
|   |       |   +-- photo_storage.md
|   |       |-- evaluation_criteria
|   |       |   +-- scoring_rubric.md
|   |       +-- interview_format
|   |           +-- standard_progression.md
|   |-- persona
|   |   |-- coachPersona.js
|   |   |   |-- module:coachPersona.js
|   |   |-- graderPersona.js
|   |   |   |-- module:graderPersona.js
|   |   +-- interviewerPersona.js
|   |       |-- module:interviewerPersona.js
|   |-- tempresults
|   |   +-- 1
|   |-- diagram_structure.js
|   |-- enhanced_skills.js
|   |   |-- module:enhanced_skills.js
|   |-- problems.js
|   |   |-- module:problems.js
|   +-- workbook_progress.js
|-- server
|   |-- __pycache__
|   |-- config
|   |   |-- aiConfig.js
|   |   |   |-- module:aiConfig.js
|   |   +-- db.js
|   |       |-- module:db.js
|   |-- logs
|   |-- middleware
|   |   +-- auth.js
|   |       |-- module:auth.js
|   |-- models
|   |   |-- Diagram.js
|   |   |   |-- module:Diagram.js
|   |   |   |-- component:DiagramSchema [internal]
|   |   |-- Evaluation.js
|   |   |   |-- module:Evaluation.js
|   |   |-- Interview.js
|   |   |   |-- module:Interview.js
|   |   |-- Problem.js
|   |   |   |-- module:Problem.js
|   |   |-- Session.js
|   |   |   |-- module:Session.js
|   |   |-- User.js
|   |   |   |-- module:User.js
|   |   +-- Workbook.js
|   |       |-- module:Workbook.js
|   |       |-- method: pre('save', function(next)
|   |-- prompts
|   |   +-- coachingPrompt.js
|   |       |-- module:coachingPrompt.js
|   |       |-- fn: getSystemPrompt(problem) [internal]
|   |-- routes
|   |   |-- api
|   |   |   +-- coaching.js
|   |   |       |-- module:coaching.js
|   |   |-- ai.js
|   |   |   |-- module:ai.js
|   |   |-- auth.js
|   |   |   |-- module:auth.js
|   |   |-- coaching.js
|   |   |   |-- module:coaching.js
|   |   |-- diagrams.js
|   |   |   |-- module:diagrams.js
|   |   |-- grader.js
|   |   |   |-- module:grader.js
|   |   |-- interviews.js
|   |   |   |-- module:interviews.js
|   |   |   |-- fn: handleError(res, error, defaultMessage = 'An unexpected error occurred') [internal]
|   |   |-- problems.js
|   |   |   |-- module:problems.js
|   |   |   |-- fn: loadProblems() [internal]
|   |   |   |-- method: loadProblems()
|   |   |-- sessions.js
|   |   |   |-- module:sessions.js
|   |   |-- users.js
|   |   |   |-- module:users.js
|   |   +-- workbook.js
|   |       |-- module:workbook.js
|   |-- scripts
|   |   |-- seedData
|   |   |   |-- problems.js
|   |   |   |   |-- module:problems.js
|   |   |   +-- workbookTemplate.js
|   |   |       |-- module:workbookTemplate.js
|   |   |-- checkConnection.js
|   |   |   |-- module:checkConnection.js
|   |   |   |-- fn: checkConnection() [exported]
|   |   |   |-- method: checkConnection()
|   |   |-- checkDatabase.js
|   |   |   |-- fn: checkDatabase() [internal]
|   |   |   |-- method: checkDatabase()
|   |   |-- initializeDatabase.js
|   |   |   |-- module:initializeDatabase.js
|   |   |   |-- fn: recreateIndexes() [internal]
|   |   |   |-- fn: seedInitialData() [internal]
|   |   |   |-- fn: verifySetup() [internal]
|   |   |   |-- fn: initializeDatabase() [exported]
|   |   |   |-- method: recreateIndexes()
|   |   |   |-- method: seedInitialData()
|   |   |   |-- method: verifySetup()
|   |   |   |-- method: initializeDatabase()
|   |   |-- seedDatabase.js
|   |   |   |-- module:seedDatabase.js
|   |   |   |-- fn: seedProblems() [internal]
|   |   |   |-- fn: seedDatabase() [exported]
|   |   |   |-- method: seedProblems()
|   |   |   |-- method: seedDatabase()
|   |   |-- seedProblems.js
|   |   |   |-- fn: seedDatabase() [internal]
|   |   |   |-- method: seedDatabase()
|   |   |-- setupDatabase.js
|   |   |   |-- module:setupDatabase.js
|   |   |   |-- fn: setupDatabase() [exported]
|   |   |   |-- method: setupDatabase()
|   |   |-- testConnection.js
|   |   |   |-- fn: testConnection() [internal]
|   |   |   |-- method: testConnection()
|   |   |-- testDiagramAnalysis.js
|   |   |   |-- module:testDiagramAnalysis.js
|   |   |   |-- fn: testDiagramAnalysis() [exported]
|   |   |   |-- method: testDiagramAnalysis()
|   |   |-- testWorkbook.js
|   |   |   |-- fn: createTestWorkbook() [internal]
|   |   |   |-- method: createTestWorkbook()
|   |   +-- verifyDatabase.js
|   |       |-- module:verifyDatabase.js
|   |       |-- fn: verifyCollections() [internal]
|   |       |-- fn: verifyIndexes() [internal]
|   |       |-- fn: verifyData() [exported]
|   |       |-- fn: verifyDatabase() [exported]
|   |       |-- method: verifyCollections()
|   |       |-- method: verifyIndexes()
|   |       |-- method: verifyData()
|   |       |-- method: verifyDatabase()
|   |-- services
|   |   |-- ai
|   |   |   |-- base
|   |   |   |   +-- AIService.js
|   |   |   |       |-- module:AIService.js
|   |   |   |       |-- class:AIService [internal]
|   |   |   |       |-- method: sendMessage(messages, options = {})
|   |   |   |       |-- method: generateResponse(messages, context, options = {})
|   |   |   |       |-- method: generateContent(prompt, options = {})
|   |   |   |-- aiFactory.js
|   |   |   |   |-- module:aiFactory.js
|   |   |   |   |-- class:AIFactory [internal]
|   |   |   |   |-- method: createService()
|   |   |   |-- aiService.js
|   |   |   |   |-- module:aiService.js
|   |   |   |   |-- class:AIService [internal]
|   |   |   |   |-- method: constructor(config)
|   |   |   |   |-- method: sendMessage(messages, options = {})
|   |   |   |   |-- method: analyzeDiagram(diagramData, context = {})
|   |   |   |-- claudeService.js
|   |   |   |   |-- module:claudeService.js
|   |   |   |   |-- class:ClaudeService extends AIService [internal]
|   |   |   |   |-- method: constructor(config = {})
|   |   |   |   |-- method: sendMessage(messages, options = {})
|   |   |   |-- coachingEngine.js
|   |   |   |   |-- module:coachingEngine.js
|   |   |   |   |-- class:CoachingEngine extends BaseEngine [internal]
|   |   |   |   |-- method: constructor(config = {})
|   |   |   |   |-- method: processMessage(sessionId, message, options = {})
|   |   |   |   |-- method: _updateWorkbookProgress(sessionId, message, response)
|   |   |   +-- index.js
|   |   |       |-- module:index.js
|   |   |-- coaching
|   |   |   |-- coachingService.js
|   |   |   |   |-- module:coachingService.js
|   |   |   |   |-- class:CoachingService [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: processMessage(sessionId, message, context = {})
|   |   |   |   |-- method: analyzeDiagram(sessionId, diagram)
|   |   |   |   |-- method: _logInteraction(sessionId, message, response)
|   |   |   +-- WorkbookService.js
|   |   |       |-- module:WorkbookService.js
|   |   |       |-- class:WorkbookService [internal]
|   |   |       |-- method: createWorkbook(userId, problemId)
|   |   |       |-- method: getWorkbook(sessionId)
|   |   |       |-- method: updateSection(sessionId, sectionPath, content)
|   |   |       |-- method: _initializeSections(problem)
|   |   |       |-- method: _getNestedSection(sections, path)
|   |   |-- diagram
|   |   |   |-- NodeTypes
|   |   |   |   +-- nodePresets.js
|   |   |   |       |-- module:nodePresets.js
|   |   |   |-- patterns
|   |   |   |   |-- PatternAnalyzer.js
|   |   |   |   |   |-- module:PatternAnalyzer.js
|   |   |   |   |   |-- class:PatternAnalyzer [internal]
|   |   |   |   |   |-- method: constructor()
|   |   |   |   |   |-- method: analyzePatterns(diagram)
|   |   |   |   |   |-- method: _performDetailedAnalysis(diagram, patternResults)
|   |   |   |   |   |-- method: _analyzePatternImplementation(diagram, pattern)
|   |   |   |   |   |-- method: _analyzeLBImplementation(diagram, pattern, analysis)
|   |   |   |   |   |-- method: _analyzeCachingImplementation(diagram, pattern, analysis)
|   |   |   |   |   |-- method: _analyzeQueueImplementation(diagram, pattern, analysis)
|   |   |   |   |   |-- method: _analyzePatternGap(diagram, missingPattern)
|   |   |   |   |   |-- method: _identifyOpportunities(diagram, patternResults)
|   |   |   |   |   |-- method: _calculateQualityMetrics(diagram, patternResults)
|   |   |   |   |   |-- method: _calculatePatternCoverage(patternResults)
|   |   |   |   |   |-- method: _calculateImplementationQuality(patternResults)
|   |   |   |   |   |-- method: _calculateArchitecturalFitness(diagram, patternResults)
|   |   |   |   |-- PatternLibrary.js
|   |   |   |   |   |-- module:PatternLibrary.js
|   |   |   |   |   |-- class:PatternLibrary [internal]
|   |   |   |   |   |-- method: constructor()
|   |   |   |   |   |-- method: getPatternSuggestions(nodes, edges)
|   |   |   |   |   |-- method: analyzePatternImplementation(pattern, nodes, edges)
|   |   |   |   |   |-- method: _analyzeCachingPattern(nodes, edges, analysis)
|   |   |   |   |   |-- method: _analyzeQueuePattern(nodes, edges, analysis)
|   |   |   |   |   |-- method: _analyzeMicroservicesPattern(nodes, edges, analysis)
|   |   |   |   |   |-- method: prioritizeSuggestions(suggestions)
|   |   |   |   |   |-- method: detectPatterns(nodes, edges)
|   |   |   |   |   |-- method: _identifyMissingPatterns(nodes, edges)
|   |   |   |   |-- PatternRegistry.js
|   |   |   |   |   |-- module:PatternRegistry.js
|   |   |   |   |   |-- class:PatternRegistry [internal]
|   |   |   |   |   |-- method: constructor()
|   |   |   |   |   |-- method: getPattern(patternId)
|   |   |   |   |   |-- method: getAllPatterns()
|   |   |   |   |   |-- method: getPatternsByCategory(category)
|   |   |   |   |   |-- method: detectPatterns(diagram)
|   |   |   |   |   |-- method: _matchesPattern(diagram, detection)
|   |   |   |   |   |-- method: _findPatternMatches(diagram, detection)
|   |   |   |   |   |-- method: _findMatchingNodeGroups(nodes, requirements)
|   |   |   |   |   |-- method: _validateConnections(nodes, edges, requiredConnections)
|   |   |   |   |   |-- method: _getRelevantEdges(nodes, edges)
|   |   |   |   |   |-- method: _analyzeImplementationQuality(diagram, pattern, matches)
|   |   |   |   |   |-- method: _matchesMetadata(edges, requiredMetadata)
|   |   |   |   +-- PatternTemplates.js
|   |   |   |       |-- module:PatternTemplates.js
|   |   |   |-- utils
|   |   |   |   +-- complexityCalculator.js
|   |   |   |       |-- module:complexityCalculator.js
|   |   |   |       |-- fn: calculateComplexity(nodes, edges) [internal]
|   |   |   |       |-- fn: calculateMaxDepth(nodes, edges) [internal]
|   |   |   |       |-- fn: buildAdjacencyList(nodes, edges) [internal]
|   |   |   |       |-- fn: findLongestPath(nodeId, adjacencyList, visited) [internal]
|   |   |   |       |-- fn: calculateComplexityScore(metrics) [internal]
|   |   |   |       |-- method: calculateComplexity(nodes, edges)
|   |   |   |       |-- method: calculateMaxDepth(nodes, edges)
|   |   |   |       |-- method: buildAdjacencyList(nodes, edges)
|   |   |   |       |-- method: forEach(edge => {
    if (adjacencyList[edge.source])
|   |   |   |       |-- method: findLongestPath(nodeId, adjacencyList, visited)
|   |   |   |       |-- method: calculateComplexityScore(metrics)
|   |   |   |-- diagramAiSuggester.js
|   |   |   |   |-- module:diagramAiSuggester.js
|   |   |   |   |-- class:DiagramAiSuggester [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: generateSuggestions(diagram, context)
|   |   |   |   |-- method: _identifyMissingPatterns(diagram)
|   |   |   |   |-- method: _buildPrompt(diagram, analysis, patterns, context)
|   |   |   |   |-- method: _generateImmediateActions(analysis, patterns)
|   |   |   |   |-- method: _generateProposedChanges(diagram, patterns)
|   |   |   |   |-- method: forEach(pattern => {
      switch (pattern)
|   |   |   |   |-- method: _calculateCenterX(nodes)
|   |   |   |   |-- method: _calculateCenterY(nodes)
|   |   |   |   |-- method: _findServiceNodes(nodes)
|   |   |   |   |-- method: _findDatabaseNodes(nodes)
|   |   |   |-- diagramAnalyzer.js
|   |   |   |   |-- module:diagramAnalyzer.js
|   |   |   |   |-- class:DiagramAnalyzer [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: analyzeDiagram(nodes, edges, type)
|   |   |   |-- diagramEvaluationService.js
|   |   |   |   |-- module:diagramEvaluationService.js
|   |   |   |   |-- class:DiagramEvaluationService [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: evaluateDiagram(diagram, type, context)
|   |   |   |   |-- method: _getCriteriaForType(type)
|   |   |   |   |-- method: _getCriterionConfig(criterion)
|   |   |   |   |-- method: _evaluateCriterion(diagram, criterion, config, context)
|   |   |   |   |-- method: _analyzeComponents(diagram)
|   |   |   |   |-- method: _identifyPatterns(diagram)
|   |   |   |   |-- method: _calculateOverallScore(scores)
|   |   |   |   |-- method: _normalizeDiagram(diagram, type)
|   |   |   |   |-- method: _storeEvaluation(evaluation, context)
|   |   |   |   |-- method: _analyzeRelationships(nodes, edges)
|   |   |   |   |-- method: _calculateComplexity(diagram)
|   |   |   |-- diagramManager.js
|   |   |   |   |-- module:diagramManager.js
|   |   |   |   |-- class:DiagramManager [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: createDiagram(type, initialData)
|   |   |   |   |-- method: updateDiagram(diagramId, updates)
|   |   |   |   |-- method: _initializeComponents(type, data)
|   |   |   |   |-- method: _generateMermaid(type, components)
|   |   |   |   |-- method: _mergeComponents(existing, updates)
|   |   |   |   |-- method: map(item => {
            if (item.id)
|   |   |   |   |-- method: getDiagram(diagramId)
|   |   |   |   |-- method: deleteDiagram(diagramId)
|   |   |   |-- diagramProgressTracker.js
|   |   |   |   |-- module:diagramProgressTracker.js
|   |   |   |   |-- class:DiagramProgressTracker [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: trackProgress(sessionId, diagramId, currentDiagram)
|   |   |   |   |-- method: _createSnapshot(diagram)
|   |   |   |   |-- method: _countComponents(diagram)
|   |   |   |   |-- method: _calculateComplexity(diagram)
|   |   |   |   |-- method: _identifyPatterns(diagram)
|   |   |   |   |-- method: _saveSnapshot(sessionId, diagramId, snapshot)
|   |   |   |   |-- method: _analyzeProgress(sessionId, diagramId)
|   |   |   |   |-- method: _getNewPatterns(previous, current)
|   |   |   |   |-- method: _getComplexityChange(previous, current)
|   |   |   |   |-- method: _calculateTrends(snapshots)
|   |   |   |   |-- method: _calculateScoreTrends(snapshots)
|   |   |   |   |-- method: _calculatePatternTrends(snapshots)
|   |   |   |   |-- method: _calculateComplexityTrends(snapshots)
|   |   |   |   |-- method: _calculateTrendMetrics(values)
|   |   |   |   |-- method: _calculateVolatility(values)
|   |   |   |   |-- method: _generateRecommendations(latest, trends)
|   |   |   |-- diagramScoringService.js
|   |   |   |   |-- module:diagramScoringService.js
|   |   |   |   |-- class:DiagramScoringService [internal]
|   |   |   |   |-- fn: calculateNodeDepth(nodeId, depth = 0) [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: evaluateAndScore(diagram)
|   |   |   |   |-- method: _scorePatterns(detectedPatterns)
|   |   |   |   |-- method: _scoreComplexity(diagram)
|   |   |   |   |-- method: _scoreBestPractices(diagram, detectedPatterns)
|   |   |   |   |-- method: _scoreAnalysis(analysis)
|   |   |   |   |-- method: _calculateRangeScore(value, min, max)
|   |   |   |   |-- method: _calculateGraphDepth(diagram)
|   |   |   |   |-- method: _calculateTotalScore(scores)
|   |   |   |   |-- method: _generateRecommendations(scores, diagram)
|   |   |   |   |-- method: _findMissingCriticalPatterns(diagram)
|   |   |   |   |-- method: _findMissingBestPractices(diagram)
|   |   |   |   |-- method: filter(check => {
      switch (check)
|   |   |   |   |-- method: _hasRedundancy(diagram)
|   |   |   |-- diagramService.js
|   |   |   |   |-- module:diagramService.js
|   |   |   |   |-- class:DiagramService [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: generateDiagram(sessionId, type, context = {})
|   |   |   |   |-- method: evaluateDiagram(diagram, sessionId, type)
|   |   |   |   |-- method: extractMermaidCode(text)
|   |   |   |   |-- method: _buildGenerationPrompt(type, context)
|   |   |   |-- patternDetector.js
|   |   |   |   |-- module:patternDetector.js
|   |   |   |   |-- class:PatternDetector [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: detectPatterns(nodes, edges)
|   |   |   |   |-- method: _analyzePattern(patternName, pattern, nodes, edges)
|   |   |   |   |-- method: _detectLoadBalancing(nodes, edges, requirements)
|   |   |   |   |-- method: _detectMicroservices(nodes, edges, requirements)
|   |   |   |   |-- method: _detectCaching(nodes, edges, requirements)
|   |   |   |   |-- method: _detectMessageQueue(nodes, edges, requirements)
|   |   |   |   |-- method: _detectApiGateway(nodes, edges, requirements)
|   |   |   +-- templates.js
|   |   |       |-- module:templates.js
|   |   |-- engines
|   |   |   |-- baseEngine.js
|   |   |   |   |-- module:baseEngine.js
|   |   |   |   |-- class:BaseEngine [internal]
|   |   |   |   |-- method: constructor(engineConfig = {})
|   |   |   |   |-- method: processMessage(sessionId, message, options = {})
|   |   |   |   |-- method: startSession(userId, contentId, options = {})
|   |   |   |   |-- method: generateContent(sessionId, contentType, options = {})
|   |   |   |-- coachEngine.js
|   |   |   |   |-- module:coachEngine.js
|   |   |   |   |-- class:CoachEngine extends BaseEngine [internal]
|   |   |   |   |-- method: constructor(config = {})
|   |   |   |   |-- method: processMessage(sessionId, message, options = {})
|   |   |   |   |-- method: startSession(userId, problemId, options = {})
|   |   |   |   |-- method: generateContent(sessionId, topic, options = {})
|   |   |   |   |-- method: generateDiagram(sessionId, diagramType, options = {})
|   |   |   |   |-- method: _getFallbackDiagram(type)
|   |   |   |   |-- method: evaluateDesign(sessionId, options = {})
|   |   |   |-- coachingEngine.js
|   |   |   |   |-- module:coachingEngine.js
|   |   |   |   |-- class:CoachingEngine [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: initialize()
|   |   |   |   |-- method: startSession(userId, problemId)
|   |   |   |   |-- method: processMessage(sessionId, message)
|   |   |   |   |-- method: switchPersona(sessionId, newPersona)
|   |   |   |-- graderEngine.js
|   |   |   |   |-- module:graderEngine.js
|   |   |   |   |-- class:GraderEngine extends BaseEngine [internal]
|   |   |   |   |-- method: constructor(config = {})
|   |   |   |   |-- method: evaluateWorkbook(sessionId, workbookContent, options = {})
|   |   |   |   |-- method: _extractScores(evaluationText)
|   |   |   |   |-- method: provideFinalAssessment(interviewId, options = {})
|   |   |   |   |-- method: _buildGraderPrompt(context)
|   |   |   |   |-- method: _getDefaultGraderPrompt(context = {})
|   |   |   |-- interviewEngine.js
|   |   |   |   |-- module:interviewEngine.js
|   |   |   |   |-- class:InterviewEngine extends BaseEngine [internal]
|   |   |   |   |-- method: constructor(config = {})
|   |   |   |   |-- method: startInterview(userId, problemId, options = {})
|   |   |   |   |-- method: generateContent(sessionId, contentType, options = {})
|   |   |   |   |-- method: generateDiagram(sessionId, options = {})
|   |   |   |   |-- method: processResponse(interviewId, message, options = {})
|   |   |   |   |-- method: finalizeInterview(interview)
|   |   |   |   |-- method: _extractEntities(messages, currentStage)
|   |   |   |   |-- method: _shouldAdvanceStage(conversation, currentStage, messageCount)
|   |   |   |   |-- method: _getNextStage(currentStage)
|   |   |   |   |-- component:BaseEngine [internal]
|   |   |   |   |-- component:Interview [internal]
|   |   |   |   |-- component:Problem [internal]
|   |   |   +-- PersonaService.js
|   |   |       |-- module:PersonaService.js
|   |   |       |-- class:PersonaService [internal]
|   |   |       |-- method: constructor()
|   |   |       |-- method: initialize(config)
|   |   |       |-- method: setActivePersona(personaId)
|   |   |       |-- method: getActivePersona()
|   |   |       |-- method: getSystemPrompt(context = {})
|   |   |-- evaluation
|   |   |   |-- evaluationParser.js
|   |   |   |-- evaluationService.js
|   |   |   |   |-- module:evaluationService.js
|   |   |   |   |-- class:EvaluationService [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: evaluateSection(sessionId, section, content)
|   |   |   |   |-- method: evaluateWorkbook(sessionId)
|   |   |   |   |-- method: _calculateMetrics(section, content)
|   |   |   |   |-- method: _calculateCompletion(section, metrics)
|   |   |   |   |-- method: _generateFeedback(section, metrics)
|   |   |   |   |-- method: _identifyImprovements(section, metrics)
|   |   |   +-- workbookEvaluationService.js
|   |   |       |-- module:workbookEvaluationService.js
|   |   |       |-- class:WorkbookEvaluationService [internal]
|   |   |       |-- method: constructor()
|   |   |       |-- method: evaluateSection(sessionId, section, content)
|   |   |       |-- method: evaluateProgress(sessionId)
|   |   |       |-- method: _calculateOverallProgress(evaluations)
|   |   |       |-- method: _generateRecommendations(evaluations)
|   |   |-- knowledge
|   |   |   |-- knowledgeService.js
|   |   |   |   |-- module:knowledgeService.js
|   |   |   |   |-- class:KnowledgeService [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: initializeVectorStore()
|   |   |   |   |-- method: queryKnowledge(query, company = 'facebook')
|   |   |   |   |-- method: _executeCommand(command, params = {})
|   |   |   |   |-- method: _getPythonScript()
|   |   |   +-- vector_store.py
|   |   |       |-- fn: initialize_vector_store() [public]
|   |   |       |-- fn: query_knowledge(query, company="facebook") [public]
|   |   |-- persona
|   |   |   +-- PersonaManager.js
|   |   |       |-- module:PersonaManager.js
|   |   |       |-- class:PersonaManager [internal]
|   |   |       |-- method: constructor()
|   |   |       |-- method: initialize()
|   |   |       |-- method: loadKnowledgeBase()
|   |   |       |-- method: setActivePersona(type)
|   |   |       |-- method: getPersonaContext(type, additionalContext = {})
|   |   |       |-- method: getRelevantKnowledge(topic)
|   |   |-- progress
|   |   |   +-- progressTrackingService.js
|   |   |       |-- module:progressTrackingService.js
|   |   |       |-- class:ProgressTrackingService [internal]
|   |   |       |-- method: trackProgress(sessionId, userId)
|   |   |       |-- method: getProgressTimeline(sessionId)
|   |   |-- skills
|   |   |   |-- skillEvaluationService.js
|   |   |   |   |-- module:skillEvaluationService.js
|   |   |   |   |-- class:SkillEvaluationService [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: evaluateResponse(category, skillName, response, context)
|   |   |   |   |-- method: evaluateDesignSession(sessionData)
|   |   |   |   |-- method: _buildEvaluationPrompt(skill, response, context)
|   |   |   |   |-- method: _getAIEvaluation(prompt)
|   |   |   |   |-- method: _generateSessionSummary(evaluations)
|   |   |   +-- skillProgressService.js
|   |   |       |-- module:skillProgressService.js
|   |   |       |-- class:SkillProgressService [internal]
|   |   |       |-- method: constructor()
|   |   |       |-- method: updateProgress(userId, sessionId, evaluations)
|   |   |       |-- method: getSkillRoadmap(userId)
|   |   |-- utils
|   |   |   +-- diagramUtils.js
|   |   |       |-- module:diagramUtils.js
|   |   |       |-- fn: getDiagramTypeForStage(currentStage) [internal]
|   |   |       |-- fn: generateSvgDiagram(entities, diagramType, title) [internal]
|   |   |       |-- fn: generateArchitectureDiagram(entities, title) [internal]
|   |   |       |-- fn: generateErDiagram(entities, title) [internal]
|   |   |       |-- fn: generateApiDiagram(entities, title) [internal]
|   |   |       |-- method: getDiagramTypeForStage(currentStage)
|   |   |       |-- method: generateSvgDiagram(entities, diagramType, title)
|   |   |       |-- method: generateArchitectureDiagram(entities, title)
|   |   |       |-- method: generateErDiagram(entities, title)
|   |   |       |-- method: generateApiDiagram(entities, title)
|   |   |-- workbook
|   |   |   +-- workbookDiagramService.js
|   |   |       |-- module:workbookDiagramService.js
|   |   |       |-- class:WorkbookDiagramService [internal]
|   |   |       |-- method: getDiagram(sessionId, diagramType)
|   |   |       |-- method: saveDiagram(sessionId, diagramType, diagramData)
|   |   |-- CoachEngine.js
|   |   |   |-- module:CoachEngine.js
|   |   |   |-- class:CoachEngine [internal]
|   |   |   |-- method: constructor()
|   |   |   |-- method: handleMessage(sessionId, userId, message, contextInfo = null)
|   |   +-- coaching.js
|   |       |-- module:coaching.js
|   |       |-- fn: logMessageProcessing(sessionId, message, systemPrompt, projectDetails) [internal]
|   |       |-- fn: formatSystemPrompt(prompt) [internal]
|   |-- tempresults
|   |-- tests
|   |   +-- ai.test.js
|   |-- utils
|   |   |-- dbHealth.js
|   |   |   |-- module:dbHealth.js
|   |   |   |-- class:DatabaseHealthCheck [internal]
|   |   |   |-- method: checkConnection()
|   |   |   |-- method: ping()
|   |   +-- logger.js
|   |       |-- module:logger.js
|   |-- app.js
|   |   |-- module:app.js
|   |-- index.js
|   +-- testAnthropic.js
|       |-- fn: testAnthropic() [internal]
|       |-- method: testAnthropic()
|-- tests
|   +-- diagram.test.js
|-- advanced_tree_structure.txt
|-- all_source_code.txt
|-- folders.txt
|-- js_files.txt
|-- md_files.txt
|-- project_overview.txt
|-- README.md
|-- sysdesignsummarydata.txt
|-- todolist-phase1.md
+-- tree_structure.txt



================================================================================
# FILE: client\components\CoachAgentInterface.js
# EXTENSION: .js
================================================================================
import { useState, useEffect } from 'react';
import { sendCoachingMessage } from '../utils/api';

export default function CoachAgentInterface() {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSendMessage = async () => {
    if (!input.trim()) return;

    const userMessage = {
      id: Date.now(),
      role: 'user',
      content: input.trim(),
      timestamp: new Date().toISOString()
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setLoading(true);

    try {
      const sessionId = 'test-session-1'; // We'll implement proper session management later
      const response = await sendCoachingMessage(sessionId, input.trim());

      if (response?.message) {
        const assistantMessage = {
          id: Date.now() + 1,
          role: 'assistant',
          content: response.message.content,
          timestamp: new Date().toISOString()
        };
        setMessages(prev => [...prev, assistantMessage]);
      }
    } catch (error) {
      console.error('Failed to send message:', error);
      // Add error message to chat
      setMessages(prev => [...prev, {
        id: Date.now() + 1,
        role: 'error',
        content: 'Failed to send message. Please try again.',
        timestamp: new Date().toISOString()
      }]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex flex-col h-screen">
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map(message => (
          <div 
            key={message.id}
            className={`p-3 rounded-lg ${
              message.role === 'user' 
                ? 'bg-blue-100 ml-auto' 
                : message.role === 'error'
                ? 'bg-red-100'
                : 'bg-gray-100'
            } max-w-[80%]`}
          >
            {message.content}
          </div>
        ))}
        {loading && (
          <div className="flex items-center space-x-2">
            <div className="animate-pulse">Thinking...</div>
          </div>
        )}
      </div>
      
      <div className="border-t p-4">
        <div className="flex space-x-2">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
            placeholder="Type your message..."
            className="flex-1 p-2 border rounded"
            disabled={loading}
          />
          <button
            onClick={handleSendMessage}
            disabled={loading || !input.trim()}
            className="px-4 py-2 bg-blue-500 text-white rounded disabled:opacity-50"
          >
            Send
          </button>
        </div>
      </div>
    </div>
  );
export default CoachAgentInterface;


================================================================================
# FILE: client\components\coaching\TopicGuidedCoaching.js
# EXTENSION: .js
================================================================================
// client/components/coaching/TopicGuidedCoaching.js
import React, { useState, useEffect } from 'react';
import { Book, ArrowRight } from 'lucide-react';

const SYSTEM_DESIGN_TOPICS = {
  REQUIREMENTS: {
    title: 'Requirements Clarification',
    questions: [
      'What specific features are required?',
      'What scale are we designing for?',
      'What are the performance requirements?',
      'What are the security considerations?',
      'Are there any compliance requirements?'
    ],
    hints: [
      'Consider functional and non-functional requirements',
      'Quantify scale with specific metrics (QPS, DAU, etc.)',
      'Think about latency, throughput, and availability'
    ]
  },
  
  ARCHITECTURE: {
    title: 'System Architecture',
    questions: [
      'What are the core components needed?',
      'How will these components interact?',
      'What APIs will be required between components?',
      'Should we use a monolithic or microservice approach?'
    ],
    hints: [
      'Draw out the high-level architecture',
      'Consider separation of concerns',
      'Think about interfaces between systems'
    ]
  },
  
  STORAGE: {
    title: 'Data Storage',
    questions: [
      'What data needs to be stored?',
      'What is the schema design?',
      'Should we use SQL or NoSQL?',
      'What are the read/write patterns?',
      'Do we need caching?'
    ],
    hints: [
      'Consider the data access patterns',
      'Think about indexing strategies',
      'Consider eventual vs. strong consistency'
    ]
  },
  
  SCALABILITY: {
    title: 'Scaling Strategy',
    questions: [
      'What components need to scale?',
      'Should we scale horizontally or vertically?',
      'How will we handle database scaling?',
      'What are potential bottlenecks?'
    ],
    hints: [
      'Consider load balancing strategies',
      'Think about database sharding approaches',
      'Consider stateless vs. stateful services'
    ]
  },
  
  RELIABILITY: {
    title: 'Reliability & Fault Tolerance',
    questions: [
      'How will the system handle failures?',
      'What redundancy is needed?',
      'How will we monitor the system?',
      'What is our disaster recovery plan?'
    ],
    hints: [
      'Consider single points of failure',
      'Think about data replication strategies',
      'Consider circuit breaker patterns'
    ]
  }
};

const TopicGuidedCoaching = ({ currentTopic, onSendMessage, onGetMaterials }) => {
  const [activeTopic, setActiveTopic] = useState(null);
  
  useEffect(() => {
    // Set active topic based on current conversation or context
    if (currentTopic && SYSTEM_DESIGN_TOPICS[currentTopic]) {
      setActiveTopic(currentTopic);
    } else {
      // Default to requirements if no topic is active
      setActiveTopic('REQUIREMENTS');
    }
  }, [currentTopic]);
  
  if (!activeTopic) return null;
  
  const topic = SYSTEM_DESIGN_TOPICS[activeTopic];
  
  return (
    <div className="bg-white border border-gray-200 rounded-lg p-4 mb-4">
      <div className="flex justify-between items-center mb-3">
        <h3 className="font-medium text-gray-900">{topic.title}</h3>
        <button 
          onClick={() => onGetMaterials(activeTopic.toLowerCase())}
          className="text-xs bg-green-50 text-green-700 px-2 py-1 rounded border border-green-200 flex items-center"
        >
          <Book className="h-3 w-3 mr-1" />
          Learn more
        </button>
      </div>
      
      <div className="space-y-2 mb-4">
        <p className="text-sm text-gray-600 font-medium">Key Questions:</p>
        <ul className="space-y-1">
          {topic.questions.map((question, index) => (
            <li key={index} className="flex items-start">
              <button
                onClick={() => onSendMessage(question)}
                className="text-sm text-blue-600 hover:text-blue-800"
              >
                <ArrowRight className="h-3 w-3 inline mr-1 text-blue-500" />
                {question}
              </button>
            </li>
          ))}
        </ul>
      </div>
      
      {topic.hints.length > 0 && (
        <div className="bg-yellow-50 p-3 rounded border border-yellow-200">
          <p className="text-xs text-yellow-800 font-medium mb-1">Hints:</p>
          <ul className="text-xs text-yellow-700 space-y-1">
            {topic.hints.map((hint, index) => (
              <li key={index}> {hint}</li>
            ))}
          </ul>
        </div>
      )}
      
      <div className="mt-4 flex justify-between">
        {Object.keys(SYSTEM_DESIGN_TOPICS).map((topicKey) => (
          <button
            key={topicKey}
            onClick={() => setActiveTopic(topicKey)}
            className={`text-xs px-2 py-1 rounded ${
              activeTopic === topicKey
                ? 'bg-blue-600 text-white'
                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
          >
            {SYSTEM_DESIGN_TOPICS[topicKey].title.split(' ')[0]}
          </button>
        ))}
      </div>
    </div>
  );
};

export default TopicGuidedCoaching;


================================================================================
# FILE: client\components\ConciseModeToggle.js
# EXTENSION: .js
================================================================================
// components/ConciseModeToggle.js
import React from 'react';

const ConciseModeToggle = ({ isEnabled, onToggle }) => {
  return (
    <div className="flex items-center">
      <span className="text-sm text-gray-600 mr-2">Concise</span>
      <div 
        className={`relative inline-block w-10 h-5 transition-colors duration-200 ease-in-out rounded-full ${isEnabled ? 'bg-indigo-600' : 'bg-gray-300'}`}
        onClick={() => onToggle(!isEnabled)}
      >
        <label
          className={`absolute left-0 top-0 w-5 h-5 bg-white border border-gray-300 rounded-full transition-transform duration-200 ease-in-out transform ${
            isEnabled ? 'translate-x-5' : 'translate-x-0'
          } cursor-pointer`}
        >
          <input
            type="checkbox"
            className="opacity-0 w-0 h-0"
            checked={isEnabled}
            onChange={() => onToggle(!isEnabled)}
          />
        </label>
      </div>
    </div>
  );
};

export default ConciseModeToggle;


================================================================================
# FILE: client\components\diagram\AiSuggestionsPanel.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { Lightbulb, Plus, AlertTriangle, X } from 'lucide-react';
import './styles/AiSuggestions.css';

const AiSuggestionsPanel = ({
  diagram,
  onClose,
  onApplySuggestion,
  sessionId
}) => {
  const [suggestions, setSuggestions] = useState(null);
  const [loading, setLoading] = useState(false);
  const [selectedSuggestion, setSelectedSuggestion] = useState(null);

  useEffect(() => {
    fetchSuggestions();
  }, [diagram]);

  const fetchSuggestions = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/diagram/suggest', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sessionId,
          diagram,
        }),
      });
      const data = await response.json();
      setSuggestions(data);
    } catch (error) {
      console.error('Failed to fetch suggestions:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleApplySuggestion = (change) => {
    setSelectedSuggestion(change);
    onApplySuggestion(change);
  };

  const renderImmediateActions = (actions) => {
    if (!actions?.length) return null;

    return (
      <div className="immediate-actions">
        <h3>Recommended Actions</h3>
        <div className="actions-list">
          {actions.map((action, index) => (
            <div key={index} className={`action-card priority-${action.priority}`}>
              <div className="action-header">
                <AlertTriangle size={16} />
                <span className="action-type">{action.type}</span>
              </div>
              <p>{action.action}</p>
              <button 
                onClick={() => handleApplySuggestion({
                  type: 'add_node',
                  nodeType: action.nodeType
                })}
                className="apply-action"
              >
                <Plus size={16} />
                Apply
              </button>
            </div>
          ))}
        </div>
      </div>
    );
  };

  const renderAiSuggestions = (aiSuggestions) => {
    if (!aiSuggestions?.length) return null;

    return (
      <div className="ai-suggestions">
        <h3>AI Suggestions</h3>
        <div className="suggestions-list">
          {aiSuggestions.map((suggestion, index) => (
            <div key={index} className="suggestion-card">
              <div className="suggestion-header">
                <Lightbulb size={16} />
                <span>{suggestion.title}</span>
              </div>
              <p>{suggestion.description}</p>
              <div className="suggestion-benefits">
                {suggestion.benefits.map((benefit, i) => (
                  <span key={i} className="benefit-tag">{benefit}</span>
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  };

  const renderProposedChanges = (changes) => {
    if (!changes?.length) return null;

    return (
      <div className="proposed-changes">
        <h3>Proposed Changes</h3>
        <div className="changes-list">
          {changes.map((change, index) => (
            <div key={index} className="change-card">
              <div className="change-header">
                <span>{change.type === 'add_node' ? 'Add Component' : 'Modify Structure'}</span>
              </div>
              <div className="change-details">
                {change.type === 'add_node' && (
                  <>
                    <p>Add {change.nodeType} component</p>
                    <p>Connects to: {change.connections.join(', ')}</p>
                  </>
                )}
              </div>
              <button 
                onClick={() => handleApplySuggestion(change)}
                className="apply-change"
              >
                Apply Change
              </button>
            </div>
          ))}
        </div>
      </div>
    );
  };

  if (loading) {
    return (
      <div className="ai-suggestions-panel">
        <div className="suggestions-loading">
          Analyzing diagram and generating suggestions...
        </div>
      </div>
    );
  }

  return (
    <div className="ai-suggestions-panel">
      <div className="suggestions-header">
        <h2>AI Suggestions</h2>
        <button onClick={onClose}>
          <X size={20} />
        </button>
      </div>

      {suggestions && (
        <div className="suggestions-content">
          {renderImmediateActions(suggestions.immediateActions)}
          {renderAiSuggestions(suggestions.aiSuggestions)}
          {renderProposedChanges(suggestions.proposedChanges)}
        </div>
      )}
    </div>
  );
};

export default AiSuggestionsPanel;


================================================================================
# FILE: client\components\diagram\CustomNode.js
# EXTENSION: .js
================================================================================
import React from 'react';
import { Handle, Position } from 'reactflow';

const CustomNode = ({ data }) => {
  const NodeIcon = data.icon;

  return (
    <div className={`
      relative
      px-4 py-3
      shadow-lg
      rounded-lg
      bg-${data.bgColor}
      border-2 border-${data.color}
      min-w-[160px]
    `}>
      <Handle
        type="target"
        position={Position.Top}
        className={`w-3 h-3 !bg-${data.color}`}
      />
      
      <div className="flex items-center gap-3">
        <div className={`
          p-2
          rounded-lg
          bg-${data.color}/10
        `}>
          <NodeIcon className={`w-6 h-6 text-${data.color}`} />
        </div>
        
        <div>
          <div className={`text-xs font-medium text-${data.color} mb-1`}>
            {data.type.toUpperCase()}
          </div>
          <div className="text-sm font-bold text-gray-800">
            {data.label}
          </div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">
              {data.notes}
            </div>
          )}
        </div>
      </div>

      <Handle
        type="source"
        position={Position.Bottom}
        className={`w-3 h-3 !bg-${data.color}`}
      />
    </div>
  );
};

export default React.memo(CustomNode);


================================================================================
# FILE: client\components\diagram\DiagramAnalysis.js
# EXTENSION: .js
================================================================================
import React from 'react';
import { Shield, TrendingUp, CheckCircle, Lightbulb } from 'lucide-react';

const AnalysisSection = ({ title, items, icon: Icon }) => (
  <div className="mb-6">
    <div className="flex items-center gap-2 mb-3">
      <Icon className="w-5 h-5 text-blue-600" />
      <h3 className="font-semibold text-gray-800">{title}</h3>
    </div>
    <ul className="space-y-2">
      {items.map((item, index) => (
        <li 
          key={index}
          className={`p-3 rounded-lg ${
            item.level === 'high' || item.priority === 'high' || item.severity === 'high'
              ? 'bg-red-50 text-red-700'
              : item.level === 'medium' || item.priority === 'medium' || item.severity === 'medium'
              ? 'bg-yellow-50 text-yellow-700'
              : 'bg-blue-50 text-blue-700'
          }`}
        >
          <p className="text-sm">{item.message}</p>
          {item.affected && item.affected.length > 0 && (
            <p className="text-xs mt-1 opacity-75">
              Affected elements: {item.affected.join(', ')}
            </p>
          )}
        </li>
      ))}
    </ul>
  </div>
);

const DiagramAnalysis = ({ analysis, onClose, onApplySuggestion }) => {
  const { suggestions, security, scalability, reliability } = analysis;

  const renderSuggestionCard = (suggestion) => (
    <div className={`suggestion-card priority-${suggestion.priority}`}>
      <div className="suggestion-header">
        <span className="suggestion-type">{suggestion.type}</span>
        <span className="suggestion-priority">{suggestion.priority}</span>
      </div>
      
      <p className="suggestion-text">{suggestion.suggestion}</p>
      
      {suggestion.details && (
        <div className="suggestion-details">
          <p>{suggestion.details}</p>
        </div>
      )}

      {suggestion.benefits && (
        <div className="suggestion-benefits">
          <h4>Benefits:</h4>
          <ul>
            {suggestion.benefits.map((benefit, idx) => (
              <li key={idx}>{benefit}</li>
            ))}
          </ul>
        </div>
      )}

      <Button
        onClick={() => onApplySuggestion(suggestion)}
        className="apply-suggestion-btn"
      >
        Apply Suggestion
      </Button>
    </div>
  );

  return (
    <div className="diagram-analysis">
      <div className="analysis-header">
        <h2>Diagram Analysis</h2>
        <Button onClick={onClose} variant="ghost">
          <X size={16} />
        </Button>
      </div>

      <div className="analysis-sections">
        <AnalysisSection
          title="Security Concerns"
          items={security}
          icon={Shield}
        />
        <AnalysisSection
          title="Scalability Analysis"
          items={scalability}
          icon={TrendingUp}
        />
        <AnalysisSection
          title="Reliability Assessment"
          items={reliability}
          icon={CheckCircle}
        />
      </div>

      <div className="suggestions-section">
        <h3>Suggested Improvements</h3>
        <div className="suggestions-grid">
          {suggestions.map((suggestion, idx) => (
            <div key={idx} className="suggestion-wrapper">
              {renderSuggestionCard(suggestion)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default DiagramAnalysis;


================================================================================
# FILE: client\components\diagram\DiagramAnalysisPanel.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { X, AlertTriangle, CheckCircle, ArrowRight } from 'lucide-react';
import { DiagramSuggestionManager } from './DiagramSuggestionManager';
import './styles/DiagramAnalysis.css';

const DiagramAnalysisPanel = ({ 
  nodes, 
  edges, 
  updateNodes, 
  updateEdges,
  onClose,
  sessionId 
}) => {
  const [analysis, setAnalysis] = useState(null);
  const [loading, setLoading] = useState(false);
  const [suggestionManager] = useState(
    () => new DiagramSuggestionManager(nodes, edges, updateNodes, updateEdges)
  );

  useEffect(() => {
    analyzeDiagram();
  }, [nodes, edges]);

  const analyzeDiagram = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/diagram/analyze', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sessionId,
          nodes,
          edges,
        }),
      });
      const data = await response.json();
      setAnalysis(data);
    } catch (error) {
      console.error('Failed to analyze diagram:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleApplySuggestion = async (suggestion) => {
    const success = suggestionManager.applySuggestion(suggestion);
    if (success) {
      // Re-analyze after applying suggestion
      await analyzeDiagram();
    }
  };

  const renderSuggestionCard = (suggestion) => {
    const priorityClass = `priority-${suggestion.priority}`;
    return (
      <div key={suggestion.id} className={`suggestion-card ${priorityClass}`}>
        <div className="suggestion-header">
          <span className="suggestion-type">{suggestion.type}</span>
          <span className="suggestion-priority">{suggestion.priority}</span>
        </div>
        <div className="suggestion-details">
          {suggestion.details}
        </div>
        {suggestion.benefits && (
          <div className="suggestion-benefits">
            <h4>Benefits:</h4>
            <ul>
              {suggestion.benefits.map((benefit, index) => (
                <li key={index}>{benefit}</li>
              ))}
            </ul>
          </div>
        )}
        <button
          className="apply-suggestion-btn"
          onClick={() => handleApplySuggestion(suggestion)}
        >
          Apply Suggestion <ArrowRight size={16} />
        </button>
      </div>
    );
  };

  const renderAnalysisSection = (title, items, icon) => {
    if (!items?.length) return null;
    return (
      <div className="analysis-section">
        <h3 className="section-title">
          {icon}
          {title}
        </h3>
        {items.map(renderSuggestionCard)}
      </div>
    );
  };

  if (loading) {
    return (
      <div className="diagram-analysis">
        <div className="analysis-loading">
          Analyzing diagram...
        </div>
      </div>
    );
  }

  return (
    <div className="diagram-analysis">
      <div className="analysis-header">
        <h2>Diagram Analysis</h2>
        <button onClick={onClose}>
          <X size={20} />
        </button>
      </div>
      
      <div className="analysis-sections">
        {analysis?.score && (
          <div className="analysis-score">
            <h3>Overall Score</h3>
            <div className="score-value">{analysis.score}/100</div>
          </div>
        )}

        {renderAnalysisSection(
          "Critical Issues",
          analysis?.criticalIssues,
          <AlertTriangle className="text-red-500" size={20} />
        )}

        {renderAnalysisSection(
          "Suggestions",
          analysis?.suggestions,
          <CheckCircle className="text-green-500" size={20} />
        )}

        {renderAnalysisSection(
          "Best Practices",
          analysis?.bestPractices,
          <CheckCircle className="text-blue-500" size={20} />
        )}
      </div>
    </div>
  );
};

export default DiagramAnalysisPanel;


================================================================================
# FILE: client\components\diagram\DiagramEvaluation.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { BarChart, CheckCircle, AlertTriangle, ArrowUp, ArrowDown } from 'lucide-react';

const CriterionCard = ({ title, score, previousScore, feedback, suggestions }) => {
  const improvement = score - (previousScore || 0);
  const Arrow = improvement >= 0 ? ArrowUp : ArrowDown;
  const arrowColor = improvement >= 0 ? 'text-green-500' : 'text-red-500';

  return (
    <div className="bg-white rounded-lg shadow p-4 mb-4">
      <div className="flex items-center justify-between mb-2">
        <h3 className="font-semibold text-gray-700">{title}</h3>
        <div className="flex items-center gap-2">
          <span className="text-lg font-bold">{Math.round(score * 100)}%</span>
          {previousScore && (
            <Arrow className={`w-4 h-4 ${arrowColor}`} />
          )}
        </div>
      </div>
      <p className="text-sm text-gray-600 mb-2">{feedback}</p>
      {suggestions?.length > 0 && (
        <div className="mt-2">
          <p className="text-xs font-semibold text-gray-500">Suggestions:</p>
          <ul className="text-xs text-gray-600 list-disc list-inside">
            {suggestions.map((suggestion, i) => (
              <li key={i}>{suggestion}</li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

const ProgressChart = ({ evaluationHistory }) => {
  if (!evaluationHistory?.length) return null;

  const data = evaluationHistory.map(eval => ({
    date: new Date(eval.timestamp).toLocaleDateString(),
    score: Math.round(eval.overallScore * 100)
  })).reverse();

  return (
    <div className="bg-white rounded-lg shadow p-4 mb-4">
      <h3 className="font-semibold text-gray-700 mb-4">Progress Over Time</h3>
      <div className="h-40 relative">
        {/* Simple bar chart implementation */}
        <div className="flex items-end justify-between h-full">
          {data.map((point, i) => (
            <div key={i} className="flex flex-col items-center w-1/6">
              <div 
                className="w-4 bg-blue-500 rounded-t"
                style={{ height: `${point.score}%` }}
              />
              <span className="text-xs text-gray-500 mt-1 rotate-45 origin-left">
                {point.date}
              </span>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

const DiagramEvaluation = ({ 
  sessionId, 
  evaluation, 
  previousEvaluation,
  onClose 
}) => {
  const [evaluationHistory, setEvaluationHistory] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchEvaluationHistory = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/sessions/${sessionId}/evaluations`);
        const data = await response.json();
        setEvaluationHistory(data);
      } catch (error) {
        console.error('Failed to fetch evaluation history:', error);
      }
      setLoading(false);
    };

    if (sessionId) {
      fetchEvaluationHistory();
    }
  }, [sessionId]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500" />
      </div>
    );
  }

  const overallScore = Math.round(evaluation?.overallScore * 100);
  const previousOverallScore = previousEvaluation ? 
    Math.round(previousEvaluation.overallScore * 100) : null;
  const improvement = previousOverallScore ? 
    overallScore - previousOverallScore : null;

  return (
    <div className="bg-gray-50 p-6 rounded-lg max-w-2xl mx-auto">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-xl font-bold text-gray-800">Diagram Evaluation</h2>
        <div className="flex items-center gap-4">
          <div className="text-center">
            <p className="text-sm text-gray-500">Overall Score</p>
            <p className="text-2xl font-bold text-blue-600">{overallScore}%</p>
            {improvement && (
              <p className={`text-sm ${improvement >= 0 ? 'text-green-500' : 'text-red-500'}`}>
                {improvement > 0 ? '+' : ''}{improvement}%
              </p>
            )}
          </div>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700"
          >
            <X className="w-6 h-6" />
          </button>
        </div>
      </div>

      <ProgressChart evaluationHistory={evaluationHistory} />

      <div className="space-y-4">
        {Object.entries(evaluation.scores).map(([criterion, score]) => (
          <CriterionCard
            key={criterion}
            title={criterion.replace(/([A-Z])/g, ' $1').trim()}
            score={score}
            previousScore={previousEvaluation?.scores[criterion]}
            feedback={evaluation.feedback[criterion]}
            suggestions={evaluation.suggestions.filter(s => 
              s.toLowerCase().includes(criterion.toLowerCase())
            )}
          />
        ))}
      </div>

      <div className="mt-6 bg-blue-50 p-4 rounded-lg">
        <h3 className="font-semibold text-blue-700 mb-2">Key Improvements Needed</h3>
        <ul className="list-disc list-inside text-blue-600 space-y-1">
          {evaluation.suggestions.slice(0, 3).map((suggestion, i) => (
            <li key={i} className="text-sm">{suggestion}</li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default DiagramEvaluation;


================================================================================
# FILE: client\components\diagram\DiagramEvaluationPanel.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { X, AlertTriangle, CheckCircle, TrendingUp, Shield, Zap } from 'lucide-react';
import './styles/DiagramEvaluation.css';

const DiagramEvaluationPanel = ({
  diagram,
  onClose,
  sessionId
}) => {
  const [evaluation, setEvaluation] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    evaluateDiagram();
  }, [diagram]);

  const evaluateDiagram = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/diagram/evaluate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sessionId,
          diagram,
        }),
      });
      const data = await response.json();
      setEvaluation(data);
    } catch (error) {
      console.error('Failed to evaluate diagram:', error);
    } finally {
      setLoading(false);
    }
  };

  const renderScoreCard = (criterion, score) => {
    const getScoreColor = (score) => {
      if (score >= 80) return 'text-green-500';
      if (score >= 60) return 'text-yellow-500';
      return 'text-red-500';
    };

    const getScoreIcon = (criterion) => {
      switch (criterion) {
        case 'scalability': return <TrendingUp size={20} />;
        case 'security': return <Shield size={20} />;
        case 'performance': return <Zap size={20} />;
        default: return <CheckCircle size={20} />;
      }
    };

    return (
      <div className={`score-card ${getScoreColor(score)}`}>
        <div className="score-header">
          {getScoreIcon(criterion)}
          <h4>{criterion.charAt(0).toUpperCase() + criterion.slice(1)}</h4>
        </div>
        <div className="score-value">{Math.round(score)}/100</div>
      </div>
    );
  };

  const renderPatterns = (patterns) => {
    if (!patterns?.length) return null;
    return (
      <div className="patterns-section">
        <h3>Identified Patterns</h3>
        <div className="patterns-grid">
          {patterns.map(pattern => (
            <div key={pattern} className="pattern-card">
              {pattern.replace(/-/g, ' ').charAt(0).toUpperCase() + pattern.slice(1)}
            </div>
          ))}
        </div>
      </div>
    );
  };

  const renderRecommendations = (recommendations) => {
    if (!recommendations?.length) return null;
    return (
      <div className="recommendations-section">
        <h3>Recommendations</h3>
        {recommendations.map((rec, index) => (
          <div key={index} className={`recommendation-card priority-${rec.priority}`}>
            <div className="recommendation-header">
              <span className="category">{rec.category}</span>
              <span className="priority">{rec.priority}</span>
            </div>
            <div className="recommendation-body">
              <p>{rec.suggestion.suggestion}</p>
              <div className="details">
                <p>{rec.suggestion.details}</p>
                <ul>
                  {rec.suggestion.implementation.map((step, i) => (
                    <li key={i}>{step}</li>
                  ))}
                </ul>
              </div>
            </div>
          </div>
        ))}
      </div>
    );
  };

  if (loading) {
    return (
      <div className="diagram-evaluation">
        <div className="evaluation-loading">
          Evaluating diagram...
        </div>
      </div>
    );
  }

  return (
    <div className="diagram-evaluation">
      <div className="evaluation-header">
        <h2>Diagram Evaluation</h2>
        <button onClick={onClose}>
          <X size={20} />
        </button>
      </div>

      {evaluation && (
        <div className="evaluation-content">
          <div className="scores-grid">
            {Object.entries(evaluation.scores).map(([criterion, score]) => (
              criterion !== 'overall' && renderScoreCard(criterion, score)
            ))}
          </div>

          <div className="overall-score">
            <h3>Overall Score</h3>
            <div className="score-value">{Math.round(evaluation.scores.overall)}/100</div>
          </div>

          {renderPatterns(evaluation.patterns)}
          {renderRecommendations(evaluation.recommendations)}
        </div>
      )}
    </div>
  );
};

export default DiagramEvaluationPanel;


================================================================================
# FILE: client\components\diagram\DiagramPanel.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect, useCallback } from 'react';
import SystemArchitectureDiagram from './SystemArchitectureDiagram';
import { CircularProgress } from '@mui/material';
import { Wand2, Save, RefreshCw, X } from 'lucide-react';

const DiagramPanel = ({
  hideModes = false,
  sessionId,
  sessionType = 'coaching',
  initialDiagram = null,
  onClose,
  onSave,
  onRefresh,
  onAiSuggest,
  onSaveAndContinue,
}) => {
  // Initialize with default nodes if no initial diagram
  const [nodes, setNodes] = useState([
    {
      id: '1',
      type: 'service',
      position: { x: 250, y: 100 },
      data: { label: 'API Service', notes: 'Main service' }
    },
    {
      id: '2',
      type: 'database',
      position: { x: 250, y: 250 },
      data: { label: 'Database', notes: 'Primary storage' }
    }
  ]);
  
  const [edges, setEdges] = useState([
    {
      id: 'e1-2',
      source: '1',
      target: '2',
      type: 'default'
    }
  ]);
  
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (initialDiagram) {
      setNodes(initialDiagram.nodes || []);
      setEdges(initialDiagram.edges || []);
    }
  }, [initialDiagram]);

  const handleNodesChange = useCallback((changes) => {
    setNodes((nds) => applyNodeChanges(changes, nds));
  }, []);

  const handleEdgesChange = useCallback((changes) => {
    setEdges((eds) => applyEdgeChanges(changes, eds));
  }, []);

  const handleConnect = useCallback((params) => {
    setEdges((eds) => addEdge(params, eds));
  }, []);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <CircularProgress />
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      {/* Toolbar */}
      <div className="flex justify-between items-center p-2 border-b">
        <div className="flex space-x-2">
          <button
            onClick={onAiSuggest}
            className="px-3 py-1 bg-purple-100 text-purple-700 rounded-md hover:bg-purple-200 flex items-center"
          >
            <Wand2 className="w-4 h-4 mr-1" />
            Ask Coach
          </button>
          <button
            onClick={() => onSave({ nodes, edges })}
            className="px-3 py-1 bg-blue-100 text-blue-700 rounded-md hover:bg-blue-200 flex items-center"
          >
            <Save className="w-4 h-4 mr-1" />
            Save
          </button>
          <button
            onClick={onRefresh}
            className="px-3 py-1 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 flex items-center"
          >
            <RefreshCw className="w-4 h-4 mr-1" />
            Refresh
          </button>
        </div>
        {onClose && (
          <button
            onClick={onClose}
            className="p-1 hover:bg-gray-100 rounded"
          >
            <X className="w-5 h-5" />
          </button>
        )}
      </div>

      {/* Diagram Area */}
      <div className="flex-1 min-h-[500px]">
        <SystemArchitectureDiagram
          initialNodes={nodes}
          initialEdges={edges}
          onNodesChange={handleNodesChange}
          onEdgesChange={handleEdgesChange}
          onConnect={handleConnect}
        />
      </div>
    </div>
  );
};

export default DiagramPanel;


================================================================================
# FILE: client\components\diagram\DiagramProgressView.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from 'recharts';
import { AlertTriangle, TrendingUp, TrendingDown, Check } from 'lucide-react';

const DiagramProgressView = ({ sessionId, diagramId }) => {
  const [progressData, setProgressData] = useState(null);
  const [activeTab, setActiveTab] = useState('scores');

  useEffect(() => {
    fetchProgressData();
  }, [sessionId, diagramId]);

  const fetchProgressData = async () => {
    try {
      const response = await fetch(`/api/diagrams/${diagramId}/progress?sessionId=${sessionId}`);
      const data = await response.json();
      setProgressData(data);
    } catch (error) {
      console.error('Failed to fetch progress data:', error);
    }
  };

  if (!progressData) {
    return <div>Loading progress data...</div>;
  }

  const formatSnapshotData = (snapshots) => {
    return snapshots.map((snapshot, index) => ({
      timestamp: new Date(snapshot.timestamp).toLocaleString(),
      ...snapshot.scores,
      complexity: snapshot.complexity.density,
      patterns: Object.values(snapshot.patterns).filter(Boolean).length,
    }));
  };

  const renderScoresChart = () => (
    <div className="h-64 w-full">
      <ResponsiveContainer>
        <LineChart data={formatSnapshotData(progressData.snapshots)}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="timestamp" />
          <YAxis />
          <Tooltip />
          <Legend />
          <Line type="monotone" dataKey="overall" stroke="#8884d8" name="Overall" />
          <Line type="monotone" dataKey="scalability.value" stroke="#82ca9d" name="Scalability" />
          <Line type="monotone" dataKey="reliability.value" stroke="#ffc658" name="Reliability" />
          <Line type="monotone" dataKey="security.value" stroke="#ff7300" name="Security" />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );

  const renderPatternProgress = () => {
    const patterns = progressData.snapshots[progressData.snapshots.length - 1].patterns;
    
    return (
      <div className="grid grid-cols-2 gap-4">
        {Object.entries(patterns).map(([pattern, implemented]) => (
          <div key={pattern} className={`p-4 rounded-lg border ${implemented ? 'border-green-500 bg-green-50' : 'border-gray-300'}`}>
            <div className="flex items-center justify-between">
              <span className="capitalize">{pattern.replace(/([A-Z])/g, ' $1').trim()}</span>
              {implemented ? <Check className="text-green-500" /> : null}
            </div>
          </div>
        ))}
      </div>
    );
  };

  const renderComplexityMetrics = () => {
    const latest = progressData.snapshots[progressData.snapshots.length - 1].complexity;
    
    return (
      <div className="grid grid-cols-2 gap-4">
        {Object.entries(latest).map(([metric, value]) => (
          <div key={metric} className="p-4 rounded-lg border border-gray-300">
            <div className="text-sm text-gray-500 capitalize">{metric}</div>
            <div className="text-xl font-semibold">{value.toFixed(2)}</div>
          </div>
        ))}
      </div>
    );
  };

  const renderRecommendations = () => {
    const recommendations = progressData.recommendations || [];
    
    return (
      <div className="space-y-4">
        {recommendations.map((rec, index) => (
          <div key={index} className={`p-4 rounded-lg border ${
            rec.type === 'warning' ? 'border-yellow-500 bg-yellow-50' : 'border-blue-500 bg-blue-50'
          }`}>
            <div className="flex items-start gap-2">
              {rec.type === 'warning' ? (
                <AlertTriangle className="text-yellow-500" />
              ) : (
                <TrendingUp className="text-blue-500" />
              )}
              <div>
                <div className="font-semibold capitalize">{rec.category}</div>
                <div className="text-sm">{rec.message}</div>
              </div>
            </div>
          </div>
        ))}
      </div>
    );
  };

  return (
    <div className="space-y-6">
      <div className="flex gap-4 border-b">
        <button
          className={`px-4 py-2 ${activeTab === 'scores' ? 'border-b-2 border-blue-500' : ''}`}
          onClick={() => setActiveTab('scores')}
        >
          Scores
        </button>
        <button
          className={`px-4 py-2 ${activeTab === 'patterns' ? 'border-b-2 border-blue-500' : ''}`}
          onClick={() => setActiveTab('patterns')}
        >
          Patterns
        </button>
        <button
          className={`px-4 py-2 ${activeTab === 'complexity' ? 'border-b-2 border-blue-500' : ''}`}
          onClick={() => setActiveTab('complexity')}
        >
          Complexity
        </button>
        <button
          className={`px-4 py-2 ${activeTab === 'recommendations' ? 'border-b-2 border-blue-500' : ''}`}
          onClick={() => setActiveTab('recommendations')}
        >
          Recommendations
        </button>
      </div>

      <div className="p-4">
        {activeTab === 'scores' && renderScoresChart()}
        {activeTab === 'patterns' && renderPatternProgress()}
        {activeTab === 'complexity' && renderComplexityMetrics()}
        {activeTab === 'recommendations' && renderRecommendations()}
      </div>
    </div>
  );
};

export default DiagramProgressView;


================================================================================
# FILE: client\components\diagram\DiagramSuggestionManager.js
# EXTENSION: .js
================================================================================
import { useState, useCallback } from 'react';
import { getNodePositionForType } from './utils/nodePositioning';
import { templates } from '../../../server/services/diagram/templates';

export class DiagramSuggestionManager {
  constructor(nodes, edges, updateNodes, updateEdges) {
    this.nodes = nodes;
    this.edges = edges;
    this.updateNodes = updateNodes;
    this.updateEdges = updateEdges;
  }

  applySuggestion(suggestion) {
    switch (suggestion.type) {
      case 'component':
        return this.applyComponentSuggestion(suggestion);
      case 'pattern':
        return this.applyPatternSuggestion(suggestion);
      case 'scalability':
        return this.applyScalabilitySuggestion(suggestion);
      case 'security':
        return this.applySecuritySuggestion(suggestion);
      default:
        console.warn('Unknown suggestion type:', suggestion.type);
        return false;
    }
  }

  applyComponentSuggestion(suggestion) {
    const componentType = this.getComponentTypeFromSuggestion(suggestion);
    if (!componentType) return false;

    const position = this.calculateOptimalPosition(componentType);
    const newNode = {
      id: `${componentType}-${Date.now()}`,
      type: componentType,
      position,
      data: { label: suggestion.details.label || componentType }
    };

    this.updateNodes([...this.nodes, newNode]);
    return true;
  }

  applyPatternSuggestion(suggestion) {
    const patternTemplate = templates[suggestion.pattern];
    if (!patternTemplate) return false;

    // Get current diagram bounds
    const bounds = this.calculateDiagramBounds();
    
    // Offset pattern nodes based on current diagram
    const offsetNodes = patternTemplate.nodes.map(node => ({
      ...node,
      position: {
        x: node.position.x + bounds.maxX + 100,
        y: node.position.y
      }
    }));

    // Add new nodes and edges
    this.updateNodes([...this.nodes, ...offsetNodes]);
    this.updateEdges([...this.edges, ...patternTemplate.edges]);
    return true;
  }

  applyScalabilitySuggestion(suggestion) {
    switch (suggestion.component) {
      case 'loadBalancer':
        return this.addLoadBalancer();
      case 'cache':
        return this.addCache();
      case 'queue':
        return this.addQueue();
      default:
        return false;
    }
  }

  applySecuritySuggestion(suggestion) {
    switch (suggestion.component) {
      case 'apiGateway':
        return this.addApiGateway();
      case 'firewall':
        return this.addFirewall();
      default:
        return false;
    }
  }

  calculateOptimalPosition(componentType) {
    const bounds = this.calculateDiagramBounds();
    return getNodePositionForType(componentType, bounds, this.nodes);
  }

  calculateDiagramBounds() {
    const bounds = {
      minX: Infinity,
      minY: Infinity,
      maxX: -Infinity,
      maxY: -Infinity
    };

    this.nodes.forEach(node => {
      bounds.minX = Math.min(bounds.minX, node.position.x);
      bounds.minY = Math.min(bounds.minY, node.position.y);
      bounds.maxX = Math.max(bounds.maxX, node.position.x);
      bounds.maxY = Math.max(bounds.maxY, node.position.y);
    });

    return bounds;
  }

  getComponentTypeFromSuggestion(suggestion) {
    const typeMap = {
      'Add load balancer': 'loadBalancer',
      'Add cache': 'cache',
      'Add queue': 'queue',
      'Add API Gateway': 'apiGateway',
      'Add database': 'database',
      'Add service': 'service',
      'Add client': 'client'
    };

    const matchedType = Object.entries(typeMap).find(([key]) => 
      suggestion.suggestion.includes(key)
    );

    return matchedType ? matchedType[1] : null;
  }
}


================================================================================
# FILE: client\components\diagram\DiagramToolbar.js
# EXTENSION: .js
================================================================================
import React from 'react';
import { 
  Globe, Server, Database, Share2, Archive, Box, 
  Gateway, Network, Trash2 
} from 'lucide-react';

const DiagramToolbar = ({ mode, setMode, onAddNode, hideModes = false }) => {
  const nodeTypes = [
    { type: 'client', icon: Globe, label: 'Client' },
    { type: 'service', icon: Server, label: 'Service' },
    { type: 'database', icon: Database, label: 'Database' },
    { type: 'loadBalancer', icon: Share2, label: 'Load Balancer' },
    { type: 'cache', icon: Archive, label: 'Cache' },
    { type: 'queue', icon: Box, label: 'Queue' },
    { type: 'gateway', icon: Gateway, label: 'API Gateway' },
    { type: 'network', icon: Network, label: 'Network' }
  ];

  return (
    <div className="flex items-center justify-center gap-2 p-3 bg-white border-t border-gray-200">
      {nodeTypes.map((item) => (
        <button
          key={item.type}
          onClick={() => onAddNode(item.type)}
          className="flex items-center gap-2 px-4 py-2 rounded bg-white hover:bg-gray-50"
        >
          <item.icon className="w-5 h-5 text-gray-600" />
          <span>{item.label}</span>
        </button>
      ))}
      
      <button
        onClick={() => onAddNode('delete')}
        className="flex items-center gap-2 px-4 py-2 rounded bg-white hover:bg-red-50 text-red-600"
      >
        <Trash2 className="w-5 h-5" />
        <span>Delete</span>
      </button>
    </div>
  );
};

export default DiagramToolbar;


================================================================================
# FILE: client\components\diagram\ElementTypeIndicator.js
# EXTENSION: .js
================================================================================
// client/components/diagram/ElementTypeIndicator.js
import React from 'react';
import { 
  Database, Server, Globe, Archive, Grid, Box, Share2 
} from 'lucide-react';

/**
 * Component to display a visual indicator of the node type
 * for use in the diagram and in the editor UI
 */
const ElementTypeIndicator = ({ type, size = 'md', showLabel = false, className = '' }) => {
  // Configure the element based on type
  const elements = {
    client: {
      icon: <Globe />,
      label: 'Client',
      color: 'text-blue-500'
    },
    service: {
      icon: <Server />,
      label: 'Service',
      color: 'text-green-500'
    },
    database: {
      icon: <Database />,
      label: 'Database',
      color: 'text-purple-500'
    },
    cache: {
      icon: <Archive />,
      label: 'Cache',
      color: 'text-red-500'
    },
    loadBalancer: {
      icon: <Grid />,
      label: 'Load Balancer',
      color: 'text-orange-500'
    },
    queue: {
      icon: <Share2 />,
      label: 'Queue',
      color: 'text-indigo-500'
    },
    custom: {
      icon: <Box />,
      label: 'Custom',
      color: 'text-gray-500'
    }
  };

  // Choose the element based on type, default to custom if not found
  const element = elements[type] || elements.custom;

  // Size classes for the icon
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-6 h-6',
    lg: 'w-8 h-8'
  };

  return (
    <div className={`flex items-center ${className}`}>
      <div className={`${element.color} ${sizeClasses[size] || sizeClasses.md}`}>
        {element.icon}
      </div>
      
      {showLabel && (
        <span className="ml-1 text-xs font-medium">{element.label}</span>
      )}
    </div>
  );
};

export default ElementTypeIndicator;


================================================================================
# FILE: client\components\diagram\MermaidRenderer.js
# EXTENSION: .js
================================================================================
// client/components/diagram/MermaidRenderer.js
import React, { useEffect, useRef, useState } from 'react';
import mermaid from 'mermaid';

mermaid.initialize({
  startOnLoad: true,
  theme: 'neutral',
  securityLevel: 'loose',
  systems: {
    useMaxWidth: false,
    htmlLabels: true,
    curve: 'linear'
  },
  fontFamily: 'ui-sans-serif, system-ui, sans-serif',
});

const MermaidRenderer = ({ code, onError }) => {
  const containerRef = useRef(null);
  const [svgContent, setSvgContent] = useState('');
  const [isRendering, setIsRendering] = useState(true);
  const [error, setError] = useState(null);
  const [renderAttempts, setRenderAttempts] = useState(0);
  
  useEffect(() => {
    setSvgContent('');
    setError(null);
    setIsRendering(true);
    
    const id = `mermaid-${Date.now()}`;
    
    const cleanup = () => {
      if (containerRef.current) {
        containerRef.current.innerHTML = '';
      }
    };
    
    const renderDiagram = async () => {
      if (!code || !containerRef.current) return;
      
      try {
        cleanup();
        const { svg } = await mermaid.render(id, code);
        setSvgContent(svg);
        setError(null);
        if (onError) {
          onError(null);
        }
      } catch (err) {
        console.error('Mermaid render error:', err);
        setError(err.message || 'Failed to render diagram');
        if (renderAttempts < 2) {
          setTimeout(() => {
            setRenderAttempts(prev => prev + 1);
            renderDiagram();
          }, 100);
        } else {
          if (onError) {
            onError(err.message || 'Failed to render diagram');
          }
        }
      } finally {
        setIsRendering(false);
      }
    };
    
    renderDiagram();
    
    return cleanup;
  }, [code, onError, renderAttempts]);
  
  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded text-red-700 whitespace-pre-wrap">
        <div className="font-medium mb-2">Error rendering diagram:</div>
        <div className="text-sm font-mono">{error}</div>
      </div>
    );
  }
  
  if (isRendering) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
      </div>
    );
  }
  
  if (svgContent) {
    return (
      <div 
        className="mermaid flex items-center justify-center p-4 h-full overflow-auto bg-white"
        dangerouslySetInnerHTML={{ __html: svgContent }}
      />
    );
  }
  
  return (
    <div className="flex items-center justify-center h-full" ref={containerRef}>
      <div className="text-gray-500">Initializing diagram...</div>
    </div>
  );
};

export default MermaidRenderer;



================================================================================
# FILE: client\components\diagram\NodePalette.js
# EXTENSION: .js
================================================================================
import React, { useState } from 'react';
import { 
  Users,      // For Client/User
  Network,    // For Networking & Delivery
  Server,     // For Backend Services
  Database,   // For Database & Storage
  Shield,     // For Security & External
  ChevronDown // For dropdown toggle
} from 'lucide-react';

const nodeCategories = [
  {
    name: 'Client/User',
    color: '#3B82F6',
    icon: <Users />,
    options: [
      { type: 'user', label: 'User' },
      { type: 'webapp', label: 'Web App' },
      { type: 'mobile', label: 'Mobile App' },
      { type: 'iot', label: 'IoT Device' }
    ]
  },
  {
    name: 'Networking & Delivery',
    color: '#10B981',
    icon: <Network />,
    options: [
      { type: 'loadbalancer', label: 'Load Balancer' },
      { type: 'cdn', label: 'CDN' },
      { type: 'gateway', label: 'API Gateway' },
      { type: 'proxy', label: 'Proxy' }
    ]
  },
  {
    name: 'Backend Services',
    color: '#8B5CF6',
    icon: <Server />,
    options: [
      { type: 'service', label: 'Service' },
      { type: 'serverless', label: 'Serverless' },
      { type: 'queue', label: 'Message Queue' },
      { type: 'container', label: 'Container' }
    ]
  },
  {
    name: 'Database & Storage',
    color: '#F59E0B',
    icon: <Database />,
    options: [
      { type: 'database', label: 'Database' },
      { type: 'storage', label: 'Object Storage' },
      { type: 'cache', label: 'Cache' },
      { type: 'file', label: 'File Storage' }
    ]
  },
  {
    name: 'Security & External',
    color: '#EF4444',
    icon: <Shield />,
    options: [
      { type: 'auth', label: 'Auth Provider' },
      { type: 'firewall', label: 'Firewall' },
      { type: 'security', label: 'Security Service' },
      { type: 'external', label: 'External API' }
    ]
  }
];

function NodePalette({ onNodeAdd }) {
  const [isOpen, setIsOpen] = useState(false);
  const [activeCategory, setActiveCategory] = useState(null);

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-3 py-2 rounded-md bg-white border shadow-sm hover:bg-gray-50"
      >
        <span>Add Component</span>
        <ChevronDown className={`w-4 h-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {isOpen && (
        <div className="absolute top-full left-0 mt-1 w-64 bg-white rounded-lg shadow-lg border z-50">
          <div className="p-2">
            {nodeCategories.map((category) => (
              <div key={category.name}>
                <button
                  className="w-full flex items-center justify-between p-2 hover:bg-gray-50 rounded-md"
                  onClick={() => setActiveCategory(
                    activeCategory === category.name ? null : category.name
                  )}
                >
                  <div className="flex items-center gap-2">
                    <span className="w-5 h-5" style={{ color: category.color }}>
                      {category.icon}
                    </span>
                    <span className="text-sm font-medium">{category.name}</span>
                  </div>
                  <ChevronDown 
                    className={`w-4 h-4 transition-transform ${
                      activeCategory === category.name ? 'rotate-180' : ''
                    }`}
                  />
                </button>
                
                {activeCategory === category.name && (
                  <div className="ml-7 mt-1 space-y-1">
                    {category.options.map((option) => (
                      <button
                        key={option.type}
                        className="w-full text-left px-2 py-1.5 text-sm text-gray-600 hover:bg-gray-50 rounded"
                        onClick={() => {
                          onNodeAdd(option.type);
                          setIsOpen(false);
                          setActiveCategory(null);
                        }}
                      >
                        {option.label}
                      </button>
                    ))}
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

export default NodePalette;


================================================================================
# FILE: client\components\diagram\NodeTypes\CacheNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/CacheNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Archive } from 'lucide-react';

const CacheNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-red-500">
      <div className="flex items-center">
        <Archive className="h-8 w-8 text-red-500 mr-2" />
        <div>
          <div className="text-xs text-red-700 font-medium bg-red-50 px-1 rounded mb-1">Cache</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Top}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-red-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-red-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-red-500"
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-red-500"
      />
    </div>
  );
};

export default memo(CacheNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\ClientNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/ClientNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Globe } from 'lucide-react';

const ClientNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-blue-500">
      <div className="flex items-center">
        <Globe className="h-8 w-8 text-blue-500 mr-2" />
        <div>
          <div className="text-xs text-blue-700 font-medium bg-blue-50 px-1 rounded mb-1">Client</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-blue-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-blue-500"
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-blue-500"
      />
    </div>
  );
};

export default memo(ClientNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\CustomNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/CustomNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Server, Database, Circle, Cloud, Router } from 'lucide-react';

const iconMap = {
  service: Server,
  database: Database,
  cache: Circle,
  gateway: Cloud,
  loadbalancer: Router,
  queue: Circle,
};

function CustomNode({ data, type }) {
  const Icon = iconMap[type] || Server;
  
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-gray-200">
      <Handle type="target" position={Position.Top} />
      <div className="flex items-center">
        <Icon className="h-6 w-6 mr-2" />
        <div className="text-sm font-medium">{data.label}</div>
      </div>
      <Handle type="source" position={Position.Bottom} />
    </div>
  );
}

export default memo(CustomNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\DatabaseNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/DatabaseNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Database } from 'lucide-react';

const DatabaseNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-purple-500">
      <div className="flex items-center">
        <Database className="h-8 w-8 text-purple-500 mr-2" />
        <div>
          <div className="text-xs text-purple-700 font-medium bg-purple-50 px-1 rounded mb-1">Database</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Top}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-purple-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-purple-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-purple-500"
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-purple-500"
      />
    </div>
  );
};

export default memo(DatabaseNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\FixedLifelineNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/FixedLifelineNode.js
import React, { memo, useEffect } from 'react';
import { Handle, Position, useUpdateNodeInternals } from 'reactflow';

/**
 * FixedLifelineNode - A lifeline node that maintains vertical alignment with its parent participant
 * 
 * This node solves the problem of lifelines moving up and down and breaking message alignment
 * by fixing its vertical position and only allowing horizontal repositioning through its parent.
 */
const FixedLifelineNode = memo(({ id, data, selected, xPos, yPos }) => {
  const updateNodeInternals = useUpdateNodeInternals();
  
  // Fixed vertical position from the top participant/actor
  const FIXED_TOP_POSITION = 120; // Distance from participant to where lifeline starts
  
  // Effect to update node internals when parent participant moves horizontally
  useEffect(() => {
    updateNodeInternals(id);
  }, [id, xPos, updateNodeInternals]);
  
  return (
    <div 
      className={`sequence-lifeline-node ${selected ? 'border-l-2 border-gray-500' : ''}`} 
      style={{ 
        width: '2px', 
        height: data.height || 400,
        position: 'relative',
        pointerEvents: 'all'
      }}
    >
      {/* The vertical lifeline */}
      <div className="w-0.5 h-full bg-gray-300 mx-auto relative">
        {/* Activation boxes rendered on top of lifeline */}
        {data.activations && data.activations.map((activation, index) => (
          <div 
            key={index}
            className={`bg-${activation.color || 'blue'}-200 border border-${activation.color || 'blue'}-400`}
            style={{
              position: 'absolute',
              width: '10px',
              height: `${activation.height}px`,
              left: '-4px',
              top: `${activation.top}px`,
              zIndex: activation.nestLevel || 1
            }}
          />
        ))}
      </div>
      
      {/* Connection points - critical for messages */}
      <Handle
        type="target"
        position={Position.Top}
        id="top"
        isConnectable={false}
        style={{ visibility: 'hidden' }}
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        className="w-3 h-3 bg-gray-500"
        isConnectable={true}
        style={{ right: '-6px', top: '50%' }}
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        className="w-3 h-3 bg-gray-500"
        isConnectable={true}
        style={{ left: '-6px', top: '50%' }}
      />
    </div>
  );
});

export default FixedLifelineNode;


================================================================================
# FILE: client\components\diagram\NodeTypes\GatewayNode.js
# EXTENSION: .js
================================================================================
import React from 'react';
import { Handle, Position } from 'reactflow';
import { Gateway } from 'lucide-react';

const GatewayNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-purple-500">
      <div className="flex items-center">
        <Gateway className="h-8 w-8 text-purple-500 mr-2" />
        <div>
          <div className="text-xs text-purple-700 font-medium bg-purple-50 px-1 rounded mb-1">API Gateway</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Left}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-purple-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-purple-500"
      />
    </div>
  );
};

export default GatewayNode;


================================================================================
# FILE: client\components\diagram\NodeTypes\LoadBalancerNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/LoadBalancerNode.js
import React from 'react';
import { Handle, Position } from 'reactflow';
import { Share2 } from 'lucide-react';

const LoadBalancerNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-green-500">
      <div className="flex items-center">
        <Share2 className="h-8 w-8 text-green-500 mr-2" />
        <div>
          <div className="text-xs text-green-700 font-medium bg-green-50 px-1 rounded mb-1">Load Balancer</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Left}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-green-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-green-500"
      />
    </div>
  );
};

export default memo(LoadBalancerNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\MessageEdge.js
# EXTENSION: .js
================================================================================
// Simplified SequenceDiagram components
// Includes:
// 1. Simplified MessageEdge - fixes arrow direction issues
// 2. Simplified LifelineNode - uses single connection points for cleaner interaction
// 3. Simplified onConnect function - handles connections between lifelines
const MessageEdge = ({
    id,
    sourceX,
    sourceY,
    targetX,
    targetY,
    data,
    style = {},
  }) => {
    // For sequence diagrams, keep messages horizontal
    // Use the source Y position for both source and target points
    // Use same Y for both points to create horizontal lines
    const messagePath = `M${sourceX},${sourceY} L${targetX},${sourceY}`;
    const messageText = data?.label || '';
    const isReturn = data?.type === 'return';
    const isAsync = data?.type === 'async';
    
    // Calculate text positioning
    const textX = (sourceX + targetX) / 2;
    const textY = sourceY - 10; // Position text above the line
    
    // Always draw arrow at target point
    const arrowPath = targetX > sourceX
      ? `M${targetX - 5},${sourceY - 5} L${targetX},${sourceY} L${targetX - 5},${sourceY + 5}` // arrow pointing right
      : `M${targetX + 5},${sourceY - 5} L${targetX},${sourceY} L${targetX + 5},${sourceY + 5}`; // arrow pointing left
    
    return (
      <>
        <path
          id={id}
          style={{ 
            ...style, 
            strokeDasharray: isReturn || isAsync ? '5,5' : 'none',
            stroke: isReturn ? '#888' : '#333',
            strokeWidth: 1.5
          }}
          className="react-flow__edge-path"
          d={messagePath}
        />
        {messageText && (
          <text
            x={textX}
            y={textY}
            textAnchor="middle"
            dominantBaseline="middle"
            className="text-xs fill-gray-700"
            style={{ fontSize: 10, fontFamily: 'sans-serif' }}
          >
            {messageText}
          </text>
        )}
        {/* Arrow head - always at target point */}
        <path
          d={arrowPath}
          style={{
            fill: 'none',
            stroke: isReturn ? '#888' : '#333',
            strokeWidth: 1.5
          }}
        />
      </>
    );
  };


================================================================================
# FILE: client\components\diagram\NodeTypes\nodePresets.js
# EXTENSION: .js
================================================================================
// Generate unique IDs for nodes
const generateId = (type) => `${type}-${Math.random().toString(36).substr(2, 9)}`;

// Create a new node with the given parameters
export const createNode = (type, position, label = '', notes = '') => {
  return {
    id: generateId(type),
    type,
    position,
    data: {
      label,
      notes
    }
  };
};

// Create a new edge between nodes
export const createEdge = (sourceId, targetId, label = '') => {
  return {
    id: `edge-${sourceId}-${targetId}`,
    source: sourceId,
    target: targetId,
    label,
    type: 'default'
  };
};

// Node type definitions with their properties
export const NODE_TYPES = {
  client: {
    label: 'Client',
    color: 'purple'
  },
  service: {
    label: 'Service',
    color: 'green'
  },
  database: {
    label: 'Database',
    color: 'blue'
  },
  loadBalancer: {
    label: 'Load Balancer',
    color: 'orange'
  },
  cache: {
    label: 'Cache',
    color: 'red'
  },
  queue: {
    label: 'Queue',
    color: 'yellow'
  },
  gateway: {
    label: 'Gateway',
    color: 'indigo'
  }
};

// Get palette configuration for node types
export const getNodeTypePalette = () => {
  return Object.entries(NODE_TYPES).map(([type, config]) => ({
    type,
    label: config.label,
    color: config.color
  }));
};


================================================================================
# FILE: client\components\diagram\NodeTypes\QueueNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/QueueNode.js
import React from 'react';
import { Handle, Position } from 'reactflow';
import { Box } from 'lucide-react';

const QueueNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-yellow-500">
      <div className="flex items-center">
        <Box className="h-8 w-8 text-yellow-500 mr-2" />
        <div>
          <div className="text-xs text-yellow-700 font-medium bg-yellow-50 px-1 rounded mb-1">Queue</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Left}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-yellow-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-yellow-500"
      />
    </div>
  );
};

export default memo(QueueNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\SequenceDiagramNodeTypes.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/SequenceDiagramNodeTypes.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { User, Server, AlertTriangle, AlignLeft, Layers } from 'lucide-react';

/**
 * Actor Node - Represents a human participant in the sequence diagram
 */
export const ActorNode = memo(({ data, selected }) => (
  <div 
    className={`px-4 py-2 shadow-md rounded-md bg-white border-2 ${selected ? 'border-blue-700' : 'border-blue-500'}`}
  >
    <div className="flex flex-col items-center">
      <User className="h-8 w-8 text-blue-500 mb-2" />
      <div className="text-sm font-bold text-center">{data.label}</div>
    </div>
    <Handle
      type="source"
      position={Position.Bottom}
      id="bottom"
      isConnectable={false}
      className="w-3 h-3 bg-blue-500"
    />
  </div>
));

/**
 * Participant Node - Represents a system or component in the sequence diagram
 */
export const ParticipantNode = memo(({ data, selected }) => (
  <div 
    className={`px-4 py-2 shadow-md rounded-md bg-white border-2 ${selected ? 'border-purple-700' : 'border-purple-500'}`}
  >
    <div className="flex flex-col items-center">
      <Server className="h-8 w-8 text-purple-500 mb-2" />
      <div className="text-sm font-bold text-center">{data.label}</div>
    </div>
    <Handle
      type="source"
      position={Position.Bottom}
      id="bottom"
      isConnectable={false}
      className="w-3 h-3 bg-purple-500"
    />
  </div>
));

/**
 * Lifeline Node - Represents the timeline of a participant in the sequence diagram
 */
export const LifelineNode = memo(({ data, selected }) => (
  <div 
    className={`sequence-lifeline-node ${selected ? 'border-l-2 border-gray-500' : ''}`} 
    style={{ width: '2px', height: data.height || 400 }}
  >
    <div className="w-1 h-full bg-gray-400 mx-auto"></div>
    <Handle
      type="target"
      position={Position.Top}
      id="top"
      isConnectable={false}
      style={{ visibility: 'hidden' }}
      className="w-3 h-3 bg-gray-500"
    />
    
    {/* Render activation boxes */}
    {data.activations && data.activations.map((activation, index) => (
      <div 
        key={index}
        className={`bg-${activation.color || 'blue'}-200 border border-${activation.color || 'blue'}-400`}
        style={{
          position: 'absolute',
          width: '10px',
          height: `${activation.height}px`,
          left: '-4px',
          top: `${activation.top}px`,
          zIndex: activation.nestLevel || 1
        }}
      />
    ))}
    
    <Handle
      type="source"
      position={Position.Right}
      id="right"
      className="w-3 h-3 bg-gray-500"
      style={{ right: '-6px', top: '50%' }}
      isConnectable={true}
    />
    <Handle
      type="target"
      position={Position.Left}
      id="left"
      className="w-3 h-3 bg-gray-500"
      style={{ left: '-6px', top: '50%' }}
      isConnectable={true}
    />
  </div>
));

/**
 * Combined Fragment Node - Represents logical groupings like alt, opt, loop, etc.
 */
export const CombinedFragmentNode = memo(({ data, selected }) => (
  <div 
    className={`px-2 py-1 border-2 ${selected ? 'border-gray-600' : 'border-gray-400'} bg-gray-50 bg-opacity-70 rounded-md`}
    style={{ width: data.width || 300, height: data.height || 120 }}
  >
    <div className="text-xs font-bold border-b border-gray-400 pb-1 mb-2 flex justify-between">
      <span>{data.fragmentType || 'opt'}</span>
      {data.condition && <span className="text-gray-600">[{data.condition}]</span>}
    </div>
    <div className="text-xs text-gray-600">{data.label || 'Fragment content'}</div>
    
    <Handle
      type="source"
      position={Position.Right}
      id="right"
      className="w-3 h-3 bg-gray-500"
    />
    <Handle
      type="target"
      position={Position.Left}
      id="left"
      className="w-3 h-3 bg-gray-500"
    />
    <Handle
      type="source"
      position={Position.Bottom}
      id="bottom"
      className="w-3 h-3 bg-gray-500"
    />
    <Handle
      type="target"
      position={Position.Top}
      id="top"
      className="w-3 h-3 bg-gray-500"
    />
  </div>
));

/**
 * Note Node - Represents a comment or note in the sequence diagram
 */
export const NoteNode = memo(({ data, selected }) => (
  <div 
    className={`px-2 py-1 bg-yellow-100 border-2 ${selected ? 'border-yellow-600' : 'border-yellow-400'} rounded-md shadow-sm`}
    style={{ maxWidth: '150px' }}
  >
    <div className="flex items-center mb-1">
      <AlignLeft className="h-3 w-3 text-yellow-700 mr-1" />
      <div className="text-xs font-medium text-yellow-700">Note</div>
    </div>
    <div className="text-xs">{data.label || 'Note text'}</div>
    
    <Handle
      type="source"
      position={Position.Right}
      id="right"
      className="w-3 h-3 bg-yellow-500"
    />
    <Handle
      type="target"
      position={Position.Left}
      id="left"
      className="w-3 h-3 bg-yellow-500"
    />
  </div>
));

/**
 * Gate Node - Represents a message to/from outside the diagram
 */
export const GateNode = memo(({ data, selected }) => (
  <div 
    className={`px-2 py-2 bg-gray-100 border-2 ${selected ? 'border-gray-600' : 'border-gray-400'} rounded-md shadow-sm`}
  >
    <div className="flex items-center justify-center">
      <AlertTriangle className="h-4 w-4 text-gray-600" />
    </div>
    <div className="text-xs text-center mt-1">{data.label || 'Gate'}</div>
    
    <Handle
      type="source"
      position={Position.Right}
      id="right"
      className="w-3 h-3 bg-gray-500"
    />
    <Handle
      type="target"
      position={Position.Left}
      id="left"
      className="w-3 h-3 bg-gray-500"
    />
  </div>
));

// Message types for edges
export const MessageTypes = {
  SYNC: 'sync',
  ASYNC: 'async',
  RETURN: 'return',
  CREATE: 'create',
  DESTROY: 'destroy',
  FOUND: 'found',
  LOST: 'lost'
};

// Fragment types
export const FragmentTypes = {
  ALT: 'alt',
  OPT: 'opt',
  LOOP: 'loop',
  BREAK: 'break',
  PAR: 'par',
  CRITICAL: 'critical',
  NEG: 'neg',
  REF: 'ref'
};

// Export all node types as a collection for easy import
export const sequenceDiagramNodeTypes = {
  actor: ActorNode,
  participant: ParticipantNode,
  lifeline: LifelineNode,
  fragment: CombinedFragmentNode,
  note: NoteNode,
  gate: GateNode
};


================================================================================
# FILE: client\components\diagram\NodeTypes\ServiceNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/ServiceNode.js
import React from 'react';
import { Handle, Position } from 'reactflow';
import { Server } from 'lucide-react';

const ServiceNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-blue-500">
      <div className="flex items-center">
        <Server className="h-8 w-8 text-blue-500 mr-2" />
        <div>
          <div className="text-xs text-blue-700 font-medium bg-blue-50 px-1 rounded mb-1">Service</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Left}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-blue-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-blue-500"
      />
    </div>
  );
};

export default memo(ServiceNode);


================================================================================
# FILE: client\components\diagram\PatternVisualizer.js
# EXTENSION: .js
================================================================================
import React from 'react';
import { Box, Card, Typography, List, ListItem, ListItemIcon, ListItemText, Chip } from '@mui/material';
import { Check, Close, TrendingUp, Security, Speed, Cloud } from '@mui/icons-material';

const patternIcons = {
  loadBalancing: <TrendingUp />,
  microservices: <Cloud />,
  caching: <Speed />,
  messageQueue: <TrendingUp />,
  apiGateway: <Security />
};

const PatternVisualizer = ({ patterns, suggestions }) => {
  const getPatternStatus = (pattern) => {
    return patterns[pattern] ? (
      <Chip 
        icon={<Check />} 
        label="Detected" 
        color="success" 
        size="small" 
      />
    ) : (
      <Chip 
        icon={<Close />} 
        label="Missing" 
        color="warning" 
        size="small" 
      />
    );
  };

  return (
    <Card sx={{ p: 2, m: 2 }}>
      <Typography variant="h6" gutterBottom>
        Architectural Patterns
      </Typography>
      <List>
        {Object.entries(patterns).map(([pattern, detected]) => (
          <ListItem key={pattern}>
            <ListItemIcon>
              {patternIcons[pattern]}
            </ListItemIcon>
            <ListItemText 
              primary={pattern.charAt(0).toUpperCase() + pattern.slice(1)} 
              secondary={
                !detected && suggestions.find(s => s.toLowerCase().includes(pattern.toLowerCase()))
              }
            />
            {getPatternStatus(pattern)}
          </ListItem>
        ))}
      </List>
    </Card>
  );
};

export default PatternVisualizer;


================================================================================
# FILE: client\components\diagram\ReactFlowDiagram.js
# EXTENSION: .js
================================================================================
// client/components/diagram/ReactFlowDiagram.js
import React, { useState, useCallback } from 'react';
import ReactFlow, {
  ReactFlowProvider,
  Controls,
  Background,
  Panel
} from 'reactflow';
import { Globe, Server, Database, Archive, Grid, Share2, Box } from 'lucide-react';
import 'reactflow/dist/style.css';

// Import custom node types
import DatabaseNode from './NodeTypes/DatabaseNode';
import ServiceNode from './NodeTypes/ServiceNode';
import ClientNode from './NodeTypes/ClientNode';
import LoadBalancerNode from './NodeTypes/LoadBalancerNode';
import CacheNode from './NodeTypes/CacheNode';
import QueueNode from './NodeTypes/QueueNode';
import CustomNode from './NodeTypes/CustomNode';
import GatewayNode from './NodeTypes/GatewayNode';

// Define nodeTypes outside the component to prevent re-creation on each render
const nodeTypes = {
  database: DatabaseNode,
  service: ServiceNode,
  client: ClientNode,
  loadBalancer: LoadBalancerNode,
  cache: CacheNode,
  queue: QueueNode,
  custom: CustomNode,
  gateway: GatewayNode
};

const Flow = ({ 
  initialNodes, 
  initialEdges, 
  onNodesChange, 
  onEdgesChange, 
  onConnect,
  onDiagramUpdate 
}) => {
  const reactFlowWrapper = useRef(null);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);
  const [autoLayout, setAutoLayout] = useState(false);
  const [selectedNode, setSelectedNode] = useState(null);
  const [showNodeEditor, setShowNodeEditor] = useState(false);
  const [nodeName, setNodeName] = useState('');
  const [nodeNotes, setNodeNotes] = useState('');
  const [isDragging, setIsDragging] = useState(false);
  const [selectedElements, setSelectedElements] = useState([]);
  
  // Safely get nodes and edges with defaults
  const safeNodes = Array.isArray(initialNodes) && initialNodes.length > 0 
    ? initialNodes 
    : [{ id: 'default', position: { x: 100, y: 100 }, data: { label: 'Default Node' } }];
  
  const safeEdges = Array.isArray(initialEdges) ? initialEdges : [];

  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onNodeClick = useCallback((event, node) => {
    setSelectedNode(node);
    setNodeName(node.data.label || '');
    setNodeNotes(node.data.notes || '');
    setShowNodeEditor(true);
  }, []);

  const onNodeDoubleClick = useCallback((event, node) => {
    setSelectedNode(node);
    setNodeName(node.data.label || '');
    setNodeNotes(node.data.notes || '');
    setShowNodeEditor(true);
  }, []);

  const handleSaveNodeEdit = useCallback(() => {
    if (!selectedNode) return;
    
    const updatedNodes = safeNodes.map(n => {
      if (n.id === selectedNode.id) {
        return {
          ...n,
          data: {
            ...n.data,
            label: nodeName,
            notes: nodeNotes
          }
        };
      }
      return n;
    });
    
    onNodesChange([{ type: 'reset', items: updatedNodes }]);
    setShowNodeEditor(false);
    setSelectedNode(null);
    
    if (onDiagramUpdate) {
      onDiagramUpdate({
        nodes: updatedNodes,
        edges: safeEdges
      });
    }
  }, [selectedNode, nodeName, nodeNotes, safeNodes, safeEdges, onNodesChange, onDiagramUpdate]);

  const onDrop = useCallback(
    (event) => {
      event.preventDefault();

      if (!reactFlowInstance || !reactFlowWrapper.current) return;

      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const type = event.dataTransfer.getData('application/reactflow');

      const position = reactFlowInstance.project({
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      });

      const newNode = {
        id: `${type}_${Date.now()}`,
        type,
        position,
        data: { 
          label: '',  // Empty label initially
          notes: '',
          type: type  // Store the type separately
        },
      };

      // Show the label editor immediately
      setSelectedNode(newNode);
      setNodeName('');
      setNodeNotes('');
      setShowNodeEditor(true);

      // Add node to diagram
      onNodesChange([{ type: 'add', item: newNode }]);
    },
    [reactFlowInstance]
  );

  const handleConnect = useCallback((params) => {
    const newEdge = {
      ...params,
      id: `edge-${params.source}-${params.target}`,
      type: 'smoothstep',
      data: { label: '' }
    };
    
    const updatedEdges = addEdge(newEdge, safeEdges);
    onConnect(params);
    
    if (onDiagramUpdate) {
      onDiagramUpdate({
        nodes: safeNodes,
        edges: updatedEdges
      });
    }
  }, [safeNodes, safeEdges, onConnect, onDiagramUpdate]);

  const handleAddNode = useCallback((type) => {
    const name = prompt("Enter a name for this node:");
    if (!name) return;

    const newNode = {
      id: `${type}-${Date.now()}`,
      type,
      position: { x: 100, y: 100 },
      data: { label: name }
    };
    
    onNodesChange([{ type: 'add', item: newNode }]);
  }, [onNodesChange]);

  const handleDelete = useCallback(() => {
    selectedElements.forEach(element => {
      onNodesChange([{ type: 'remove', id: element.id }]);
    });
  }, [selectedElements, onNodesChange]);

  return (
    <div className="w-full h-full relative" ref={reactFlowWrapper} style={{ minHeight: '300px' }}>
      <ReactFlow
        nodes={safeNodes}
        edges={safeEdges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={handleConnect}
        onInit={setReactFlowInstance}
        onDrop={onDrop}
        onDragOver={onDragOver}
        onNodeClick={onNodeClick}
        onNodeDoubleClick={onNodeDoubleClick}
        nodeTypes={nodeTypes}
        fitView={false}
        attributionPosition="bottom-left"
        minZoom={0.5}
        maxZoom={2}
        deleteKeyCode={['Backspace', 'Delete']}
        multiSelectionKeyCode={['Control', 'Meta']}
        snapToGrid={autoLayout}
        snapGrid={[15, 15]}
        connectionLineStyle={{ strokeWidth: 2, stroke: '#999' }}
        connectionLineType="smoothstep"
        onSelectionChange={(elements) => setSelectedElements(elements)}
      >
        <Controls />
        <Background variant="dots" gap={12} size={1} />
        <Panel position="top-right">
          <div className="bg-white p-2 rounded shadow-md flex flex-col space-y-2">
            <button 
              onClick={() => setAutoLayout(!autoLayout)} 
              className={`px-2 py-1 text-xs rounded ${autoLayout ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
            >
              {autoLayout ? 'Disable Auto Layout' : 'Enable Auto Layout'}
            </button>
            <button 
              onClick={() => {
                if (reactFlowInstance) {
                  reactFlowInstance.fitView();
                }
              }}
              className="px-2 py-1 text-xs bg-gray-200 rounded"
            >
              Center View
            </button>
          </div>
        </Panel>
        <Panel position="bottom" className="w-full">
          <div className="bg-white p-2 border-t border-gray-200 flex flex-wrap justify-center gap-2">
            {[
              { type: 'client', icon: <Globe className="w-4 h-4" />, color: 'blue', label: 'Client' },
              { type: 'service', icon: <Server className="w-4 h-4" />, color: 'green', label: 'Service' },
              { type: 'database', icon: <Database className="w-4 h-4" />, color: 'purple', label: 'Database' },
              { type: 'cache', icon: <Archive className="w-4 h-4" />, color: 'red', label: 'Cache' },
              { type: 'loadBalancer', icon: <Grid className="w-4 h-4" />, color: 'orange', label: 'Load Balancer' },
              { type: 'queue', icon: <Share2 className="w-4 h-4" />, color: 'indigo', label: 'Queue' },
              { type: 'custom', icon: <Box className="w-4 h-4" />, color: 'gray', label: 'Custom' }
            ].map(({ type, icon, color, label }) => (
              <button
                key={type}
                onClick={() => handleAddNode(type)}
                className="flex items-center px-2 py-1 text-xs rounded bg-gray-100 text-gray-700 border border-gray-200 hover:bg-gray-200"
                draggable
                onDragStart={(event) => {
                  event.dataTransfer.setData('application/reactflow', type);
                  setIsDragging(true);
                }}
                onDragEnd={() => setIsDragging(false)}
              >
                <span className="mr-1">{icon}</span>
                {label}
              </button>
            ))}
          </div>
        </Panel>
      </ReactFlow>
      
      {showNodeEditor && selectedNode && (
        <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-10">
          <div className="bg-white rounded-lg p-4 w-64">
            <h3 className="font-medium mb-2">Edit Node</h3>
            <div className="mb-4">
              <label className="block text-sm text-gray-700 mb-1">Name</label>
              <input 
                type="text" 
                value={nodeName} 
                onChange={(e) => setNodeName(e.target.value)}
                className="w-full px-2 py-1 border rounded"
              />
            </div>
            <div className="mb-4">
              <label className="block text-sm text-gray-700 mb-1">Notes</label>
              <textarea 
                value={nodeNotes} 
                onChange={(e) => setNodeNotes(e.target.value)}
                className="w-full px-2 py-1 border rounded h-20"
              />
            </div>
            <div className="flex justify-end space-x-2">
              <button 
                onClick={() => setShowNodeEditor(false)}
                className="px-3 py-1 text-sm bg-gray-200 rounded"
              >
                Cancel
              </button>
              <button 
                onClick={handleSaveNodeEdit}
                className="px-3 py-1 text-sm bg-blue-500 text-white rounded"
              >
                Save
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

// Wrapper with error handling
const ReactFlowDiagramWithProvider = (props) => {
  return (
    <ReactFlowProvider>
      <Flow {...props} />
    </ReactFlowProvider>
  );
};

export default ReactFlowDiagramWithProvider;


================================================================================
# FILE: client\components\diagram\ScorePanel.js
# EXTENSION: .js
================================================================================
import React from 'react';
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer } from 'recharts';
import { Shield, Zap, Server, Tool } from 'lucide-react';
import './styles/ScorePanel.css';

const ScorePanel = ({ scores, improvements }) => {
  const categoryIcons = {
    security: <Shield size={20} />,
    scalability: <Zap size={20} />,
    reliability: <Server size={20} />,
    maintainability: <Tool size={20} />
  };

  const formatScoreData = () => {
    return Object.entries(scores).map(([category, data]) => ({
      name: category,
      score: data.value,
      factors: data.factors
    })).filter(item => item.name !== 'overall');
  };

  return (
    <div className="score-panel">
      <div className="overall-score">
        <h2>Overall Score</h2>
        <div className="score-circle">
          <span>{Math.round(scores.overall)}</span>
        </div>
      </div>

      <div className="category-scores">
        <h3>Category Breakdown</h3>
        <ResponsiveContainer width="100%" height={200}>
          <BarChart data={formatScoreData()}>
            <XAxis dataKey="name" />
            <YAxis domain={[0, 100]} />
            <Tooltip />
            <Bar dataKey="score" fill="#4CAF50" />
          </BarChart>
        </ResponsiveContainer>
      </div>

      <div className="score-details">
        {Object.entries(scores).map(([category, data]) => {
          if (category === 'overall') return null;
          return (
            <div key={category} className="category-detail">
              <div className="category-header">
                {categoryIcons[category]}
                <h4>{category}</h4>
                <span className="category-score">{data.value}</span>
              </div>
              <ul className="factor-list">
                {data.factors.map((factor, index) => (
                  <li key={index}>{factor}</li>
                ))}
              </ul>
            </div>
          );
        })}
      </div>

      <div className="improvement-plan">
        <h3>Improvement Plan</h3>
        
        <div className="timeline">
          <div className="timeline-section">
            <h4>Immediate Actions</h4>
            <ul>
              {improvements.immediate.map((item, index) => (
                <li key={index} className={`priority-${item.impact}`}>
                  <span className="action">{item.action}</span>
                  <span className="effort-tag">{item.effort}</span>
                </li>
              ))}
            </ul>
          </div>

          <div className="timeline-section">
            <h4>Short Term</h4>
            <ul>
              {improvements.shortTerm.map((item, index) => (
                <li key={index} className={`priority-${item.impact}`}>
                  <span className="action">{item.action}</span>
                  <span className="effort-tag">{item.effort}</span>
                </li>
              ))}
            </ul>
          </div>

          <div className="timeline-section">
            <h4>Long Term</h4>
            <ul>
              {improvements.longTerm.map((item, index) => (
                <li key={index} className={`priority-${item.impact}`}>
                  <span className="action">{item.action}</span>
                  <span className="effort-tag">{item.effort}</span>
                </li>
              ))}
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ScorePanel;


================================================================================
# FILE: client\components\diagram\SequenceDiagram.js
# EXTENSION: .js
================================================================================
// client/components/diagram/SequenceDiagram.js
import React, { useState, useCallback, useEffect, useRef } from 'react';
import { memo } from 'react';
import ReactFlow, { 
  ReactFlowProvider, 
  Background, 
  Controls,
  Handle, 
  Position,
  addEdge,
  applyEdgeChanges, 
  applyNodeChanges,
  Panel
} from 'reactflow';
import 'reactflow/dist/style.css';
import { User, Server, ArrowRight, Plus, Edit, Trash2, Save, Download, HelpCircle, Layout } from 'lucide-react';

// Custom Node Types for Sequence Diagrams
const ActorNode = memo(({ data, selected }) => (
  <div 
    className={`px-4 py-2 shadow-md rounded-md bg-white border-2 ${selected ? 'border-blue-700' : 'border-blue-500'}`}
  >
    <div className="flex flex-col items-center">
      <User className="h-8 w-8 text-blue-500 mb-2" />
      <div className="text-sm font-bold text-center">{data.label}</div>
    </div>
    <Handle
      type="source"
      position={Position.Bottom}
      id="bottom"
      isConnectable={true}
      className="w-3 h-3 bg-blue-500"
    />
  </div>
));

const ParticipantNode = memo(({ data, selected }) => (
  <div 
    className={`px-4 py-2 shadow-md rounded-md bg-white border-2 ${selected ? 'border-purple-700' : 'border-purple-500'}`}
  >
    <div className="flex flex-col items-center">
      <Server className="h-8 w-8 text-purple-500 mb-2" />
      <div className="text-sm font-bold text-center">{data.label}</div>
    </div>
    <Handle
      type="source"
      position={Position.Bottom}
      id="bottom"
      isConnectable={true}
      className="w-3 h-3 bg-purple-500"
    />
  </div>
));

const LifelineNode = memo(({ data, selected }) => (
  <div 
    className={`sequence-lifeline-node ${selected ? 'border-l-2 border-gray-500' : ''}`} 
    style={{ width: '2px', height: 400 }}
  >
    <div className="w-0.5 h-full bg-gray-300 mx-auto"></div>
    <Handle
      type="target"
      position={Position.Top}
      id="top"
      isConnectable={true}
      style={{ opacity: 0 }}
      className="w-3 h-3 bg-gray-500"
    />
    {data.activations && data.activations.map((activation, index) => (
      <div 
        key={index}
        className="bg-gray-200 border border-gray-400"
        style={{
          position: 'absolute',
          width: '10px',
          height: `${activation.height}px`,
          left: '-4px',
          top: `${activation.top}px`,
        }}
      />
    ))}
    {/* Multiple connection points along the lifeline */}
    {Array.from({ length: 8 }).map((_, index) => (
      <React.Fragment key={`connection-points-${index}`}>
        <Handle
          type="source"
          position={Position.Right}
          id={`right-${index}`}
          style={{ top: `${(index + 1) * 50}px` }}
          className="w-3 h-3 bg-gray-500"
        />
        <Handle
          type="target"
          position={Position.Left}
          id={`left-${index}`}
          style={{ top: `${(index + 1) * 50}px` }}
          className="w-3 h-3 bg-gray-500"
        />
      </React.Fragment>
    ))}
  </div>
));

const MessageEdge = ({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  data,
  style = {},
}) => {
  // For sequence diagrams, keep messages horizontal
  // Use the source Y position for both source and target points
  const straightEdgePath = `M${sourceX},${sourceY} L${targetX},${sourceY}`;
  const messageText = data?.label || '';
  const isReturn = data?.type === 'return';
  const isAsync = data?.type === 'async';
  
  // Automatically determine direction based on node positions
  const direction = sourceX < targetX ? 'ltr' : 'rtl';
  
  // Calculate text positioning
  const textX = (sourceX + targetX) / 2;
  const textY = sourceY - 10; // Position text above the line
  
  // Determine which end gets the arrow based on direction
  let arrowX, arrowY;
  if (direction === 'ltr') {
    arrowX = targetX;
    arrowY = sourceY;
  } else {
    arrowX = sourceX;
    arrowY = sourceY;
  }
  
  // Generate arrow path based on direction
  const arrowPath = direction === 'ltr'
    ? `M${arrowX - 5},${arrowY - 5} L${arrowX},${arrowY} L${arrowX - 5},${arrowY + 5}`
    : `M${arrowX + 5},${arrowY - 5} L${arrowX},${arrowY} L${arrowX + 5},${arrowY + 5}`;
  
  return (
    <>
      <path
        id={id}
        style={{ 
          ...style, 
          strokeDasharray: isReturn || isAsync ? '5,5' : 'none',
          stroke: isReturn ? '#888' : '#333',
          strokeWidth: 1.5
        }}
        className="react-flow__edge-path"
        d={straightEdgePath}
      />
      {messageText && (
        <text
          x={textX}
          y={textY}
          textAnchor="middle"
          dominantBaseline="middle"
          className="text-xs fill-gray-700"
          style={{ fontSize: 10, fontFamily: 'sans-serif' }}
        >
          {messageText}
        </text>
      )}
      {/* Arrow head */}
      <path
        d={arrowPath}
        style={{
          fill: 'none',
          stroke: isReturn ? '#888' : '#333',
          strokeWidth: 1.5
        }}
      />
    </>
  );
};

// Function to convert nodes and edges to mermaid syntax
function generateMermaidCode(nodes, edges) {
  if (!nodes || !edges) return '';
  
  const participants = nodes.filter(node => 
    node.type === 'actor' || node.type === 'participant'
  );
  
  // Start with sequence diagram declaration
  let code = 'sequenceDiagram\n';
  
  // Declare participants
  participants.forEach(participant => {
    if (participant.type === 'actor') {
      code += `    actor ${participant.data.label.replace(/\s+/g, '_')}\n`;
    } else {
      code += `    participant ${participant.data.label.replace(/\s+/g, '_')}\n`;
    }
  });
  
  // Sort edges by vertical position to maintain proper sequence
  const sortedEdges = [...edges].sort((a, b) => {
    const nodeA = nodes.find(n => n.id === a.source);
    const nodeB = nodes.find(n => n.id === b.source);
    if (!nodeA || !nodeB) return 0;
    
    return nodeA.position.y - nodeB.position.y;
  });
  
  // Add messages
  sortedEdges.forEach(edge => {
    if (!edge.data?.label) return;
    
    // Find the lifelines
    const sourceLifeline = nodes.find(n => n.id === edge.source);
    const targetLifeline = nodes.find(n => n.id === edge.target);
    
    if (!sourceLifeline || !targetLifeline) return;
    
    // Find the parent participants of these lifelines
    const sourceParticipant = nodes.find(n => 
      (n.type === 'actor' || n.type === 'participant') && 
      sourceLifeline.data?.participantId === n.id
    );
    
    const targetParticipant = nodes.find(n => 
      (n.type === 'actor' || n.type === 'participant') && 
      targetLifeline.data?.participantId === n.id
    );
    
    if (!sourceParticipant || !targetParticipant) return;
    
    const sourceLabel = sourceParticipant.data.label.replace(/\s+/g, '_');
    const targetLabel = targetParticipant.data.label.replace(/\s+/g, '_');
    const messageLabel = edge.data.label;
    const messageType = edge.data.type || 'sync';
    
    if (messageType === 'sync') {
      code += `    ${sourceLabel}->>+${targetLabel}: ${messageLabel}\n`;
    } else if (messageType === 'async') {
      code += `    ${sourceLabel}-->>+${targetLabel}: ${messageLabel}\n`;
    } else if (messageType === 'return') {
      code += `    ${sourceLabel}-->>-${targetLabel}: ${messageLabel}\n`;
    }
  });
  
  return code;
}

// Main Sequence Diagram Component
const SequenceDiagram = ({ initialDiagram, onDiagramUpdate }) => {
  // Define node and edge types
  const nodeTypes = {
    actor: ActorNode,
    participant: ParticipantNode,
    lifeline: LifelineNode
  };
  
  const edgeTypes = {
    message: MessageEdge
  };
  
  // State initialization
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [selectedElement, setSelectedElement] = useState(null);
  const [messageType, setMessageType] = useState('sync');
  const [editingLabel, setEditingLabel] = useState('');
  const [isEditing, setIsEditing] = useState(false);
  const [showHelp, setShowHelp] = useState(false);
  
  // Use refs to prevent circular updates
  const nodesRef = useRef(nodes);
  const edgesRef = useRef(edges);
  const mermaidCodeRef = useRef('');
  const isInitializedRef = useRef(false);
  const isMountedRef = useRef(false);
  const isUpdatingRef = useRef(false);
  
  // Safe update functions to prevent infinite loops - defined before they're used
  const safeSetNodes = useCallback((newNodes) => {
    if (isUpdatingRef.current) return;
    
    isUpdatingRef.current = true;
    setNodes(newNodes);
    nodesRef.current = newNodes;
    
    // Reset the flag after a small delay
    setTimeout(() => {
      isUpdatingRef.current = false;
    }, 0);
  }, []);
  
  const safeSetEdges = useCallback((newEdges) => {
    if (isUpdatingRef.current) return;
    
    isUpdatingRef.current = true;
    setEdges(newEdges);
    edgesRef.current = newEdges;
    
    // Reset the flag after a small delay
    setTimeout(() => {
      isUpdatingRef.current = false;
    }, 0);
  }, []);
  
  // Initialize diagram only once
  useEffect(() => {
    // Set mounted flag
    isMountedRef.current = true;
    
    if (isInitializedRef.current) return;
    
    let diagramNodes = [];
    let diagramEdges = [];
    
    try {
      if (initialDiagram && initialDiagram.nodes && initialDiagram.nodes.length > 0) {
        // Use the provided diagram data
        diagramNodes = [...initialDiagram.nodes];
        diagramEdges = initialDiagram.edges ? [...initialDiagram.edges] : [];
        
        if (initialDiagram.mermaidCode) {
          mermaidCodeRef.current = initialDiagram.mermaidCode;
        } else {
          mermaidCodeRef.current = generateMermaidCode(diagramNodes, diagramEdges);
        }
      } else {
        // Create default sequence diagram with two participants
        const timestamp = Date.now();
        const actor1Id = `actor-${timestamp}`;
        const actor2Id = `participant-${timestamp + 1}`;
        const lifeline1Id = `lifeline-${timestamp + 2}`;
        const lifeline2Id = `lifeline-${timestamp + 3}`;
        
        diagramNodes = [
          // Participants at the top
          { 
            id: actor1Id, 
            type: 'actor', 
            position: { x: 150, y: 50 }, 
            data: { 
              label: 'User',
              id: actor1Id
            } 
          },
          { 
            id: actor2Id, 
            type: 'participant', 
            position: { x: 350, y: 50 }, 
            data: { 
              label: 'System',
              id: actor2Id
            } 
          },
          // Lifelines below each participant
          {
            id: lifeline1Id,
            type: 'lifeline',
            position: { x: 175, y: 120 },
            data: { 
              label: '', 
              participantId: actor1Id,
              height: 400,
              activations: [],
              id: lifeline1Id
            }
          },
          {
            id: lifeline2Id,
            type: 'lifeline',
            position: { x: 375, y: 120 },
            data: { 
              label: '', 
              participantId: actor2Id,
              height: 400,
              activations: [],
              id: lifeline2Id
            }
          }
        ];
        
        diagramEdges = [
          {
            id: `edge-${lifeline1Id}-${lifeline2Id}-${timestamp}`,
            source: lifeline1Id,
            target: lifeline2Id,
            sourceHandle: 'right',
            targetHandle: 'left',
            data: { 
              label: 'Request',
              type: 'sync'
            },
            type: 'message',
            animated: false
          }
        ];
        
        mermaidCodeRef.current = generateMermaidCode(diagramNodes, diagramEdges);
      }
      
      // Set initial state
      safeSetNodes(diagramNodes);
      safeSetEdges(diagramEdges);
      
      // Update refs
      nodesRef.current = diagramNodes;
      edgesRef.current = diagramEdges;
      
      isInitializedRef.current = true;
    } catch (error) {
      console.error("Error initializing sequence diagram:", error);
    }
    
    // Cleanup function
    return () => {
      isMountedRef.current = false;
    };
  }, [initialDiagram, safeSetNodes, safeSetEdges]);
  
  // Update mermaid code whenever nodes or edges change
  useEffect(() => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    // We've already updated refs in safeSet* functions
    const newMermaidCode = generateMermaidCode(nodesRef.current, edgesRef.current);
    
    // Only update if code has changed
    if (newMermaidCode !== mermaidCodeRef.current) {
      mermaidCodeRef.current = newMermaidCode;
      
      // Notify parent if callback exists
      if (onDiagramUpdate && isMountedRef.current) {
        onDiagramUpdate({
          nodes: nodesRef.current,
          edges: edgesRef.current,
          mermaidCode: newMermaidCode
        });
      }
    }
  }, [nodes, edges, onDiagramUpdate]);
  
  // Handle node changes - with strict rules for sequence diagrams
  const onNodesChange = useCallback((changes) => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    const updatedNodes = applyNodeChanges(changes, nodesRef.current);
    
    // For position changes, enforce sequence diagram rules
    const positionChanges = changes.filter(change => change.type === 'position');
    if (positionChanges.length > 0) {
      const finalNodes = updatedNodes.map(node => {
        // Find if this node was moved
        const change = positionChanges.find(c => c.id === node.id);
        if (!change) return node;
        
        // For actors/participants, only allow horizontal movement
        if (node.type === 'actor' || node.type === 'participant') {
          const newY = 50; // Fix Y position at top
          
          // Update lifeline position to match
          const correspondingLifeline = updatedNodes.find(
            n => n.type === 'lifeline' && n.data?.participantId === node.id
          );
          
          if (correspondingLifeline) {
            // Update the lifeline's x position to match the participant
            const lifelineIndex = updatedNodes.findIndex(n => n.id === correspondingLifeline.id);
            if (lifelineIndex >= 0) {
              updatedNodes[lifelineIndex] = {
                ...updatedNodes[lifelineIndex],
                position: {
                  x: node.position.x + 25, // Center the lifeline under the participant
                  y: updatedNodes[lifelineIndex].position.y
                }
              };
            }
          }
          
          return {
            ...node,
            position: {
              x: node.position.x, // Allow X movement
              y: newY // Fix Y position
            }
          };
        }
        
        // For lifelines, only allow vertical position changes
        if (node.type === 'lifeline') {
          // Find the associated participant
          const participant = updatedNodes.find(
            n => (n.type === 'actor' || n.type === 'participant') && n.id === node.data?.participantId
          );
          
          if (participant) {
            return {
              ...node,
              position: {
                x: participant.position.x + 25, // Keep aligned with participant
                y: node.position.y // Allow vertical movement
              }
            };
          }
        }
        
        return node;
      });
      
      safeSetNodes(finalNodes);
    } else {
      safeSetNodes(updatedNodes);
    }
  }, [safeSetNodes]);
  
  // Handle edge changes
  const onEdgesChange = useCallback((changes) => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    const updatedEdges = applyEdgeChanges(changes, edgesRef.current);
    safeSetEdges(updatedEdges);
  }, [safeSetEdges]);
  
  // Handle connections - enforce sequence diagram rules
  const onConnect = useCallback((params) => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    // Allow connections between any connection points along lifelines
    // Check for both directions (left-to-right and right-to-left)
    const isLeftToRight = params.sourceHandle?.startsWith('right') && params.targetHandle?.startsWith('left');
    const isRightToLeft = params.sourceHandle?.startsWith('left') && params.targetHandle?.startsWith('right');
    
    if (isLeftToRight || isRightToLeft) {
      // Get the source and target nodes
      const sourceNode = nodesRef.current.find(n => n.id === params.source);
      const targetNode = nodesRef.current.find(n => n.id === params.target);
      
      if (!sourceNode || !targetNode) return;
      
      // For proper sequence diagram behavior, extract vertical position from handle IDs
      const sourcePos = parseInt(params.sourceHandle.split('-')[1]) || 0;
      const targetPos = parseInt(params.targetHandle.split('-')[1]) || 0;
      
      // Add connection at the same vertical level (maintaining sequence diagram conventions)
      const newEdge = {
        id: `edge-${params.source}-${params.target}-${Date.now()}`,
        source: params.source,
        target: params.target,
        sourceHandle: params.sourceHandle,
        targetHandle: params.targetHandle,
        data: { 
          label: 'New Message',
          type: messageType,
          // Store vertical position for reference
          verticalPosition: Math.max(sourcePos, targetPos),
          // Store direction for drawing
          direction: isLeftToRight ? 'ltr' : 'rtl'
        },
        type: 'message',
        animated: false
      };
      
      const newEdges = addEdge(newEdge, edgesRef.current);
      safeSetEdges(newEdges);
      
      // Select the new edge
      setSelectedElement(newEdge);
      setIsEditing(true);
      setEditingLabel('New Message');
    }
  }, [messageType, safeSetEdges]);
  
  // Handle node selection
  const onNodeClick = useCallback((_, node) => {
    if (!isInitializedRef.current) return;
    
    if (node.type === 'actor' || node.type === 'participant') {
      setSelectedElement(node);
      setEditingLabel(node.data?.label || '');
      setIsEditing(false);
    }
  }, []);
  
  // Handle edge selection
  const onEdgeClick = useCallback((_, edge) => {
    if (!isInitializedRef.current) return;
    
    setSelectedElement(edge);
    setEditingLabel(edge.data?.label || '');
    setIsEditing(false);
  }, []);
  
  // Save edited label
  const saveLabel = useCallback(() => {
    if (!isInitializedRef.current || !selectedElement || !editingLabel.trim()) return;
    
    if (selectedElement.source) {
      // It's an edge
      const updatedEdges = edgesRef.current.map(e => 
        e.id === selectedElement.id 
          ? { ...e, data: { ...e.data, label: editingLabel } }
          : e
      );
      safeSetEdges(updatedEdges);
    } else {
      // It's a node
      const updatedNodes = nodesRef.current.map(n => 
        n.id === selectedElement.id 
          ? { ...n, data: { ...n.data, label: editingLabel } }
          : n
      );
      safeSetNodes(updatedNodes);
    }
    
    setIsEditing(false);
  }, [selectedElement, editingLabel, safeSetEdges, safeSetNodes]);
  
  // Add a new actor
  const addActor = useCallback(() => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    // Generate unique IDs for new nodes
    const timestamp = Date.now();
    const actorId = `actor-${timestamp}`;
    const lifelineId = `lifeline-${timestamp + 1}`;
    
    // Determine position (place new actor to the right of existing ones)
    const lastX = Math.max(
      ...nodesRef.current
        .filter(n => n.type === 'actor' || n.type === 'participant')
        .map(n => n.position.x + 200),
      100 // default starting position if no nodes exist
    );
    
    const newActor = { 
      id: actorId, 
      type: 'actor', 
      position: { x: lastX, y: 50 }, 
      data: { 
        label: 'New Actor',
        id: actorId
      } 
    };
    
    const newLifeline = {
      id: lifelineId,
      type: 'lifeline',
      position: { x: lastX + 25, y: 120 },
      data: { 
        label: '', 
        participantId: actorId,
        height: 400,
        activations: [],
        id: lifelineId
      }
    };
    
    const updatedNodes = [...nodesRef.current, newActor, newLifeline];
    safeSetNodes(updatedNodes);
    
    // Select the new actor for immediate editing
    setSelectedElement(newActor);
    setEditingLabel('New Actor');
    setIsEditing(true);
  }, [safeSetNodes]);
  
  // Add a new participant (object)
  const addParticipant = useCallback(() => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    // Generate unique IDs for new nodes
    const timestamp = Date.now();
    const participantId = `participant-${timestamp}`;
    const lifelineId = `lifeline-${timestamp + 1}`;
    
    // Determine position (place new participant to the right of existing ones)
    const lastX = Math.max(
      ...nodesRef.current
        .filter(n => n.type === 'actor' || n.type === 'participant')
        .map(n => n.position.x + 200),
      100 // default starting position if no nodes exist
    );
    
    const newParticipant = { 
      id: participantId, 
      type: 'participant', 
      position: { x: lastX, y: 50 }, 
      data: { 
        label: 'New Participant',
        id: participantId
      } 
    };
    
    const newLifeline = {
      id: lifelineId,
      type: 'lifeline',
      position: { x: lastX + 25, y: 120 },
      data: { 
        label: '', 
        participantId: participantId,
        height: 400,
        activations: [],
        id: lifelineId
      }
    };
    
    const updatedNodes = [...nodesRef.current, newParticipant, newLifeline];
    safeSetNodes(updatedNodes);
    
    // Select the new participant for immediate editing
    setSelectedElement(newParticipant);
    setEditingLabel('New Participant');
    setIsEditing(true);
  }, [safeSetNodes]);
  
  // Delete selected element
  const deleteSelected = useCallback(() => {
    if (!isInitializedRef.current || !selectedElement) return;
    
    if (selectedElement.source) {
      // It's an edge - simply remove it
      const updatedEdges = edgesRef.current.filter(e => e.id !== selectedElement.id);
      safeSetEdges(updatedEdges);
    } else {
      // It's a node
      if (selectedElement.type === 'actor' || selectedElement.type === 'participant') {
        // Remove participant and its lifeline
        const updatedNodes = nodesRef.current.filter(n => 
          n.id !== selectedElement.id && n.data?.participantId !== selectedElement.id
        );
        safeSetNodes(updatedNodes);
        
        // Remove any edges connected to the lifeline
        const lifeline = nodesRef.current.find(n => n.data?.participantId === selectedElement.id);
        if (lifeline) {
          const updatedEdges = edgesRef.current.filter(e => 
            e.source !== lifeline.id && e.target !== lifeline.id
          );
          safeSetEdges(updatedEdges);
        }
      }
    }
    
    setSelectedElement(null);
    setIsEditing(false);
  }, [selectedElement, safeSetNodes, safeSetEdges]);
  
  // Add a new message between existing lifelines
  const addMessage = useCallback(() => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    // Need at least two lifelines to add a message
    const lifelines = nodesRef.current.filter(n => n.type === 'lifeline');
    if (lifelines.length < 2) return;
    
    // Get first two lifelines
    const [source, target] = lifelines.slice(0, 2);
    
    // Create a new message edge
    const newEdge = {
      id: `edge-${source.id}-${target.id}-${Date.now()}`,
      source: source.id,
      target: target.id,
      sourceHandle: 'right',
      targetHandle: 'left',
      data: { 
        label: 'New Message',
        type: messageType
      },
      type: 'message',
      animated: false
    };
    
    const updatedEdges = [...edgesRef.current, newEdge];
    safeSetEdges(updatedEdges);
    
    // Select the new message for immediate editing
    setSelectedElement(newEdge);
    setEditingLabel('New Message');
    setIsEditing(true);
  }, [messageType, safeSetEdges]);
  
  // Enable editing mode for the selected element
  const startEditing = useCallback(() => {
    if (!selectedElement) return;
    
    // Set the label based on selected element type
    if (selectedElement.source) {
      // It's an edge
      setEditingLabel(selectedElement.data?.label || '');
    } else {
      // It's a node
      setEditingLabel(selectedElement.data?.label || '');
    }
    
    setIsEditing(true);
  }, [selectedElement]);
  
  // Export to Mermaid code
  const exportMermaid = useCallback(() => {
    const mermaidCode = generateMermaidCode(nodesRef.current, edgesRef.current);
    const blob = new Blob([mermaidCode], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `sequence-diagram-${Date.now()}.mmd`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, []);
  
  return (
    <div className="w-full h-full flex flex-col">
      {/* Toolbar */}
      <div className="p-3 bg-white shadow-sm border-b border-gray-200">
        <div className="flex justify-between items-center">
          <div className="flex items-center space-x-2">
            <button
              onClick={addActor}
              className="px-2 py-1 bg-blue-100 text-blue-700 rounded-md hover:bg-blue-200 flex items-center shadow-sm"
            >
              <User size={14} className="mr-1" />
              Add Actor
            </button>
            <button
              onClick={addSystem}
              className="px-2 py-1 bg-blue-100 text-blue-700 rounded-md hover:bg-blue-200 flex items-center shadow-sm"
            >
              <Server size={14} className="mr-1" />
              Add System
            </button>
            <select
              onChange={(e) => setMessageType(e.target.value)}
              className="px-2 py-1 bg-blue-100 text-blue-700 rounded-md border-none shadow-sm"
            >
              <option value="sync">Sync Message</option>
              <option value="async">Async Message</option>
              <option value="return">Return Message</option>
            </select>
          </div>
          
          {selectedElement && (
            <div className="flex items-center space-x-2">
              <button
                onClick={deleteSelected}
                className="px-2 py-1 bg-red-100 text-red-700 rounded-md hover:bg-red-200 flex items-center"
              >
                <Trash2 size={14} className="mr-1" />
                Delete
              </button>
              <button
                onClick={startEditing}
                className="px-2 py-1 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 flex items-center"
              >
                <Edit size={14} className="mr-1" />
                Rename
              </button>
            </div>
          )}
        </div>
      </div>

      {/* Editing Panel */}
      {isEditing && selectedElement && (
        <div className="p-3 border-b border-gray-200 bg-blue-50">
          <div className="flex items-center">
            <input
              type="text"
              value={editingLabel}
              onChange={(e) => setEditingLabel(e.target.value)}
              className="flex-1 px-2 py-1 border border-gray-300 rounded-md"
              autoFocus
            />
            <button
              onClick={saveLabel}
              className="ml-2 px-3 py-1 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm"
            >
              Save
            </button>
            <button
              onClick={() => setIsEditing(false)}
              className="ml-2 px-3 py-1 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 text-sm"
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Diagram Area */}
      <div className="flex-1 h-full relative" style={{ touchAction: 'none' }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          onNodeClick={onNodeClick}
          onEdgeClick={onEdgeClick}
          nodeTypes={nodeTypes}
          edgeTypes={edgeTypes}
          fitView
          minZoom={0.3}
          maxZoom={2}
          defaultEdgeOptions={{
            type: 'message'
          }}
        >
          <Controls />
          <Background variant="dots" size={1} gap={16} color="#f0f0f0" />
        </ReactFlow>
      </div>
    </div>
  );
};

// Wrap with provider at the export level
const SequenceDiagramWrapped = (props) => (
  <ReactFlowProvider>
    <SequenceDiagram {...props} />
  </ReactFlowProvider>
);

export default SequenceDiagramWrapped;


================================================================================
# FILE: client\components\diagram\SequenceDiagramManager.js
# EXTENSION: .js
================================================================================
// client/components/diagram/SequenceDiagramManager.js
import React, { useState, useCallback, useEffect, useRef } from 'react';
import { ReactFlowProvider } from 'reactflow';
import SequenceDiagram from './SequenceDiagram';

/**
 * SequenceDiagramManager - Component that handles state and coordinates
 * between participants and lifelines in a sequence diagram.
 * 
 * This component addresses the problem of lifelines moving up and down
 * by ensuring they always remain fixed relative to their participants.
 */
const SequenceDiagramManager = ({ initialDiagram, onDiagramUpdate }) => {
  const [participants, setParticipants] = useState([]);
  const [messages, setMessages] = useState([]);
  const [validationRules] = useState({
    maxParticipants: 10,
    requireResponse: true,
    enforceSequentialOrder: true
  });

  const validateDiagram = useCallback(() => {
    // Implement validation logic
    const errors = [];
    if (participants.length > validationRules.maxParticipants) {
      errors.push('Too many participants');
    }
    // Add more validation rules
    return errors;
  }, [participants, validationRules]);

  const updateDiagram = useCallback((newNodes, newEdges) => {
    const errors = validateDiagram();
    if (errors.length === 0) {
      setDiagramState({ nodes: newNodes, edges: newEdges });
      onDiagramUpdate({ nodes: newNodes, edges: newEdges });
    }
    return errors;
  }, [validateDiagram, onDiagramUpdate]);

  // Add more sequence-specific functionality

  // Store the actual node positions for lifelines
  const [diagramState, setDiagramState] = useState(initialDiagram || { nodes: [], edges: [], mermaidCode: '' });
  
  // Reference to the current diagram for callbacks
  const diagramRef = useRef(diagramState);
  useEffect(() => {
    diagramRef.current = diagramState;
  }, [diagramState]);
  
  // Extract participants from diagram nodes on initialization
  useEffect(() => {
    if (initialDiagram?.nodes) {
      const extractedParticipants = initialDiagram.nodes.filter(
        node => node.type === 'actor' || node.type === 'participant'
      );
      setParticipants(extractedParticipants);
    }
  }, [initialDiagram]);
  
  // Handle node position changes, particularly for participants
  const handleNodePositionChange = useCallback((node, newPosition) => {
    // If a participant is moved, update its stored position
    if (node.type === 'actor' || node.type === 'participant') {
      const updatedParticipants = participants.map(p => 
        p.id === node.id 
          ? { ...p, position: newPosition }
          : p
      );
      
      // If this is a new participant, add it
      if (!updatedParticipants.some(p => p.id === node.id)) {
        updatedParticipants.push({ ...node, position: newPosition });
      }
      
      setParticipants(updatedParticipants);
    }
  }, [participants]);
  
  // When a lifeline needs to be updated because its parent moved
  const updateLifelinePosition = useCallback((lifeline, parentPosition) => {
    // Calculate new position based on parent's horizontal position
    // but maintain vertical position to keep messages aligned
    const newPosition = {
      x: parentPosition.x + 25, // Center under parent 
      y: lifeline.position.y     // Keep original vertical position
    };
    
    return newPosition;
  }, []);
  
  // Handle diagram updates
  const handleDiagramUpdate = useCallback((updatedDiagram) => {
    // Store updated diagram
    setDiagramState(updatedDiagram);
    
    // Extract participants
    const updatedParticipants = updatedDiagram.nodes.filter(
      node => node.type === 'actor' || node.type === 'participant'
    );
    setParticipants(updatedParticipants);
    
    // Pass updates to parent component if needed
    if (onDiagramUpdate) {
      onDiagramUpdate(updatedDiagram);
    }
  }, [onDiagramUpdate]);
  
  // Process the diagram to ensure lifelines maintain correct positions
  const processedDiagram = useCallback(() => {
    if (!diagramState?.nodes?.length) return diagramState;
    
    // Create a processed version of nodes with fixed lifeline positions
    const processedNodes = diagramState.nodes.map(node => {
      // If this is a lifeline, find its parent and update position
      if (node.type === 'lifeline' && node.data?.participantId) {
        const parent = participants.find(p => p.id === node.data.participantId);
        if (parent) {
          // Calculate aligned position
          const alignedPosition = {
            x: parent.position.x + 25, // Center under parent
            y: 120 // Fixed vertical offset from top
          };
          
          // Return updated node with fixed position
          return {
            ...node,
            position: alignedPosition,
            // Add parent position as data so child component knows when to update
            data: {
              ...node.data,
              parentX: parent.position.x,
              parentY: parent.position.y
            }
          };
        }
      }
      return node;
    });
    
    return {
      ...diagramState,
      nodes: processedNodes
    };
  }, [diagramState, participants]);
  
  return (
    <ReactFlowProvider>
      <SequenceDiagram
        initialDiagram={processedDiagram()}
        onDiagramUpdate={handleDiagramUpdate}
        onNodePositionChange={handleNodePositionChange}
      />
    </ReactFlowProvider>
  );
};

export default SequenceDiagramManager;


================================================================================
# FILE: client\components\diagram\SystemArchitectureDiagram.js
# EXTENSION: .js
================================================================================
import React, { useCallback, useState, useMemo } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  Panel,
  ReactFlowProvider,
  addEdge,
  applyEdgeChanges,
  applyNodeChanges
} from 'reactflow';
import { Trash2 } from 'lucide-react';
import NodePalette from './NodePalette';
import { NODE_TYPES, getNodeConfig } from './utils/nodePresets';
import CustomNode from './NodeTypes/CustomNode';
import 'reactflow/dist/style.css';

// Define nodeTypes outside of the component
const nodeTypes = {
  // Client/User nodes
  user: CustomNode,
  webapp: CustomNode,
  mobile: CustomNode,
  iot: CustomNode,

  // Networking & Delivery nodes
  loadbalancer: CustomNode,
  cdn: CustomNode,
  gateway: CustomNode,
  proxy: CustomNode,

  // Backend Services nodes
  service: CustomNode,
  serverless: CustomNode,
  queue: CustomNode,
  container: CustomNode,

  // Database & Storage nodes
  database: CustomNode,
  storage: CustomNode,
  cache: CustomNode,
  file: CustomNode,

  // Security & External nodes
  auth: CustomNode,
  firewall: CustomNode,
  security: CustomNode,
  external: CustomNode
};

function SystemArchitectureDiagram({ initialNodes, initialEdges, onNodesChange, onEdgesChange, onConnect }) {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [selectedElements, setSelectedElements] = useState([]);

  const handleAddNode = useCallback((type) => {
    const position = { x: Math.random() * 500, y: Math.random() * 300 };
    const nodeConfig = getNodeConfig(type);
    const newNode = {
      id: `${type}-${Date.now()}`,
      type,
      position,
      data: { 
        label: nodeConfig.label || type,
        type 
      },
    };
    setNodes((nds) => [...nds, newNode]);
  }, []);

  const handleDelete = useCallback(() => {
    if (selectedElements.length > 0) {
      setNodes((nds) => nds.filter((node) => !selectedElements.includes(node)));
      setEdges((eds) => eds.filter((edge) => !selectedElements.includes(edge)));
    }
  }, [selectedElements]);

  return (
    <div className="h-full w-full relative">
      <ReactFlowProvider>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          nodeTypes={nodeTypes}
          onSelectionChange={setSelectedElements}
          deleteKeyCode={['Backspace', 'Delete']}
          fitView
          defaultEdgeOptions={{
            type: 'smoothstep',
            animated: true
          }}
        >
          <Background />
          <Controls />
          <MiniMap />
          <Panel position="top-right" className="bg-white p-2 rounded-lg shadow-lg m-2">
            <button
              onClick={handleDelete}
              className="p-2 hover:bg-red-100 rounded-lg text-red-600 transition-colors"
              disabled={selectedElements.length === 0}
            >
              <Trash2 size={20} />
            </button>
          </Panel>
        </ReactFlow>
        <div className="absolute bottom-0 left-0 right-0 bg-white border-t shadow-lg">
          <NodePalette onNodeAdd={handleAddNode} />
        </div>
      </ReactFlowProvider>
    </div>
  );
}

export default SystemArchitectureDiagram;



================================================================================
# FILE: client\components\diagram\SystemSequenceDiagram.js
# EXTENSION: .js
================================================================================
import React, { useCallback, useEffect, useState } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  Panel,
  useNodesState,
  useEdgesState
} from 'reactflow';
import 'reactflow/dist/style.css';

const SystemSequenceDiagram = ({ 
  initialDiagram,
  onDiagramUpdate 
}) => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);

  useEffect(() => {
    if (initialDiagram?.nodes && initialDiagram?.edges) {
      setNodes(initialDiagram.nodes);
      setEdges(initialDiagram.edges);
    }
  }, [initialDiagram]);

  const onConnect = useCallback((params) => {
    const newEdge = {
      ...params,
      type: 'message',
      animated: false,
      data: { 
        label: 'Request',
        type: 'sync'
      }
    };
    setEdges((eds) => [...eds, newEdge]);
  }, [setEdges]);

  // Update parent component when diagram changes
  useEffect(() => {
    if (onDiagramUpdate) {
      onDiagramUpdate({
        nodes,
        edges,
        mermaidCode: generateMermaidCode(nodes, edges)
      });
    }
  }, [nodes, edges, onDiagramUpdate]);

  const generateMermaidCode = (nodes, edges) => {
    const participants = nodes
      .filter(node => node.type === 'lifeline')
      .map(node => `participant ${node.id} as ${node.data.label}`)
      .join('\n');

    const messages = edges
      .map(edge => {
        const sourceNode = nodes.find(n => n.id === edge.source);
        const targetNode = nodes.find(n => n.id === edge.target);
        if (!sourceNode || !targetNode) return null;
        
        return `${sourceNode.id}->${targetNode.id}: ${edge.data?.label || 'message'}`;
      })
      .filter(Boolean)
      .join('\n');

    return `sequenceDiagram\n${participants}\n${messages}`;
  };

  const nodeTypes = {
    lifeline: ({ data }) => (
      <div className="px-4 py-2 border-2 border-gray-300 rounded bg-white">
        {data.label}
      </div>
    )
  };

  return (
    <div className="h-full w-full">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        fitView
        proOptions={{ hideAttribution: true }}
      >
        <Background />
        <Controls />
        <MiniMap />
        <Panel position="top-right" className="bg-white p-2 rounded shadow">
          <button
            className="px-3 py-1 bg-blue-600 text-white rounded text-sm"
            onClick={() => {
              const newNode = {
                id: `lifeline-${Date.now()}`,
                type: 'lifeline',
                position: { x: 100, y: 100 },
                data: { label: 'New Participant' }
              };
              setNodes(nds => [...nds, newNode]);
            }}
          >
            Add Participant
          </button>
        </Panel>
      </ReactFlow>
    </div>
  );
};

export default SystemSequenceDiagram;


================================================================================
# FILE: client\components\diagram\utils\conversion.js
# EXTENSION: .js
================================================================================
// client/components/diagram/utils/conversion.js
import { MarkerType } from 'reactflow';

// Node shape mappings from Mermaid syntax to node types
const MERMAID_NODE_TYPES = {
  '(': 'cache',           // Circle = Cache
  '[': 'service',         // Rectangle = Service
  '[[': 'service',        // Rectangle = Service variant
  '{': 'loadBalancer',    // Diamond = Load Balancer
  '((': 'database',       // Database
  '>': 'client',          // Flag shape = Client
  '([': 'queue'           // Stadium shape = Queue
};

// Extract node type from Mermaid syntax
const getNodeType = (mermaidNodeDef) => {
  // Check for standard brackets that define node shapes in Mermaid
  for (const [bracket, type] of Object.entries(MERMAID_NODE_TYPES)) {
    if (mermaidNodeDef.includes(`${bracket}`)) {
      return type;
    }
  }
  
  // Check for explicit node type if present in the node id (e.g., database_1234 = database)
  const lowerNodeDef = mermaidNodeDef.toLowerCase();
  if (lowerNodeDef.includes('database')) return 'database';
  if (lowerNodeDef.includes('client')) return 'client';
  if (lowerNodeDef.includes('service')) return 'service';
  if (lowerNodeDef.includes('cache')) return 'cache';
  if (lowerNodeDef.includes('queue')) return 'queue';
  if (lowerNodeDef.includes('loadbalancer') || lowerNodeDef.includes('load_balancer')) return 'loadBalancer';
  
  // Default to service if no type is detected
  return 'service';
};

// Extract node label from Mermaid node definition
const getNodeLabel = (nodeText) => {
  // Check for bracket notation with label: Node["Label"]
  const bracketLabelMatch = nodeText.match(/\["([^"]+)"\]/);
  if (bracketLabelMatch) {
    return bracketLabelMatch[1];
  }
  
  // Check for parenthesis notation with label: Node("Label")
  const parenLabelMatch = nodeText.match(/\("([^"]+)"\)/);
  if (parenLabelMatch) {
    return parenLabelMatch[1];
  }
  
  // Check for standard label: Node[Label]
  const standardLabelMatch = nodeText.match(/\[([^\]]+)\]/);
  if (standardLabelMatch) {
    return standardLabelMatch[1];
  }
  
  // Check for database label: Node[(Label)]
  const dbLabelMatch = nodeText.match(/\[\(([^)]+)\)\]/);
  if (dbLabelMatch) {
    return dbLabelMatch[1];
  }
  
  // Check for cache label: Node((Label))
  const cacheLabelMatch = nodeText.match(/\(\(([^)]+)\)\)/);
  if (cacheLabelMatch) {
    return cacheLabelMatch[1];
  }
  
  // Check for client label: Node>Label]
  const clientLabelMatch = nodeText.match(/>([^]]+)\]/);
  if (clientLabelMatch) {
    return clientLabelMatch[1];
  }
  
  // Check for queue label: Node([Label])
  const queueLabelMatch = nodeText.match(/\(\[([^\]]+)\]\)/);
  if (queueLabelMatch) {
    return queueLabelMatch[1];
  }
  
  // If no specific label format is found, use the node ID as label
  return nodeText;
};

// Convert Mermaid diagram code to ReactFlow nodes and edges
export const mermaidToReactFlow = (mermaidCode) => {
  if (!mermaidCode) {
    return { nodes: [], edges: [] };
  }
  
  const nodes = [];
  const edges = [];
  const nodeMap = {};
  
  try {
    // Split the Mermaid code into lines
    const lines = mermaidCode.split('\n');
    
    // Process each line
    lines.forEach((line, lineIndex) => {
      // Skip empty lines, comments, and the graph definition line
      const trimmedLine = line.trim();
      if (!trimmedLine || trimmedLine.startsWith('%') || trimmedLine.startsWith('graph ')) {
        return;
      }
      
      // Check if the line defines a node
      if (!trimmedLine.includes('-->') && !trimmedLine.includes('---') && !trimmedLine.includes('~~~')) {
        const nodeParts = trimmedLine.split('=');
        const nodeId = nodeParts[0].trim();
        const nodeDef = nodeParts.length > 1 ? nodeParts[1].trim() : nodeId;
        
        // Skip if this is not a node definition
        if (!nodeId || nodeId.includes(' ')) {
          return;
        }
        
        const type = getNodeType(nodeDef);
        
        // Extract the label from the node definition
        let label = getNodeLabel(nodeDef);
        
        // If label was not found using the special formats, try to extract from the Mermaid syntax
        if (label === nodeId && nodeDef !== nodeId) {
          // Extract text between brackets, parentheses or other syntax markers
          const simpleMatch = nodeDef.match(/\[(.*?)\]|\((.*?)\)|{(.*?)}|>(.*?)]/);
          if (simpleMatch) {
            label = simpleMatch.find(match => match && match !== nodeDef) || nodeId;
          }
        }
        
        // Create the ReactFlow node
        const node = {
          id: nodeId,
          type: type,
          position: { 
            x: 150 + (lineIndex * 50), 
            y: 100 + (lineIndex * 50) 
          },
          data: { 
            label: label || nodeId,
            notes: ''
          }
        };
        
        nodes.push(node);
        nodeMap[nodeId] = node;
      }
      // Check if the line defines an edge
      else if (trimmedLine.includes('-->') || trimmedLine.includes('---')) {
        const isDirected = trimmedLine.includes('-->');
        const edgeParts = isDirected 
          ? trimmedLine.split('-->') 
          : trimmedLine.split('---');
        
        if (edgeParts.length >= 2) {
          const sourceId = edgeParts[0].trim();
          const targetId = edgeParts[1].trim();
          
          // Extract label if present
          let label = '';
          const labelMatch = targetId.match(/\|([^|]+)\|/);
          if (labelMatch) {
            label = labelMatch[1].trim();
          }
          
          // Clean up target ID if it contains a label
          const cleanTargetId = targetId.split('|')[0].trim();
          
          // Create the ReactFlow edge
          const edge = {
            id: `edge-${sourceId}-${cleanTargetId}`,
            source: sourceId,
            target: cleanTargetId,
            label: label,
            type: 'smoothstep',
            markerEnd: isDirected ? { type: MarkerType.ArrowClosed } : undefined
          };
          
          edges.push(edge);
        }
      }
    });
    
    // If nodes have position data from a previous ReactFlow state, use it
    // Otherwise, arrange nodes in a simple grid
    if (nodes.length > 0 && !nodes[0].position) {
      const gridSize = Math.ceil(Math.sqrt(nodes.length));
      nodes.forEach((node, index) => {
        const row = Math.floor(index / gridSize);
        const col = index % gridSize;
        node.position = {
          x: 150 + (col * 200),
          y: 100 + (row * 150)
        };
      });
    }
    
    return { nodes, edges };
  } catch (error) {
    console.error('Error converting Mermaid to ReactFlow:', error);
    throw new Error(`Failed to convert Mermaid to ReactFlow: ${error.message}`);
  }
};

// Convert ReactFlow nodes and edges to Mermaid diagram code
export const reactFlowToMermaid = ({ nodes, edges }) => {
  if (!nodes || !edges) {
    return { 
      mermaidCode: 'graph TD\n    A[Empty Diagram]',
      positions: [] 
    };
  }
  
  try {
    let mermaidCode = 'graph TD\n';
    let positionData = [];
    
    // Store positions for each node
    nodes.forEach(node => {
      const label = node.data.label || node.id;
      const type = node.type || 'service';
      
      // Store position data
      positionData.push({
        id: node.id,
        position: node.position,
        mermaidPosition: {
          level: Math.floor(node.position.y / 100),
          column: Math.floor(node.position.x / 150)
        }
      });

      // Generate Mermaid code as before...
      const shape = nodeShapes[type] || nodeShapes.custom;
      mermaidCode += `    ${node.id}${shape.replace('[]', `[${label}]`)}\n`;
    });

    // Add edges with position data
    edges.forEach(edge => {
      const sourceNode = nodes.find(n => n.id === edge.source);
      const targetNode = nodes.find(n => n.id === edge.target);
      
      if (sourceNode && targetNode) {
        positionData.push({
          id: edge.id,
          sourcePosition: sourceNode.position,
          targetPosition: targetNode.position
        });
      }

      // Add edge to Mermaid code
      mermaidCode += `    ${edge.source} -->`;
      if (edge.label) mermaidCode += `|${edge.label}|`;
      mermaidCode += ` ${edge.target}\n`;
    });

    return {
      mermaidCode,
      positions: positionData
    };
  } catch (error) {
    console.error('Error converting to Mermaid:', error);
    throw error;
  }
};


================================================================================
# FILE: client\components\diagram\utils\nodePositioning.js
# EXTENSION: .js
================================================================================
const GRID_SIZE = 50;
const NODE_WIDTH = 150;
const NODE_HEIGHT = 40;

export const getNodePositionForType = (type, bounds, existingNodes) => {
  switch (type) {
    case 'loadBalancer':
      return getLoadBalancerPosition(bounds, existingNodes);
    case 'cache':
      return getCachePosition(bounds, existingNodes);
    case 'apiGateway':
      return getApiGatewayPosition(bounds, existingNodes);
    case 'database':
      return getDatabasePosition(bounds, existingNodes);
    default:
      return getDefaultPosition(bounds, existingNodes);
  }
};

const getLoadBalancerPosition = (bounds, existingNodes) => {
  // Place load balancer before the first service node
  const serviceNode = existingNodes.find(node => node.type === 'service');
  if (serviceNode) {
    return {
      x: serviceNode.position.x - NODE_WIDTH - GRID_SIZE,
      y: serviceNode.position.y
    };
  }
  return getDefaultPosition(bounds, existingNodes);
};

const getCachePosition = (bounds, existingNodes) => {
  // Place cache near the database
  const dbNode = existingNodes.find(node => node.type === 'database');
  if (dbNode) {
    return {
      x: dbNode.position.x,
      y: dbNode.position.y + NODE_HEIGHT + GRID_SIZE
    };
  }
  return getDefaultPosition(bounds, existingNodes);
};

const getApiGatewayPosition = (bounds, existingNodes) => {
  // Place API Gateway at the entry point
  const clientNode = existingNodes.find(node => node.type === 'client');
  if (clientNode) {
    return {
      x: clientNode.position.x + NODE_WIDTH + GRID_SIZE,
      y: clientNode.position.y
    };
  }
  return {
    x: bounds.minX - NODE_WIDTH - GRID_SIZE,
    y: (bounds.minY + bounds.maxY) / 2
  };
};

const getDatabasePosition = (bounds, existingNodes) => {
  // Place database at the end
  return {
    x: bounds.maxX + NODE_WIDTH + GRID_SIZE,
    y: (bounds.minY + bounds.maxY) / 2
  };
};

const getDefaultPosition = (bounds, existingNodes) => {
  // Place new node in a grid pattern
  const gridX = Math.floor((bounds.maxX + GRID_SIZE) / GRID_SIZE) * GRID_SIZE;
  const gridY = Math.floor((bounds.minY + GRID_SIZE) / GRID_SIZE) * GRID_SIZE;
  
  return {
    x: gridX,
    y: gridY
  };
};


================================================================================
# FILE: client\components\diagram\utils\nodePresets.js
# EXTENSION: .js
================================================================================
import { Database, Server, Globe, Archive, Grid, Share2, Gateway } from 'lucide-react';
import React from 'react';

/**
 * Node presets for system design components
 * These are used to create consistent node types for the diagram editor
 */
export const NODE_TYPES = {
  CLIENT: 'client',
  SERVICE: 'service',
  DATABASE: 'database',
  CACHE: 'cache',
  LOAD_BALANCER: 'loadBalancer',
  QUEUE: 'queue',
  GATEWAY: 'gateway'
};

export const getNodeConfig = (type) => {
  const configs = {
    [NODE_TYPES.CLIENT]: {
      icon: <Globe className="w-6 h-6" />,
      color: '#3B82F6', // blue-500
      bgColor: '#EFF6FF', // blue-50
      label: 'Client'
    },
    [NODE_TYPES.SERVICE]: {
      icon: <Server className="w-6 h-6" />,
      color: '#10B981', // green-500
      bgColor: '#ECFDF5', // green-50
      label: 'Service'
    },
    [NODE_TYPES.DATABASE]: {
      icon: <Database className="w-6 h-6" />,
      color: '#8B5CF6', // purple-500
      bgColor: '#F5F3FF', // purple-50
      label: 'Database'
    },
    [NODE_TYPES.CACHE]: {
      icon: <Archive className="w-6 h-6" />,
      color: '#EF4444', // red-500
      bgColor: '#FEF2F2', // red-50
      label: 'Cache'
    },
    [NODE_TYPES.LOAD_BALANCER]: {
      icon: <Grid className="w-6 h-6" />,
      color: '#F97316', // orange-500
      bgColor: '#FFF7ED', // orange-50
      label: 'Load Balancer'
    },
    [NODE_TYPES.QUEUE]: {
      icon: <Share2 className="w-6 h-6" />,
      color: '#6366F1', // indigo-500
      bgColor: '#EEF2FF', // indigo-50
      label: 'Queue'
    },
    [NODE_TYPES.GATEWAY]: {
      icon: <Gateway className="w-6 h-6" />,
      color: '#14B8A6', // teal-500
      bgColor: '#F0FDFA', // teal-50
      label: 'API Gateway'
    }
  };

  return configs[type] || configs[NODE_TYPES.SERVICE];
};

/**
 * Creates a new node with a unique ID based on the node type
 * @param {string} type - The type of node (from NODE_TYPES)
 * @param {object} position - The position {x, y} of the node
 * @param {string} label - The label text for the node
 * @param {string} notes - Optional notes for the node
 * @returns {object} - A React Flow node object
 */
export const createNode = (type, position, label = '', notes = '') => {
  const nodeConfig = getNodeConfig(type);
  
  // Use provided label or default
  const nodeLabel = label || nodeConfig.label || 'Node';
  
  return {
    id: `${type}_${Date.now()}`,
    type,
    position,
    data: {
      label: nodeLabel,
      notes,
      ...nodeConfig
    }
  };
};

/**
 * Creates a connection between two nodes
 * @param {string} sourceId - The ID of the source node
 * @param {string} targetId - The ID of the target node
 * @param {string} label - Optional label for the connection
 * @returns {object} - A React Flow edge object
 */
export const createEdge = (sourceId, targetId, label = '') => {
  return {
    id: `edge-${sourceId}-${targetId}`,
    source: sourceId,
    target: targetId,
    label,
    type: 'smoothstep',
    animated: false,
    style: { strokeWidth: 2 }
  };
};

/**
 * Returns a palette of node type options for the editor UI
 */
export const getNodeTypePalette = () => [
  {
    type: NODE_TYPES.CLIENT,
    label: 'Client',
    description: 'User-facing components like web browsers or mobile apps',
    color: 'blue'
  },
  {
    type: NODE_TYPES.SERVICE,
    label: 'Service',
    description: 'Backend services that process business logic',
    color: 'green'
  },
  {
    type: NODE_TYPES.DATABASE,
    label: 'Database',
    description: 'Data storage systems (SQL, NoSQL, etc.)',
    color: 'purple'
  },
  {
    type: NODE_TYPES.CACHE,
    label: 'Cache',
    description: 'In-memory data stores for quick access (Redis, Memcached)',
    color: 'red'
  },
  {
    type: NODE_TYPES.LOAD_BALANCER,
    label: 'Load Balancer',
    description: 'Distributes network traffic across multiple servers',
    color: 'orange'
  },
  {
    type: NODE_TYPES.QUEUE,
    label: 'Queue',
    description: 'Message queues for asynchronous processing',
    color: 'indigo'
  },
  {
    type: NODE_TYPES.GATEWAY,
    label: 'API Gateway',
    description: 'API Gateway for managing API requests',
    color: 'teal'
  }
  ];


================================================================================
# FILE: client\components\diagram\utils\sequenceDiagramUtils.js
# EXTENSION: .js
================================================================================
// client/components/diagram/utils/sequenceDiagramUtils.js

/**
 * Convert a ReactFlow sequence diagram to Mermaid syntax
 * 
 * @param {Array} nodes - ReactFlow nodes
 * @param {Array} edges - ReactFlow edges
 * @returns {string} - Mermaid code for the sequence diagram
 */
export function generateMermaidCode(nodes, edges) {
    if (!nodes || !edges) return '';
    
    const participants = nodes.filter(node => 
      node.type === 'actor' || node.type === 'participant'
    );
    
    // Start with sequence diagram declaration
    let code = 'sequenceDiagram\n';
    
    // Get all fragments for processing
    const fragments = nodes.filter(node => node.type === 'fragment');
    
    // Get all notes for processing
    const notes = nodes.filter(node => node.type === 'note');
    
    // Declare participants
    participants.forEach(participant => {
      if (participant.type === 'actor') {
        code += `    actor ${participant.data.label.replace(/\s+/g, '_')}\n`;
      } else {
        code += `    participant ${participant.data.label.replace(/\s+/g, '_')}\n`;
      }
    });
    
    // Sort edges by vertical position to maintain proper sequence
    const sortedEdges = [...edges].sort((a, b) => {
      const nodeA = nodes.find(n => n.id === a.source);
      const nodeB = nodes.find(n => n.id === b.source);
      if (!nodeA || !nodeB) return 0;
      
      return nodeA.position.y - nodeB.position.y;
    });
    
    // Process the notes
    notes.forEach(note => {
      // Find the closest participant (simplified approach)
      const closestParticipant = findClosestParticipant(note, participants);
      if (closestParticipant) {
        const participantLabel = closestParticipant.data.label.replace(/\s+/g, '_');
        code += `    Note over ${participantLabel}: ${note.data.label}\n`;
      }
    });
    
    // Add fragments (handle proper nesting in mermaid)
    // Sort fragments by nesting level (outermost first)
    const sortedFragments = [...fragments].sort((a, b) => 
      (a.data.nestingLevel || 0) - (b.data.nestingLevel || 0)
    );
    
    sortedFragments.forEach(fragment => {
      // Find affected participants
      const affectedParticipants = findParticipantsInFragment(fragment, participants);
      if (affectedParticipants.length >= 1) {
        const first = affectedParticipants[0].data.label.replace(/\s+/g, '_');
        const last = affectedParticipants[affectedParticipants.length - 1]?.data.label.replace(/\s+/g, '_') || first;
        
        // Get fragment type and condition
        const fragmentType = fragment.data.fragmentType || 'opt';
        const condition = fragment.data.condition || '';
        
        // Add the fragment start
        if (fragmentType === 'ref') {
          // References are handled differently in Mermaid
          code += `    ref over ${first},${last}: ${fragment.data.label || 'Reference'}\n`;
        } else {
          code += `    ${fragmentType} ${condition}\n`;
          
          // If we have a label for the fragment, add it as a note
          if (fragment.data.label) {
            code += `    Note over ${first},${last}: ${fragment.data.label}\n`;
          }
          
          // Add any internal messages that belong to this fragment
          // This is a simplified approach - a full implementation would track
          // which messages are inside which fragments
          
          // End the fragment
          code += `    end\n`;
        }
      }
    });
    
    // Add messages
    sortedEdges.forEach(edge => {
      if (!edge.data?.label) return;
      
      // Find the source node
      const sourceNode = nodes.find(n => n.id === edge.source);
      // Find the target node
      const targetNode = nodes.find(n => n.id === edge.target);
      
      if (!sourceNode || !targetNode) return;
      
      // Handle different node types
      let sourceLabel, targetLabel;
      
      // Get source label based on node type
      if (sourceNode.type === 'lifeline') {
        // For lifelines, find the parent participant
        const sourceParticipant = nodes.find(n => 
          (n.type === 'actor' || n.type === 'participant') && 
          sourceNode.data?.participantId === n.id
        );
        
        if (sourceParticipant) {
          sourceLabel = sourceParticipant.data.label.replace(/\s+/g, '_');
        } else {
          sourceLabel = 'Unknown';
        }
      } else if (sourceNode.type === 'gate') {
        sourceLabel = '['; // Mermaid syntax for external entities
      } else {
        // For other node types, use their own label
        sourceLabel = sourceNode.data?.label.replace(/\s+/g, '_') || 'Unknown';
      }
      
      // Get target label based on node type
      if (targetNode.type === 'lifeline') {
        // For lifelines, find the parent participant
        const targetParticipant = nodes.find(n => 
          (n.type === 'actor' || n.type === 'participant') && 
          targetNode.data?.participantId === n.id
        );
        
        if (targetParticipant) {
          targetLabel = targetParticipant.data.label.replace(/\s+/g, '_');
        } else {
          targetLabel = 'Unknown';
        }
      } else if (targetNode.type === 'gate') {
        targetLabel = ']'; // Mermaid syntax for external entities
      } else {
        // For other node types, use their own label
        targetLabel = targetNode.data?.label.replace(/\s+/g, '_') || 'Unknown';
      }
      
      const messageLabel = edge.data.label;
      const messageType = edge.data.type || 'sync';
      
      // Map ReactFlow's message types to Mermaid syntax
      switch (messageType) {
        case 'create':
          code += `    ${sourceLabel}->>+${targetLabel}: ${messageLabel}\n`;
          break;
        case 'destroy':
          code += `    ${sourceLabel}-x${targetLabel}: ${messageLabel}\n`;
          break;
        case 'async':
          code += `    ${sourceLabel}-->>+${targetLabel}: ${messageLabel}\n`;
          break;
        case 'return':
        case 'reply':
          code += `    ${sourceLabel}-->>-${targetLabel}: ${messageLabel}\n`;
          break;
        case 'found':
          // For 'found' messages, use a placeholder syntax
          code += `    [->+${targetLabel}: ${messageLabel}\n`;
          break;
        case 'lost':
          // For 'lost' messages, use a placeholder syntax
          code += `    ${sourceLabel}->]: ${messageLabel}\n`;
          break;
        default: // sync
          code += `    ${sourceLabel}->>+${targetLabel}: ${messageLabel}\n`;
      }
    });
    
    return code;
  }
  
  /**
   * Convert Mermaid sequence diagram code to ReactFlow nodes and edges
   * 
   * @param {string} mermaidCode - Mermaid sequence diagram code
   * @returns {Object} - { nodes, edges } for ReactFlow
   */
  export function mermaidToReactFlow(mermaidCode) {
    if (!mermaidCode) return { nodes: [], edges: [] };
    
    const lines = mermaidCode.split('\n');
    const nodes = [];
    const edges = [];
    
    // Map to keep track of participants and their positions
    const participantMap = {};
    
    // Parse participant declarations
    let horizontalPosition = 100;
    
    lines.forEach(line => {
      const trimmedLine = line.trim();
      
      // Skip empty lines and the initial sequenceDiagram declaration
      if (!trimmedLine || trimmedLine === 'sequenceDiagram') return;
      
      // Parse actor declarations
      const actorMatch = trimmedLine.match(/^\s*actor\s+([^\s:]+)/);
      if (actorMatch) {
        const participantId = `actor-${Date.now()}-${Object.keys(participantMap).length}`;
        const lifelineId = `lifeline-${Date.now()}-${Object.keys(participantMap).length}`;
        
        // Clean up the participant name
        const participantName = actorMatch[1].replace(/_/g, ' ');
        
        // Create actor node
        nodes.push({
          id: participantId,
          type: 'actor',
          position: { x: horizontalPosition, y: 50 },
          data: { 
            label: participantName,
            id: participantId
          }
        });
        
        // Create lifeline node
        nodes.push({
          id: lifelineId,
          type: 'lifeline',
          position: { x: horizontalPosition + 25, y: 120 },
          data: { 
            label: '', 
            participantId: participantId,
            height: 400,
            activations: [],
            id: lifelineId
          }
        });
        
        // Track participant for message connections
        participantMap[actorMatch[1]] = {
          id: participantId,
          lifelineId: lifelineId,
          position: horizontalPosition
        };
        
        // Increment position for next participant
        horizontalPosition += 200;
      }
      
      // Parse participant declarations
      const participantMatch = trimmedLine.match(/^\s*participant\s+([^\s:]+)/);
      if (participantMatch) {
        const participantId = `participant-${Date.now()}-${Object.keys(participantMap).length}`;
        const lifelineId = `lifeline-${Date.now()}-${Object.keys(participantMap).length}`;
        
        // Clean up the participant name
        const participantName = participantMatch[1].replace(/_/g, ' ');
        
        // Create participant node
        nodes.push({
          id: participantId,
          type: 'participant',
          position: { x: horizontalPosition, y: 50 },
          data: { 
            label: participantName,
            id: participantId
          }
        });
        
        // Create lifeline node
        nodes.push({
          id: lifelineId,
          type: 'lifeline',
          position: { x: horizontalPosition + 25, y: 120 },
          data: { 
            label: '', 
            participantId: participantId,
            height: 400,
            activations: [],
            id: lifelineId
          }
        });
        
        // Track participant for message connections
        participantMap[participantMatch[1]] = {
          id: participantId,
          lifelineId: lifelineId,
          position: horizontalPosition
        };
        
        // Increment position for next participant
        horizontalPosition += 200;
      }
      
      // Parse note declarations
      const noteMatch = trimmedLine.match(/^\s*Note\s+(?:over|right of|left of)\s+([^:,]+)(?:,\s*([^:]+))?:\s*(.*)/);
      if (noteMatch) {
        const noteId = `note-${Date.now()}-${nodes.length}`;
        const firstParticipant = participantMap[noteMatch[1]];
        const secondParticipant = noteMatch[2] ? participantMap[noteMatch[2]] : null;
        
        if (firstParticipant) {
          // Position note above the first referenced participant
          let noteX = firstParticipant.position;
          
          // If there's a second participant, center between them
          if (secondParticipant) {
            noteX = (firstParticipant.position + secondParticipant.position) / 2;
          }
          
          nodes.push({
            id: noteId,
            type: 'note',
            position: { x: noteX, y: 150 + (edges.length * 30) }, // Position based on number of existing edges
            data: {
              label: noteMatch[3] || 'Note'
            }
          });
        }
      }
      
      // Parse fragment declarations
      const fragmentMatch = trimmedLine.match(/^\s*(alt|opt|loop|par|critical|break|ref)\s*(.*)?/);
      if (fragmentMatch) {
        const fragmentId = `fragment-${Date.now()}-${nodes.length}`;
        const fragmentType = fragmentMatch[1];
        const condition = fragmentMatch[2] || '';
        
        // Since we don't know the exact participants yet, we'll create a fragment
        // spanning the entire diagram by default
        nodes.push({
          id: fragmentId,
          type: 'fragment',
          position: { x: 50, y: 180 + (edges.length * 30) }, // Position based on existing edges
          data: {
            fragmentType,
            condition,
            label: 'Fragment content',
            width: horizontalPosition - 50 + 100, // Span all participants
            height: 120
          }
        });
      }
      
      // Parse message declarations with various syntaxes
      const messageMatch = trimmedLine.match(/^\s*([^-\s]+)\s*(->>|-->|->|-->>|--x|-x)\s*([^:]+):\s*(.*)/);
      if (messageMatch) {
        const source = participantMap[messageMatch[1]];
        const target = participantMap[messageMatch[3]];
        const messageType = messageMatch[2];
        const messageLabel = messageMatch[4];
        
        if (source && target) {
          // Determine message type based on syntax
          let type = 'sync';
          if (messageType === '-->' || messageType === '->') {
            type = 'async';
          } else if (messageType === '--x' || messageType === '-x') {
            type = 'destroy';
          }
          
          // Create message edge
          edges.push({
            id: `edge-${source.lifelineId}-${target.lifelineId}-${edges.length}`,
            source: source.lifelineId,
            target: target.lifelineId,
            sourceHandle: 'right',
            targetHandle: 'left',
            data: {
              label: messageLabel,
              type
            },
            type: 'message',
            animated: false
          });
        }
      }
    });
    
    return { nodes, edges };
  }
  
  /**
   * Find the closest participant to a note node
   * 
   * @param {Object} note - The note node
   * @param {Array} participants - Array of participant nodes
   * @returns {Object|null} - The closest participant node or null if none found
   */
  function findClosestParticipant(note, participants) {
    if (!participants.length) return null;
    
    let closestParticipant = participants[0];
    let minDistance = Number.MAX_VALUE;
    
    participants.forEach(participant => {
      const distance = Math.abs(note.position.x - participant.position.x);
      if (distance < minDistance) {
        minDistance = distance;
        closestParticipant = participant;
      }
    });
    
    return closestParticipant;
  }
  
  /**
   * Find participants within a fragment's area
   * 
   * @param {Object} fragment - The fragment node
   * @param {Array} participants - Array of participant nodes
   * @returns {Array} - Participants that are within the fragment's area
   */
  function findParticipantsInFragment(fragment, participants) {
    const fragmentLeft = fragment.position.x;
    const fragmentRight = fragment.position.x + (fragment.data.width || 300);
    
    return participants.filter(participant => {
      const participantX = participant.position.x;
      return participantX >= fragmentLeft && participantX <= fragmentRight;
    });
  }
  
  /**
   * Normalize a sequence diagram - fix any issues with node positions
   * and ensure lifelines are properly aligned with their parents
   * 
   * @param {Array} nodes - ReactFlow nodes
   * @param {Array} edges - ReactFlow edges
   * @returns {Object} - { nodes, edges } with corrected positions
   */
  export function normalizeSequenceDiagram(nodes, edges) {
    if (!nodes || !edges) return { nodes, edges };
    
    // Find all participant and actor nodes
    const participants = nodes.filter(node => 
      node.type === 'actor' || node.type === 'participant'
    );
    
    // Fix participant positions - they should all be at the same Y position
    const participantY = 50;
    const normalizedNodes = nodes.map(node => {
      // Fix participant positions
      if (node.type === 'actor' || node.type === 'participant') {
        return {
          ...node,
          position: {
            ...node.position,
            y: participantY
          }
        };
      }
      
      // Fix lifeline positions to align with parents
      if (node.type === 'lifeline' && node.data?.participantId) {
        const parent = participants.find(p => p.id === node.data.participantId);
        if (parent) {
          return {
            ...node,
            position: {
              x: parent.position.x + 25, // Center under parent
              y: 120 // Fixed Y position
            },
            data: {
              ...node.data,
              parentX: parent.position.x,
              parentY: parent.position.y
            }
          };
        }
      }
      
      return node;
    });
    
    return { nodes: normalizedNodes, edges };
  }


================================================================================
# FILE: client\components\evaluation\EvaluationSummary.js
# EXTENSION: .js
================================================================================
// client/components/evaluation/EvaluationSummary.js
import React, { useState } from 'react';
import { ChevronDown, ChevronUp, Award, AlertTriangle, Check } from 'lucide-react';

const EvaluationSummary = ({ evaluation, scores }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  
  if (!evaluation) return null;
  
  // Extract overall score
  const overallScore = scores?.overall?.score || 0;
  
  // Determine score color
  const getScoreColor = (score) => {
    if (score >= 90) return 'text-green-600';
    if (score >= 75) return 'text-blue-600';
    if (score >= 60) return 'text-yellow-600';
    return 'text-red-600';
  };
  
  // Extract priority improvements section if present
  const priorityMatch = /Priority Improvements:[^\n]*\n((?:[\d\.\s]+[^\n]+\n)+)/i.exec(evaluation);
  const priorities = priorityMatch ? priorityMatch[1].trim() : '';
  
  // Extract strengths section if present
  const strengthsMatch = /Strengths:[^\n]*\n((?:\*\s+[^\n]+\n)+)/i.exec(evaluation);
  const strengths = strengthsMatch ? strengthsMatch[1].trim() : '';
  
  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <div className="flex justify-between items-center mb-4">
        <div className="flex items-center">
          <Award size={20} className="text-indigo-600 mr-2" />
          <h2 className="text-xl font-bold text-gray-900">Evaluation Summary</h2>
        </div>
        <div className={`text-3xl font-bold ${getScoreColor(overallScore)}`}>
          {overallScore}/100
        </div>
      </div>
      
      {/* Extract and display the summary paragraph */}
      <div className="mb-4">
        <h3 className="text-lg font-medium text-gray-900 mb-2">Overall Assessment</h3>
        <p className="text-gray-700">
          {evaluation.split(/\n\n/)[0].replace(/^.*Overall Score:.*\n/, '').trim()}
        </p>
      </div>
      
      {/* Display strengths if available */}
      {strengths && (
        <div className="mb-4">
          <h3 className="text-lg font-medium text-gray-900 mb-2 flex items-center">
            <Check size={16} className="text-green-500 mr-2" />
            Strengths
          </h3>
          <div className="pl-4 border-l-4 border-green-500">
            {strengths.split('\n').map((item, index) => (
              <p key={index} className="mb-2 text-gray-700">{item}</p>
            ))}
          </div>
        </div>
      )}
      
      {/* Display priority improvements if available */}
      {priorities && (
        <div className="mb-4">
          <h3 className="text-lg font-medium text-gray-900 mb-2 flex items-center">
            <AlertTriangle size={16} className="text-amber-500 mr-2" />
            Priority Improvements
          </h3>
          <div className="pl-4 border-l-4 border-amber-500">
            {priorities.split('\n').map((item, index) => (
              <p key={index} className="mb-2 text-gray-700">{item}</p>
            ))}
          </div>
        </div>
      )}
      
      {/* Expand/collapse full evaluation */}
      <div className="mt-4 pt-4 border-t border-gray-200">
        <button 
          onClick={() => setIsExpanded(!isExpanded)}
          className="flex items-center text-indigo-600 hover:text-indigo-800 font-medium"
        >
          {isExpanded ? (
            <>
              <ChevronUp size={18} className="mr-1" />
              Hide Full Evaluation
            </>
          ) : (
            <>
              <ChevronDown size={18} className="mr-1" />
              View Full Evaluation
            </>
          )}
        </button>
        
        {isExpanded && (
          <div className="mt-4 p-4 bg-gray-50 rounded-md">
            <pre className="whitespace-pre-wrap text-sm text-gray-700">
              {evaluation}
            </pre>
          </div>
        )}
      </div>
      
      {/* Dimension scores if expanded */}
      {isExpanded && scores && (
        <div className="mt-4 pt-4 border-t border-gray-200">
          <h3 className="text-lg font-medium text-gray-900 mb-2">Dimension Scores</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {Object.entries(scores)
              .filter(([key]) => key !== 'overall')
              .map(([dimension, { score, maxScore }]) => (
                <div key={dimension} className="bg-gray-100 p-3 rounded-lg">
                  <div className="flex justify-between items-center mb-2">
                    <span className="font-medium text-gray-800">{dimension}</span>
                    <span className={`font-bold ${getScoreColor(score)}`}>{score}/{maxScore}</span>
                  </div>
                  <div className="w-full bg-gray-300 rounded-full h-2">
                    <div 
                      className={`h-2 rounded-full ${getScoreColor(score).replace('text-', 'bg-')}`}
                      style={{ width: `${(score / maxScore) * 100}%` }}
                    ></div>
                  </div>
                </div>
              ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default EvaluationSummary;


================================================================================
# FILE: client\components\ExperienceLevelSelector.js
# EXTENSION: .js
================================================================================
// components/ExperienceLevelSelector.js
import React from 'react';
import { User } from 'lucide-react';

const ExperienceLevelSelector = ({ currentLevel, onLevelChange }) => {
  return (
    <div className="flex items-center">
      <User size={16} className="text-gray-500 mr-2" />
      <select 
        value={currentLevel} 
        onChange={(e) => onLevelChange(e.target.value)}
        className="text-sm border-none bg-transparent focus:ring-0 text-gray-600 p-0"
      >
        <option value="junior">Junior</option>
        <option value="mid-level">Mid-Level</option>
        <option value="senior">Senior</option>
        <option value="staff+">Staff+</option>
      </select>
    </div>
  );
};

export default ExperienceLevelSelector;


================================================================================
# FILE: client\components\MermaidToolbar.js
# EXTENSION: .js
================================================================================
// client/components/MermaidToolbar.js
import React from 'react';
import { Database, Server, Globe, Archive, Grid, Box, Share2, ArrowRight } from 'lucide-react';

const ComponentButton = ({ icon, label, snippet, onInsert }) => (
  <button
    onClick={() => onInsert(snippet)}
    className="flex flex-col items-center p-2 bg-white border border-gray-200 rounded shadow-sm hover:bg-blue-50 hover:border-blue-200 transition-colors w-20 h-20"
  >
    {icon}
    <span className="text-xs mt-2 text-center">{label}</span>
  </button>
);

const MermaidToolbar = ({ onInsert }) => {
  const components = [
    {
      icon: <Globe className="h-5 w-5 text-blue-600" />,
      label: "Client",
      snippet: "Client[Client] --> API"
    },
    {
      icon: <Server className="h-5 w-5 text-green-600" />,
      label: "Server",
      snippet: "Server[API Server]"
    },
    {
      icon: <Database className="h-5 w-5 text-purple-600" />,
      label: "Database",
      snippet: "DB[(Database)]"
    },
    {
      icon: <Archive className="h-5 w-5 text-red-600" />,
      label: "Cache",
      snippet: "Cache[(Cache)]"
    },
    {
      icon: <Grid className="h-5 w-5 text-orange-600" />,
      label: "Load Balancer",
      snippet: "LB{Load Balancer}"
    },
    {
      icon: <Box className="h-5 w-5 text-teal-600" />,
      label: "Microservice",
      snippet: "Service[Microservice]"
    },
    {
      icon: <Share2 className="h-5 w-5 text-indigo-600" />,
      label: "Queue",
      snippet: "Queue([Message Queue])"
    },
    {
      icon: <ArrowRight className="h-5 w-5 text-gray-600" />,
      label: "Connection",
      snippet: "A --> B"
    }
  ];

  return (
    <div className="flex flex-wrap gap-2">
      {components.map((component, index) => (
        <ComponentButton
          key={index}
          icon={component.icon}
          label={component.label}
          snippet={component.snippet}
          onInsert={onInsert}
        />
      ))}
    </div>
  );
};

export default MermaidToolbar;


================================================================================
# FILE: client\components\MetricCard.js
# EXTENSION: .js
================================================================================
import React from 'react';

const MetricCard = ({ title, value, icon, iconBgColor, progress, subtext }) => {
  return (
    <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
      <div className="flex items-center gap-3 mb-1">
        <div className={`h-10 w-10 rounded-lg ${iconBgColor} flex items-center justify-center`}>
          {icon}
        </div>
        <div>
          <h3 className="text-sm text-slate-500 font-medium">{title}</h3>
          <p className="text-2xl font-bold text-slate-900">{value}</p>
        </div>
      </div>
      
      {progress !== undefined && (
        <div className="w-full h-2 bg-slate-100 rounded-full mt-4">
          <div 
            className="h-2 bg-indigo-500 rounded-full" 
            style={{ width: `${progress}%` }}
          ></div>
        </div>
      )}
      
      {subtext && (
        <div className="text-sm text-slate-500 mt-4">
          {subtext}
        </div>
      )}
    </div>
  );
};

export default MetricCard;


================================================================================
# FILE: client\components\RealTimeFeedback.js
# EXTENSION: .js
================================================================================
import React, { useEffect, useState } from 'react';
import { AlertCircle, CheckCircle, AlertTriangle } from 'react-feather';

const RealTimeFeedback = ({ section, content, onFeedback }) => {
  const [feedback, setFeedback] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const debounceTimeout = setTimeout(async () => {
      if (!content) return;
      
      setLoading(true);
      try {
        const response = await fetch('/api/evaluate/section', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ section, content })
        });
        
        const data = await response.json();
        setFeedback(data);
        onFeedback?.(data);
      } catch (error) {
        console.error('Feedback error:', error);
      } finally {
        setLoading(false);
      }
    }, 1000);

    return () => clearTimeout(debounceTimeout);
  }, [content, section]);

  if (!feedback && !loading) return null;

  return (
    <div className="fixed bottom-4 right-4 max-w-md bg-white shadow-lg rounded-lg p-4">
      <div className="flex items-center gap-2 mb-2">
        {loading ? (
          <AlertTriangle className="text-yellow-500" />
        ) : feedback?.score > 80 ? (
          <CheckCircle className="text-green-500" />
        ) : (
          <AlertCircle className="text-red-500" />
        )}
        <h3 className="font-semibold">
          {loading ? 'Analyzing...' : 'Feedback'}
        </h3>
      </div>
      
      {!loading && feedback && (
        <>
          <div className="mb-2">
            <div className="flex justify-between">
              <span>Quality Score</span>
              <span className="font-bold">{feedback.score}%</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div 
                className="bg-blue-600 rounded-full h-2" 
                style={{ width: `${feedback.score}%` }}
              />
            </div>
          </div>

          {feedback.suggestions?.length > 0 && (
            <div className="mt-2">
              <h4 className="font-medium mb-1">Suggestions:</h4>
              <ul className="text-sm text-gray-600">
                {feedback.suggestions.slice(0, 3).map((suggestion, i) => (
                  <li key={i} className="flex items-center gap-1">
                    <span></span> {suggestion}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </>
      )}
    </div>
  );
};

export default RealTimeFeedback;


================================================================================
# FILE: client\components\Sidebar.js
# EXTENSION: .js
================================================================================
import React from 'react';
import { useRouter } from 'next/router';
import { Book, BarChart2, Award, Layout, Clock, Activity, School } from 'lucide-react';
import { useAuth } from '../contexts/AuthContext';

const Sidebar = ({ activeTab }) => {
  const router = useRouter();
  const { user, logout } = useAuth();

  return (
    <div className="w-64 bg-slate-900 text-white p-4 flex flex-col h-full">
      <div className="flex items-center gap-3 mb-10">
        <div className="h-8 w-8 rounded-md bg-indigo-500 flex items-center justify-center">
          <Layout className="h-5 w-5 text-white" />
        </div>
        <h1 className="text-xl font-bold">System Design Coach</h1>
      </div>
      
      <div className="space-y-1">
        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'home' ? 'bg-indigo-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/dashboard')}
        >
          <div className="flex items-center">
            <Layout className="mr-3 h-4 w-4" />
            Dashboard
          </div>
        </button>
        
        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'problems' ? 'bg-indigo-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/problems')}
        >
          <div className="flex items-center">
            <Book className="mr-3 h-4 w-4" />
            Design Problems
          </div>
        </button>
        
        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'progress' ? 'bg-indigo-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/progress')}
        >
          <div className="flex items-center">
            <BarChart2 className="mr-3 h-4 w-4" />
            My Progress
          </div>
        </button>
        
        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'certs' ? 'bg-indigo-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/certifications')}
        >
          <div className="flex items-center">
            <Award className="mr-3 h-4 w-4" />
            Certifications
          </div>
        </button>

        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'coaching' ? 'bg-green-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/coaching')}
        >
          <div className="flex items-center">
            <School className="mr-3 h-4 w-4" />
            <span>Coaching Sessions</span>
          </div>
        </button>

        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'interviews' ? 'bg-indigo-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/interviews')}
        >
          <div className="flex items-center">
            <Activity className="mr-3 h-4 w-4" />
            <span>Practice Interviews</span>
          </div>
        </button>
        
        
      </div>
      
      <div className="mt-auto">
        <div className="bg-slate-800 rounded-lg p-4 text-sm">
          <div className="flex items-center justify-between mb-3">
            <span className="font-medium">Pro Plan</span>
            <span className="bg-emerald-600 text-white px-2 py-1 rounded text-xs">Active</span>
          </div>
          <div className="flex items-center gap-2 text-slate-300 mb-3">
            <Clock className="h-4 w-4" />
            <span>Unlimited access</span>
          </div>
          <button 
            className="bg-slate-700 hover:bg-slate-600 text-sm text-white w-full py-2 rounded"
            onClick={logout}
          >
            Sign Out
          </button>
        </div>
      </div>
    </div>
  );
};

export default Sidebar;


================================================================================
# FILE: client\components\SimpleFlow.js
# EXTENSION: .js
================================================================================
import React from 'react';
import ReactFlow, { ReactFlowProvider, Background, Controls } from 'reactflow';
import 'reactflow/dist/style.css';

const initialNodes = [
  { id: '1', position: { x: 100, y: 100 }, data: { label: 'Hello' } },
  { id: '2', position: { x: 200, y: 200 }, data: { label: 'World' } }
];

const initialEdges = [
  { id: 'e1-2', source: '1', target: '2' }
];

function Flow() {
  // Debug logging
  console.log("SimpleFlow rendering with:", initialNodes, initialEdges);
  
  return (
    <div style={{width: '100%', height: '100%', position: 'relative'}}>
      <ReactFlow 
        nodes={initialNodes}
        edges={initialEdges}
        fitView
      >
        <Controls />
        <Background />
      </ReactFlow>
    </div>
  );
}

export default function SimpleFlowWithProvider() {
  return (
    <ReactFlowProvider>
      <Flow />
    </ReactFlowProvider>
  );
}


================================================================================
# FILE: client\components\SystemDesignDiagram.tsx
# EXTENSION: .tsx
================================================================================
import React, { useCallback, useState, useEffect } from 'react';
import ReactFlow, {
  Controls,
  Background,
  addEdge,
  Connection,
  NodeTypes,
  applyNodeChanges,
  applyEdgeChanges,
  Node,
  Edge,
  NodeChange,
  EdgeChange
} from 'reactflow';
import 'reactflow/dist/style.css';
import mermaid from 'mermaid';
import { Server, Database, CloudLightning, Router, Lock } from 'lucide-react';

// Custom Node Types with Detailed Rendering
const nodeTypes: NodeTypes = {
  infrastructureNode: ({ data }) => (
    <div className="bg-blue-100 p-2 rounded border border-blue-300 flex items-center">
      {data.icon}
      <span className="ml-2">{data.label}</span>
    </div>
  ),
  computationNode: ({ data }) => (
    <div className="bg-green-100 p-2 rounded border border-green-300 flex items-center">
      {data.icon}
      <span className="ml-2">{data.label}</span>
    </div>
  ),
  dataNode: ({ data }) => (
    <div className="bg-purple-100 p-2 rounded border border-purple-300 flex items-center">
      {data.icon}
      <span className="ml-2">{data.label}</span>
    </div>
  ),
};

// Sidebar Component for Adding System Design Components
const SystemArchitectureSidebar: React.FC<{ onAddNode: (type: string, label: string) => void }> = ({ onAddNode }) => {
  const componentTypes = [
    { 
      type: 'infrastructureNode', 
      label: 'Load Balancer', 
      icon: <Router className="h-5 w-5 text-blue-600" />,
      category: 'Infrastructure'
    },
    { 
      type: 'computationNode', 
      label: 'Web Server', 
      icon: <Server className="h-5 w-5 text-green-600" />,
      category: 'Computation'
    },
    { 
      type: 'dataNode', 
      label: 'Database', 
      icon: <Database className="h-5 w-5 text-purple-600" />,
      category: 'Data'
    },
    { 
      type: 'infrastructureNode', 
      label: 'API Gateway', 
      icon: <CloudLightning className="h-5 w-5 text-blue-600" />,
      category: 'Infrastructure'
    },
    { 
      type: 'infrastructureNode', 
      label: 'Authentication', 
      icon: <Lock className="h-5 w-5 text-blue-600" />,
      category: 'Infrastructure'
    }
  ];

  return (
    <div className="w-64 p-4 bg-gray-50 border-r">
      <h2 className="text-lg font-bold mb-4">Components</h2>
      {componentTypes.map((component, index) => (
        <button
          key={index}
          onClick={() => onAddNode(component.type, component.label)}
          className="flex items-center w-full p-2 hover:bg-gray-100 rounded mb-2"
        >
          {component.icon}
          <span className="ml-2 text-sm">{component.label}</span>
          <span className="ml-auto text-xs text-gray-500">{component.category}</span>
        </button>
      ))}
    </div>
  );
};

const SystemArchitectureDiagram: React.FC = () => {
  // State management for nodes and edges using regular useState
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);

  // Handler for node changes
  const onNodesChange = useCallback(
    (changes: NodeChange[]) => {
      setNodes(nds => applyNodeChanges(changes, nds));
    },
    []
  );

  // Handler for edge changes
  const onEdgesChange = useCallback(
    (changes: EdgeChange[]) => {
      setEdges(eds => applyEdgeChanges(changes, eds));
    },
    []
  );

  // Handle connections between nodes
  const onConnect = useCallback(
    (connection: Connection) => {
      const newEdge = { 
        ...connection, 
        id: `edge-${connection.source}-${connection.target}`,
        type: 'default',
        animated: true 
      };

      setEdges((eds) => addEdge(newEdge, eds));
    },
    []
  );

  // Add a new node to the diagram
  const handleAddNode = useCallback((type: string, label: string) => {
    const newNode = {
      id: `node-${Date.now()}`,
      type,
      data: { 
        label, 
        icon: type === 'infrastructureNode' ? <Router className="h-5 w-5 text-blue-600" /> :
               type === 'computationNode' ? <Server className="h-5 w-5 text-green-600" /> :
               <Database className="h-5 w-5 text-purple-600" />
      },
      position: { 
        x: Math.random() * 500, 
        y: Math.random() * 500 
      },
    };

    setNodes((prevNodes) => [...prevNodes, newNode]);
  }, []);

  // Generate Mermaid code for the current diagram
  const generateMermaidCode = useCallback(() => {
    const nodeLines = nodes.map(
      (node) => `${node.id}[${node.data.label}]`
    );
    const edgeLines = edges.map(
      (edge) => `${edge.source} --> ${edge.target}`
    );

    return `graph TD\n${[...nodeLines, ...edgeLines].join('\n')}`;
  }, [nodes, edges]);

  // Render Mermaid diagram
  const renderMermaidDiagram = useCallback(async () => {
    try {
      mermaid.initialize({ 
        startOnLoad: false,
        theme: 'default'
      });

      const { svg } = await mermaid.render('mermaid-diagram', generateMermaidCode());
      return svg;
    } catch (error) {
      console.error('Mermaid rendering error', error);
      return '';
    }
  }, [generateMermaidCode]);

  // Render the system design diagram
  return (
    <div className="flex h-screen">
      <SystemArchitectureSidebar onAddNode={handleAddNode} />
      <div className="flex-1">
        <div className="p-2 bg-gray-50 border-b">
          <h2 className="text-lg font-semibold">System Architecture Diagram</h2>
        </div>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          nodeTypes={nodeTypes}
          fitView
        >
          <Controls />
          <Background color="#f0f0f0" />
        </ReactFlow>
      </div>
    </div>
  );
};

export default SystemDesignDiagram;


================================================================================
# FILE: client\components\TestConnection.js
# EXTENSION: .js
================================================================================
const testBackend = async () => {
  try {
    const response = await fetch('/api/auth/me');
    const data = await response.json();
    console.log('Backend response:', data);
  } catch (error) {
    console.error('Error connecting to backend:', error);
  }
};


================================================================================
# FILE: client\components\Workbook.js
# EXTENSION: .js
================================================================================
import RealTimeFeedback from './RealTimeFeedback';
import { useState, useEffect } from 'react';
import { autoSaveWorkbook } from '../utils/workbookStorage';

const Workbook = ({ sessionId, userId, initialData }) => {
  const [currentSection, setCurrentSection] = useState('requirements');
  const [workbookData, setWorkbookData] = useState(initialData);
  const [evaluations, setEvaluations] = useState({});

  const handleSectionChange = async (section, content) => {
    const newData = {
      ...workbookData,
      [section]: content
    };
    setWorkbookData(newData);

    try {
      await autoSaveWorkbook(sessionId, newData);
    } catch (error) {
      console.error('Save error:', error);
    }
  };

  const handleFeedback = (section, feedback) => {
    setEvaluations(prev => ({
      ...prev,
      [section]: feedback
    }));
  };

  return (
    <div className="flex h-screen">
      <div className="flex-1 p-4">
        <WorkbookSection
          section={currentSection}
          content={workbookData[currentSection]}
          onChange={(content) => handleSectionChange(currentSection, content)}
        />
        
        <RealTimeFeedback
          section={currentSection}
          content={workbookData[currentSection]}
          onFeedback={(feedback) => handleFeedback(currentSection, feedback)}
        />
      </div>

      <div className="w-64 bg-gray-100 p-4">
        <ProgressSidebar
          evaluations={evaluations}
          currentSection={currentSection}
          onSectionChange={setCurrentSection}
        />
      </div>
    </div>
  );
};

export default Workbook;



================================================================================
# FILE: client\config\aiConfig.js
# EXTENSION: .js
================================================================================
export const AI_CONFIG = {
  provider: 'claude',
  model: 'claude-3-7-sonnet-latest',
  maxTokens: 1000,
  temperature: 0.7,
  defaultSystemPrompt: "You are an expert system design coach. Help guide the developer through architectural decisions and trade-offs."
};


================================================================================
# FILE: client\contexts\AuthContext.js
# EXTENSION: .js
================================================================================
// client/contexts/AuthContext.js
import React, { createContext, useState, useContext, useEffect } from 'react';
import { useRouter } from 'next/router';
import Cookies from 'js-cookie';
import { loginUser, registerUser, getMe } from '../utils/api';

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const router = useRouter();
  
  // Check if user is authenticated on mount
  useEffect(() => {
    const initAuth = async () => {
      const token = Cookies.get('auth_token');
      console.log('Auth Check:', {
        hasToken: !!token,
        tokenValue: token ? `${token.substring(0, 20)}...` : null,
        currentPath: router.pathname
      });
      
      if (token) {
        try {
          const userData = await getMe();
          console.log('Auth Success:', {
            user: userData.user,
            authenticated: true
          });
          setUser(userData.user);
          setIsAuthenticated(true);
        } catch (error) {
          console.error('Auth Error:', {
            error: error.message,
            status: error.response?.status,
            data: error.response?.data
          });
          Cookies.remove('auth_token');
          setIsAuthenticated(false);
          setUser(null);
          
          // Redirect to login if on protected route
          if (router.pathname !== '/auth/login' && router.pathname !== '/auth/register') {
            router.push('/auth/login');
          }
        }
      } else {
        console.log('No auth token found');
        setIsAuthenticated(false);
        setUser(null);
        
        // Redirect to login if on protected route
        if (router.pathname !== '/auth/login' && router.pathname !== '/auth/register') {
          router.push('/auth/login');
        }
      }
      
      setIsLoading(false);
    };
    
    initAuth();
  }, [router]);
  
  // Login function
  const login = async (email, password) => {
    try {
      console.log('Login attempt:', { email });
      const response = await loginUser(email, password);
      console.log('Login API Response:', {
        success: response.success,
        hasToken: !!response.token,
        hasUser: !!response.user
      });
      
      if (response.success && response.token) {
        // Store token in cookie
        Cookies.set('auth_token', response.token, {
          expires: 7,
          path: '/',
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax'
        });
        
        console.log('Cookie check after setting:', {
          hasAuthToken: !!Cookies.get('auth_token')
        });
        
        setUser(response.user);
        setIsAuthenticated(true);
        
        // Redirect to dashboard or home
        router.push('/coaching');
        return { success: true };
      } else {
        console.error('Login failed - Invalid response:', response);
        return {
          success: false,
          error: response.error || 'Invalid login response'
        };
      }
    } catch (error) {
      console.error('Login error:', {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status
      });
      return {
        success: false,
        error: error.response?.data?.error || 'Login failed'
      };
    }
  };
  
  // Register function
  const register = async (name, email, password, experience) => {
    try {
      const response = await registerUser(name, email, password, experience);
      
      if (response.success && response.token) {
        // Store token in cookie
        Cookies.set('auth_token', response.token, {
          expires: 7,
          path: '/',
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'lax'
        });
        
        setUser(response.user);
        setIsAuthenticated(true);
        
        // Redirect to dashboard or home
        router.push('/coaching');
        return { success: true };
      } else {
        return {
          success: false,
          error: response.error || 'Registration failed'
        };
      }
    } catch (error) {
      console.error('Register error:', error);
      return {
        success: false,
        error: error.response?.data?.error || 'Registration failed'
      };
    }
  };
  
  // Logout function
  const logout = () => {
    Cookies.remove('auth_token', { path: '/' });
    setUser(null);
    setIsAuthenticated(false);
    router.push('/auth/login');
  };
  
  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        isAuthenticated,
        login,
        register,
        logout,
        setUser
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);

export default AuthContext;


================================================================================
# FILE: client\data\persona\coachPersona.js
# EXTENSION: .js
================================================================================
export const COACH_PERSONA = {
  role: "System Design Coach",
  name: "Coach Calvin",
  expertise: ["System Architecture", "Design Patterns", "Scalability", "Performance"],
  style: "supportive and analytical",
  basePrompt: `You are Coach Calvin, an expert system design coach with deep expertise in software architecture, design patterns, and scalability. Your approach is:
- Focus on practical, real-world solutions
- Guide through questions rather than direct answers
- Emphasize architectural principles and best practices
- Help identify trade-offs in design decisions
- Maintain a supportive and encouraging tone

You're currently helping a developer improve their system design skills. Keep responses focused and technical.`
};


================================================================================
# FILE: client\hooks\useSession.js
# EXTENSION: .js
================================================================================
"use client";

import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { getCoachingSession } from '../utils/api';

export function useSession(sessionId) {
  const [session, setSession] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const router = useRouter();

  useEffect(() => {
    if (!sessionId) {
      setLoading(false);
      return;
    }

    async function fetchSession() {
      try {
        setLoading(true);
        const data = await getCoachingSession(sessionId);
        setSession(data);
        setError(null);
      } catch (err) {
        console.error(`Error fetching session ${sessionId}:`, err);
        setError("Failed to load session");
        if (err.response?.status === 401) {
          router.push('/auth/login');
        }
      } finally {
        setLoading(false);
      }
    }

    fetchSession();
  }, [sessionId, router]);

  const updateSession = (newData) => {
    setSession(prev => ({
      ...prev,
      ...newData
    }));
  };

  return {
    session,
    loading,
    error,
    updateSession
  };
}


================================================================================
# FILE: client\next.config.js
# EXTENSION: .js
================================================================================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: '/api/:path*',
      },
    ];
  },
}

module.exports = nextConfig;



================================================================================
# FILE: client\pages\_app.js
# EXTENSION: .js
================================================================================
"use client";

import * as React from 'react';
import Head from 'next/head';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { CacheProvider } from '@emotion/react';
import theme from '../styles/theme';
import createEmotionCache from '../utils/createEmotionCache';
import { ToastContainer } from 'react-toastify';
import { AuthProvider } from '../contexts/AuthContext';
import 'react-toastify/dist/ReactToastify.css';
import '../styles/globals.css';

// Client-side cache, shared for the whole session
const clientSideEmotionCache = createEmotionCache();

function MyApp(props) {
  const { Component, emotionCache = clientSideEmotionCache, pageProps } = props;

  return (
    <CacheProvider value={emotionCache}>
      <Head>
        <title>System Design Coach</title>
        <meta name="viewport" content="initial-scale=1, width=device-width" />
      </Head>
      <AuthProvider>
        <ThemeProvider theme={theme}>
          <CssBaseline />
          <Component {...pageProps} />
          <ToastContainer />
        </ThemeProvider>
      </AuthProvider>
    </CacheProvider>
  );
}

export default MyApp;


================================================================================
# FILE: client\pages\api\auth\login.js
# EXTENSION: .js
================================================================================
export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ 
      success: false, 
      error: 'Method not allowed' 
    });
  }

  try {
    const { email, password } = req.body;

    // Basic validation
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        error: 'Email and password are required'
      });
    }

    // For development, create a mock successful response
    const mockUser = {
      id: 'mock-user-1',
      email: email,
      name: 'Test User',
      experience: 'intermediate'
    };

    const mockToken = `mock-token-${Date.now()}`;

    // Return success response
    return res.status(200).json({
      success: true,
      token: mockToken,
      user: mockUser
    });

  } catch (error) {
    console.error('Login handler error:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
}


================================================================================
# FILE: client\pages\api\auth\me.js
# EXTENSION: .js
================================================================================
export default async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ 
      success: false, 
      error: 'Method not allowed' 
    });
  }

  try {
    // Get the authorization header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        error: 'Unauthorized'
      });
    }

    const token = authHeader.split(' ')[1];

    // For development, return mock user data if token exists
    if (token) {
      return res.status(200).json({
        success: true,
        user: {
          id: 'mock-user-1',
          email: 'vyas.sathya@gmail.com',
          name: 'Test User',
          experience: 'intermediate'
        }
      });
    }

    return res.status(401).json({
      success: false,
      error: 'Invalid token'
    });

  } catch (error) {
    console.error('Auth me handler error:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
}


================================================================================
# FILE: client\pages\api\coaching\message.js
# EXTENSION: .js
================================================================================
import axios from 'axios';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  try {
    const { messages, options } = req.body;
    
    const response = await axios.post(`${process.env.NEXT_PUBLIC_API_URL}/coaching/message`, {
      messages,
      options
    });

    res.status(200).json(response.data);
  } catch (error) {
    console.error('Server AI request failed:', error.message);
    res.status(500).json({ 
      message: 'Failed to process message',
      error: error.message 
    });
  }
}


================================================================================
# FILE: client\pages\api\mock\coaching\[id].js
# EXTENSION: .js
================================================================================
export default function handler(req, res) {
    const { id } = req.query;
    
    res.status(200).json({
      id,
      problem: { 
        id: 'mock-problem',
        title: 'System Design Coaching Session'
      },
      conversation: [{
        role: 'assistant',
        content: "Welcome to your system design coaching session! I'm here to help you work through design challenges and improve your system architecture skills. What would you like to focus on today?",
        timestamp: new Date().toISOString()
      }],
      currentStage: 'introduction',
      status: 'in_progress',
      startedAt: new Date().toISOString()
    });
  }


================================================================================
# FILE: client\pages\api\mock\coaching\message.js
# EXTENSION: .js
================================================================================
import { Anthropic } from '@anthropic-ai/sdk';
import { AI_CONFIG } from '../../../../config/aiConfig';
import { COACH_PERSONA } from '../../../../data/persona/coachPersona';
import { problems } from '../../../../data/persona/coachPersona';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }
  
  const { messages, options } = req.body;
  
  try {
    // Use the existing coach persona configuration
    const systemPrompt = options?.contextInfo?.designContext 
      ? `${COACH_PERSONA.systemPrompt}\n\nContext: ${options.contextInfo.designContext}`
      : COACH_PERSONA.systemPrompt;

    const response = await anthropic.messages.create({
      model: AI_CONFIG.model,
      max_tokens: AI_CONFIG.maxTokens,
      messages: messages,
      system: systemPrompt,
      temperature: AI_CONFIG.temperature,
    });

    return res.status(200).json({
      message: {
        role: 'assistant',
        content: response.content[0].text,
        timestamp: new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('Error processing message:', error);
    return res.status(500).json({ 
      error: 'Failed to process message',
      details: error.message 
    });
  }
}

export const config = {
  api: {
    bodyParser: true,
  },
}



================================================================================
# FILE: client\pages\api\mock\coaching\services\aiService.js
# EXTENSION: .js
================================================================================
export class AIService {
  constructor(config) {
    this.provider = config?.provider || 'claude';
    this.baseUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000';
  }

  async sendMessage(messages, options = {}) {
    try {
      const { sessionId } = options;
      // Use the full URL with baseUrl
      const response = await fetch(`${this.baseUrl}/api/ai/message`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          messages,
          sessionId,
          context: options.context,
          provider: this.provider
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      return data.response;
    } catch (error) {
      console.error('AI Service Error:', error);
      throw error;
    }
  }
}

export const config = {
  provider: 'claude'
};

export const aiService = new AIService(config);


================================================================================
# FILE: client\pages\api\mock\coaching\sessions.js
# EXTENSION: .js
================================================================================
export default function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  const { problemId } = req.body;

  const session = {
    _id: `session-${Date.now()}`,
    problemId: problemId,
    status: 'active',
    startedAt: new Date().toISOString(),
    problem: {
      id: problemId,
      title: 'System Design Coaching Session'
    }
  };

  res.status(200).json({ session });
}


================================================================================
# FILE: client\pages\api\mock\coaching\sessions\[id].js
# EXTENSION: .js
================================================================================
export default function handler(req, res) {
  const { id } = req.query;
  
  if (req.method === 'GET') {
    res.status(200).json({
      success: true,
      session: {
        _id: id,
        status: 'active',
        startedAt: new Date().toISOString(),
        problem: {
          id: 'url-shortener',
          title: 'Design a URL Shortening Service'
        },
        conversation: [{
          role: 'assistant',
          content: "Welcome to your system design coaching session! I'm here to help you work through design challenges and improve your system architecture skills. What would you like to focus on today?",
          timestamp: new Date().toISOString()
        }]
      }
    });
  } else {
    res.status(405).json({ message: 'Method not allowed' });
  }
}


================================================================================
# FILE: client\pages\api\mock\coaching\sessions\[id]\message.js
# EXTENSION: .js
================================================================================
import { Anthropic } from '@anthropic-ai/sdk';
import { CLAUDE_MODEL } from '../../../../../../config/aiConfig';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { id: sessionId } = req.query;
  const { message, contextInfo } = req.body;

  try {
    const response = await anthropic.messages.create({
      model: CLAUDE_MODEL,
      max_tokens: 1000,
      messages: [{
        role: 'user',
        content: message
      }],
      system: "You are an expert system design coach helping developers improve their architecture and implementation decisions.",
      temperature: 0.7,
    });

    return res.status(200).json({
      message: {
        role: 'assistant',
        content: response.content[0].text,
        timestamp: new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('Error processing message:', error);
    return res.status(500).json({ 
      error: 'Failed to process message',
      details: error.message 
    });
  }
}

export const config = {
  api: {
    bodyParser: true,
  },
};



================================================================================
# FILE: client\pages\api\services\aiService.js
# EXTENSION: .js
================================================================================
import { Configuration, OpenAIApi } from 'openai';
import Anthropic from '@anthropic-ai/sdk';
import { AI_CONFIG } from '../../../config/aiConfig';

export class AIService {
  constructor(config) {
    this.provider = config.provider || 'claude';
    this.config = config;
    this.anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    });
  }

  async sendMessage(messages, options = {}) {
    try {
      const systemPrompt = options.systemPrompt || "You are a helpful AI assistant";
      
      const response = await this.anthropic.messages.create({
        model: AI_CONFIG.model,
        max_tokens: 1000,
        messages: messages,
        system: systemPrompt,
        temperature: options.temperature || 0.7,
      });

      return response.content[0].text;
    } catch (error) {
      console.error('AI Service Error:', error);
      throw new Error('Failed to get AI response');
    }
  }
}

export const config = {
  provider: 'claude',
  defaultSystemPrompt: "You are an expert system design coach. Help guide the developer through architectural decisions and trade-offs.",
};

export const aiService = new AIService(config);


================================================================================
# FILE: client\pages\APIDesignPage.js
# EXTENSION: .js
================================================================================
import React, { useState } from 'react';
import { Plus, Trash2, ChevronDown, ChevronUp, MessageSquare, Save, Clock, PenTool } from 'lucide-react';

const EnhancedAPIDesignPage = ({ data = {}, updateData }) => {
  // Preserve original state management for functionality
  const [apis, setApis] = useState(
    data.apis ? JSON.parse(data.apis) : [
      {
        id: 1,
        endpoint: '/api/resource',
        method: 'GET',
        description: 'Get all resources',
        requestParams: [{ id: 1, name: 'limit', type: 'number', required: false, description: 'Maximum results to return' }],
        responseFormat: '[\n  {\n    "id": "string",\n    "name": "string"\n  }\n]',
        expanded: true
      }
    ]
  );
  
  const [apiType, setApiType] = useState(data.apiType || 'REST');
  
  const methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];
  
  // Keep original handler functions
  const addAPI = () => {
    const newId = apis.length > 0 ? Math.max(...apis.map(api => api.id)) + 1 : 1;
    const updatedApis = [...apis, {
      id: newId,
      endpoint: '',
      method: 'GET',
      description: '',
      requestParams: [],
      responseFormat: '{}',
      expanded: true
    }];
    
    setApis(updatedApis);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        apis: JSON.stringify(updatedApis)
      });
    }
  };
  
  const removeAPI = (id) => {
    const updatedApis = apis.filter(api => api.id !== id);
    setApis(updatedApis);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        apis: JSON.stringify(updatedApis)
      });
    }
  };
  
  const updateAPI = (id, field, value) => {
    const updatedApis = apis.map(api => 
      api.id === id ? { ...api, [field]: value } : api
    );
    setApis(updatedApis);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        apis: JSON.stringify(updatedApis)
      });
    }
  };
  
  const toggleExpand = (id) => {
    const updatedApis = apis.map(api => 
      api.id === id ? { ...api, expanded: !api.expanded } : api
    );
    setApis(updatedApis);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        apis: JSON.stringify(updatedApis)
      });
    }
  };
  
  const addRequestParam = (apiId) => {
    const api = apis.find(a => a.id === apiId);
    if (!api) return;
    
    const newParamId = api.requestParams.length > 0 
      ? Math.max(...api.requestParams.map(p => p.id)) + 1 
      : 1;
      
    const newParams = [...api.requestParams, {
      id: newParamId,
      name: '',
      type: 'string',
      required: false,
      description: ''
    }];
    
    updateAPI(apiId, 'requestParams', newParams);
  };
  
  const removeRequestParam = (apiId, paramId) => {
    const api = apis.find(a => a.id === apiId);
    if (!api) return;
    
    const newParams = api.requestParams.filter(p => p.id !== paramId);
    updateAPI(apiId, 'requestParams', newParams);
  };
  
  const updateRequestParam = (apiId, paramId, field, value) => {
    const api = apis.find(a => a.id === apiId);
    if (!api) return;
    
    const newParams = api.requestParams.map(p => 
      p.id === paramId ? { ...p, [field]: value } : p
    );
    
    updateAPI(apiId, 'requestParams', newParams);
  };

  const updateApiType = (type) => {
    setApiType(type);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        apiType: type
      });
    }
  };
  
  return (
    <div className="flex flex-col h-full bg-white">
      <div className="flex-1 overflow-auto p-6 space-y-6">
        {/* Coach tip box */}
        <div className="bg-green-50 border border-green-100 rounded-md p-4 text-sm text-green-700">
          <strong className="font-medium">Coach tip:</strong> Define clear, RESTful endpoints with consistent naming conventions. Document request parameters thoroughly and specify response formats for better developer experience.
        </div>
      
        {/* API Type Selection */}
        <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <div className="flex justify-between items-center mb-3">
            <h2 className="text-lg font-semibold text-gray-800">API Type</h2>
            <button 
              className="text-green-600 hover:text-green-800 text-sm font-medium flex items-center"
              onClick={() => {/* Add diagram functionality */}}
            >
              <PenTool size={14} className="mr-1" />
              Add diagram
            </button>
          </div>
          <div className="flex space-x-4">
            <label className="flex items-center">
              <input 
                type="radio" 
                name="apiType" 
                checked={apiType === 'REST'} 
                onChange={() => updateApiType('REST')}
                className="mr-2 text-green-600 focus:ring-green-500" 
              />
              <span>REST</span>
            </label>
            <label className="flex items-center">
              <input 
                type="radio" 
                name="apiType" 
                checked={apiType === 'GraphQL'} 
                onChange={() => updateApiType('GraphQL')}
                className="mr-2 text-green-600 focus:ring-green-500" 
              />
              <span>GraphQL</span>
            </label>
            <label className="flex items-center">
              <input 
                type="radio" 
                name="apiType" 
                checked={apiType === 'gRPC'} 
                onChange={() => updateApiType('gRPC')}
                className="mr-2 text-green-600 focus:ring-green-500" 
              />
              <span>gRPC</span>
            </label>
          </div>
        </div>
        
        {/* API Endpoints */}
        <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <h2 className="text-lg font-semibold text-gray-800 mb-3">API Endpoints</h2>
          <p className="text-sm text-gray-600 mb-4">Define the endpoints your system exposes</p>
          
          <div className="space-y-4">
            {apis.map(api => (
              <div key={api.id} className="border border-gray-300 rounded-md overflow-hidden shadow-sm">
                {/* API Header */}
                <div className="flex items-center justify-between p-3 bg-gray-100 border-b border-gray-300">
                  <div className="flex items-center space-x-3">
                    <select
                      value={api.method}
                      onChange={(e) => updateAPI(api.id, 'method', e.target.value)}
                      className="px-2 py-1 text-sm font-medium rounded border border-gray-300 bg-white focus:ring-green-500 focus:border-green-500"
                    >
                      {methods.map(method => (
                        <option key={method} value={method}>{method}</option>
                      ))}
                    </select>
                    <input
                      type="text"
                      value={api.endpoint}
                      onChange={(e) => updateAPI(api.id, 'endpoint', e.target.value)}
                      placeholder="Endpoint path (e.g., /api/users)"
                      className="px-2 py-1 text-sm border border-gray-300 rounded w-64 focus:ring-green-500 focus:border-green-500"
                    />
                  </div>
                  <div className="flex items-center">
                    <button 
                      onClick={() => toggleExpand(api.id)}
                      className="p-1 text-gray-500 hover:text-gray-700"
                    >
                      {api.expanded ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                    </button>
                    <button 
                      onClick={() => removeAPI(api.id)}
                      className="p-1 text-gray-500 hover:text-red-500 ml-2"
                    >
                      <Trash2 size={18} />
                    </button>
                  </div>
                </div>
                
                {/* API Details */}
                {api.expanded && (
                  <div className="p-4 space-y-4 bg-white">
                    {/* Description */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Description</label>
                      <input
                        type="text"
                        value={api.description}
                        onChange={(e) => updateAPI(api.id, 'description', e.target.value)}
                        placeholder="What does this endpoint do?"
                        className="w-full px-3 py-2 text-sm border border-gray-300 rounded focus:ring-green-500 focus:border-green-500"
                      />
                    </div>
                    
                    {/* Request Parameters */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Request Parameters</label>
                      <div className="border border-gray-300 rounded overflow-hidden">
                        {/* Table Header */}
                        <div className="grid grid-cols-12 gap-2 bg-gray-100 p-2 text-xs font-medium text-gray-700">
                          <div className="col-span-3">Name</div>
                          <div className="col-span-2">Type</div>
                          <div className="col-span-2">Required</div>
                          <div className="col-span-4">Description</div>
                          <div className="col-span-1"></div>
                        </div>
                        
                        {/* Parameters */}
                        {api.requestParams.map(param => (
                          <div key={param.id} className="grid grid-cols-12 gap-2 p-2 border-t border-gray-300">
                            <div className="col-span-3">
                              <input
                                type="text"
                                value={param.name}
                                onChange={(e) => updateRequestParam(api.id, param.id, 'name', e.target.value)}
                                placeholder="Parameter name"
                                className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:ring-green-500 focus:border-green-500"
                              />
                            </div>
                            <div className="col-span-2">
                              <select
                                value={param.type}
                                onChange={(e) => updateRequestParam(api.id, param.id, 'type', e.target.value)}
                                className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:ring-green-500 focus:border-green-500"
                              >
                                <option value="string">string</option>
                                <option value="number">number</option>
                                <option value="boolean">boolean</option>
                                <option value="object">object</option>
                                <option value="array">array</option>
                              </select>
                            </div>
                            <div className="col-span-2 flex items-center">
                              <input
                                type="checkbox"
                                checked={param.required}
                                onChange={(e) => updateRequestParam(api.id, param.id, 'required', e.target.checked)}
                                className="mr-2 rounded text-green-600 focus:ring-green-500"
                              />
                              <span className="text-sm">Required</span>
                            </div>
                            <div className="col-span-4">
                              <input
                                type="text"
                                value={param.description}
                                onChange={(e) => updateRequestParam(api.id, param.id, 'description', e.target.value)}
                                placeholder="Parameter description"
                                className="w-full px-2 py-1 text-sm border border-gray-300 rounded focus:ring-green-500 focus:border-green-500"
                              />
                            </div>
                            <div className="col-span-1 flex justify-end">
                              <button 
                                onClick={() => removeRequestParam(api.id, param.id)}
                                className="p-1 text-gray-500 hover:text-red-500"
                              >
                                <Trash2 size={14} />
                              </button>
                            </div>
                          </div>
                        ))}
                        
                        {/* Add Parameter Button */}
                        <div className="p-2 border-t border-gray-300">
                          <button
                            onClick={() => addRequestParam(api.id)}
                            className="flex items-center text-xs text-green-600 hover:text-green-800 font-medium"
                          >
                            <Plus size={14} className="mr-1" />
                            Add Parameter
                          </button>
                        </div>
                      </div>
                    </div>
                    
                    {/* Response Format */}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">Response Format</label>
                      <div className="flex">
                        <textarea
                          value={api.responseFormat}
                          onChange={(e) => updateAPI(api.id, 'responseFormat', e.target.value)}
                          placeholder="JSON response schema"
                          className="flex-1 h-32 px-3 py-2 text-sm border border-gray-300 rounded font-mono focus:ring-green-500 focus:border-green-500"
                        />
                      </div>
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
          
          <button 
            onClick={addAPI}
            className="mt-4 flex items-center text-sm text-green-600 hover:text-green-800 font-medium"
          >
            <Plus size={16} className="mr-1" />
            Add Endpoint
          </button>
        </div>
      </div>
      
      {/* Enhanced footer with actions */}
      <div className="border-t border-gray-200 p-4 flex justify-between">
        <button className="flex items-center px-4 py-2 text-sm bg-green-50 text-green-700 rounded-md hover:bg-green-100 transition-colors">
          <MessageSquare size={16} className="mr-2" />
          Ask Coach
        </button>
        <button className="flex items-center px-4 py-2 text-sm bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors shadow-sm">
          <Save size={16} className="mr-2" />
          Save & Continue
        </button>
      </div>
    </div>
  );
};

export default EnhancedAPIDesignPage;


================================================================================
# FILE: client\pages\auth\login.js
# EXTENSION: .js
================================================================================
import { useState } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { Layout } from 'lucide-react';

export default function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { login } = useAuth();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setIsSubmitting(true);

    try {
      const result = await login(email, password);
      console.log('Login result:', result);
      
      if (!result.success) {
        setError(result.error || 'Login failed');
      }
      // Successful login is handled by AuthContext (redirect)
      
    } catch (error) {
      console.error('Login error:', error);
      setError(error.message || 'An error occurred during login');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen bg-slate-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-xl shadow-md p-8 w-full max-w-md">
        <div className="flex justify-center mb-6">
          <div className="h-12 w-12 rounded-md bg-indigo-500 flex items-center justify-center">
            <Layout className="h-8 w-8 text-white" />
          </div>
        </div>
        
        <h1 className="text-2xl font-bold text-center mb-6">Sign in to System Design Coach</h1>
        
        {error && (
          <div className="mb-4 p-3 bg-red-50 text-red-700 rounded border border-red-200">
            {error}
          </div>
        )}
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-slate-700 mb-1">
              Email address
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-slate-700 mb-1">
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          
          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:opacity-50"
          >
            {isSubmitting ? 'Signing in...' : 'Sign in'}
          </button>
        </form>
        
        <div className="mt-6 text-center text-sm">
          <span className="text-slate-600">Don't have an account?</span>{' '}
          <a href="/auth/register" className="text-indigo-600 hover:text-indigo-800 font-medium">
            Sign up
          </a>
        </div>
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\auth\register.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import { Layout } from 'lucide-react';
import { useAuth } from '../../contexts/AuthContext';

export default function Register() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [experience, setExperience] = useState('intermediate');
  const [error, setError] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const { register, isAuthenticated } = useAuth();
  const router = useRouter();
  
  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated) {
      router.push('/dashboard');
    }
  }, [isAuthenticated, router]);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    console.log('Registration submitted:', { name, email, experience });
    
    try {
      const result = await register(name, email, password, experience);
      console.log('Registration result:', result);
      
      if (result.success) {
        router.push('/dashboard');
      } else {
        setError(result.error);
      }
    } catch (error) {
      console.error('Registration error:', error);
      setError(error.response?.data?.error || 'Registration failed');
    }
  };
  
  return (
    <div className="min-h-screen bg-slate-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-xl shadow-md p-8 w-full max-w-md">
        <div className="flex justify-center mb-6">
          <div className="h-12 w-12 rounded-md bg-indigo-500 flex items-center justify-center">
            <Layout className="h-8 w-8 text-white" />
          </div>
        </div>
        
        <h1 className="text-2xl font-bold text-center mb-6">Create an Account</h1>
        
        {error && (
          <div className="mb-4 p-3 bg-red-50 text-red-700 rounded border border-red-200">
            {error}
          </div>
        )}
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="name" className="block text-sm font-medium text-slate-700 mb-1">
              Full Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-slate-700 mb-1">
              Email address
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-slate-700 mb-1">
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          
          <div>
            <label htmlFor="experience" className="block text-sm font-medium text-slate-700 mb-1">
              Experience Level
            </label>
            <select
              id="experience"
              value={experience}
              onChange={(e) => setExperience(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
            >
              <option value="beginner">Beginner</option>
              <option value="intermediate">Intermediate</option>
              <option value="senior">Senior</option>
              <option value="expert">Expert</option>
            </select>
          </div>
          
          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:opacity-50"
          >
            {isSubmitting ? 'Creating Account...' : 'Create Account'}
          </button>
        </form>
        
        <div className="mt-6 text-center text-sm">
          <span className="text-slate-600">Already have an account?</span>{' '}
          <Link href="/auth/login" className="text-indigo-600 hover:text-indigo-800 font-medium">
            Sign in
          </Link>
        </div>
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\chat.js
# EXTENSION: .js
================================================================================
import CoachAgentInterface from '../components/CoachAgentInterface';

export default function ChatPage() {
  return (
    <div className="container mx-auto h-screen">
      <CoachAgentInterface />
    </div>
  );
}


================================================================================
# FILE: client\pages\coaching\[id].js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useRouter } from 'next/router';
import dynamic from 'next/dynamic';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw';
import {
  ArrowLeft, Save, Send, RefreshCw, MessageSquare, CheckCircle, XCircle, Eye, Edit, 
  ClipboardList, Database, Code, Layout, BarChart, Shield, ChevronDown, ChevronUp
} from 'lucide-react';
import { applyNodeChanges, applyEdgeChanges, addEdge } from 'reactflow';
import { useAuth } from '../../contexts/AuthContext';
import {
  getCoachingSession, sendCoachingMessage, getCoachingMaterials,
  getCoachingDiagram, saveDiagram
} from '../../utils/api';
import { mermaidToReactFlow, reactFlowToMermaid } from '../../components/diagram/utils/conversion';
import TopicGuidedCoaching from '../../components/coaching/TopicGuidedCoaching';

// Import workbook components directly
import RequirementsPage from '../RequirementsPage';
import APIDesignPage from '../APIDesignPage';
import DataModelPage from '../DataModelPage';
import SystemArchitecturePage from '../SystemArchitecturePage';
import ScalingStrategyPage from '../ScalingStrategyPage';
import ReliabilitySecurityPage from '../ReliabilitySecurityPage';

const MermaidRenderer = dynamic(() => import('../../components/diagram/MermaidRenderer'), {
  ssr: false,
  loading: () => <div className="animate-pulse bg-gray-100 h-full w-full"></div>
});

const SystemArchitectureDiagram = dynamic(() => import('../../components/diagram/SystemArchitectureDiagram'), {
  ssr: false,
  loading: () => (
    <div className="flex h-full items-center justify-center bg-gray-50">
      <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500"></div>
    </div>
  )
});

const SystemSequenceDiagram = dynamic(() => import('../../components/diagram/SystemSequenceDiagram'), {
  ssr: false,
  loading: () => (
    <div className="flex h-full items-center justify-center bg-gray-50">
      <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500"></div>
    </div>
  )
});

const CoachingSessionPage = () => {
  const router = useRouter();
  const { user } = useAuth();
  const messagesEndRef = useRef(null);
  
  // Safely extract session ID from router query
  const sessionId = router.query?.id;

  // Session state
  const [session, setSession] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // UI state
  const [messageInput, setMessageInput] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [activeMaterial, setActiveMaterial] = useState(null);
  const [currentTopic, setCurrentTopic] = useState('REQUIREMENTS');
  const [includeDiagram, setIncludeDiagram] = useState(false);
  const [requestDiagramSuggestions, setRequestDiagramSuggestions] = useState(false);
  
  // Add state for TopicGuidedCoaching collapsible section
  const [topicGuidedOpen, setTopicGuidedOpen] = useState(false);
  
  // Add dropdown reference
  const workbookDropdownRef = useRef(null);
  const [showWorkbookDropdown, setShowWorkbookDropdown] = useState(false);

  // Chat state
  const [messages, setMessages] = useState([]);
  const [isTyping, setIsTyping] = useState(false);

  // Diagram state
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [diagramCode, setDiagramCode] = useState(
    'graph TD\n    Client[Client] --> API[API Gateway]\n    API --> Service[Service]\n    Service --> DB[(Database)]'
  );
  const [viewMode, setViewMode] = useState('edit');
  const [currentDiagramState, setCurrentDiagramState] = useState(null);
  const [isSavingDiagram, setIsSavingDiagram] = useState(false);
  const [diagramSuggestions, setDiagramSuggestions] = useState(null);
  const [showSuggestions, setShowSuggestions] = useState(false);

  // Workbook state
  const [rightPanelMode, setRightPanelMode] = useState('workbook'); // 'workbook' or 'diagram'
  const [activeWorkbookTab, setActiveWorkbookTab] = useState('requirements');
  const [formData, setFormData] = useState({
    requirements: {},
    api: {},
    data: {},
    architecture: {},
    scaling: {},
    reliability: {}
  });

  // Define workbook tabs
  const workbookTabs = [
    { id: 'requirements', label: 'Requirements', icon: <ClipboardList size={18} /> },
    { id: 'api', label: 'API Design', icon: <Code size={18} /> },
    { id: 'data', label: 'Data Model', icon: <Database size={18} /> },
    { id: 'architecture', label: 'Architecture', icon: <Layout size={18} /> },
    { id: 'scaling', label: 'Scaling Strategy', icon: <BarChart size={18} /> },
    { id: 'reliability', label: 'Reliability & Security', icon: <Shield size={18} /> }
  ];
  
  // Define diagram tabs
  const [diagramTabs, setDiagramTabs] = useState([
    { id: 'systems', label: 'Systems Diagram', active: true },
    { id: 'sequence', label: 'Sequence Diagram', active: false }
  ]);
  
  const setActiveDiagramTab = (tabId) => {
    setDiagramTabs(diagramTabs.map(tab => ({
      ...tab,
      active: tab.id === tabId
    })));
  };

  // Update form data
  const updateFormData = (section, data) => {
    setFormData(prev => ({
      ...prev,
      [section]: data
    }));
  };
  
  // Add click outside handler for workbook dropdown
  useEffect(() => {
    function handleClickOutside(event) {
      if (workbookDropdownRef.current && !workbookDropdownRef.current.contains(event.target)) {
        setShowWorkbookDropdown(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [workbookDropdownRef]);

  // Load session data
  useEffect(() => {
    if (!sessionId) return;
    
    const fetchSession = async () => {
      try {
        const data = await getCoachingSession(sessionId);
        console.log('SESSION DATA:', JSON.stringify(data, null, 2));

        const initialMessages = data.conversation 
          ? data.conversation.map((msg, index) => ({
              id: index,
              role: msg.role === 'system' ? 'system' : 
                    msg.role === 'assistant' ? 'assistant' : 'user',
              content: msg.content || "No content available",
              timestamp: msg.timestamp || new Date().toISOString()
            }))
          : [{
              id: 0,
              role: 'assistant',
              content: `Welcome to your ${data.problem?.title || 'system design'} coaching session. Let's begin our system design journey!`,
              timestamp: new Date().toISOString()
            }];

        console.log('INITIAL MESSAGES:', JSON.stringify(initialMessages, null, 2));
        setMessages(initialMessages);
        setSession(data);
        setError(null);
      } catch (err) {
        console.error(`Error fetching coaching session ${sessionId}:`, err);
        setError("Failed to load coaching session");
        setMessages([{
          id: 0,
          role: 'assistant',
          content: "Welcome to your system design coaching session. Let's get started!",
          timestamp: new Date().toISOString()
        }]);
      } finally {
        setLoading(false);
      }
    };

    fetchSession();
  }, [sessionId]);
  
  // Auto-scroll to bottom of messages
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  const detectCurrentTopic = (conversation) => {
    const topicKeywords = {
      'REQUIREMENTS': ['requirements', 'features', 'functional', 'non-functional', 'constraints', 'users', 'scale'],
      'ARCHITECTURE': ['architecture', 'components', 'services', 'monolith', 'microservices', 'api'],
      'STORAGE': ['database', 'storage', 'schema', 'SQL', 'NoSQL', 'cache', 'data model'],
      'SCALABILITY': ['scale', 'scaling', 'load balancing', 'horizontal', 'vertical', 'throughput'],
      'RELIABILITY': ['reliability', 'fault tolerance', 'redundancy', 'availability', 'monitoring']
    };
    const recentMessages = conversation.slice(-5);
    const combinedText = recentMessages.map(msg => typeof msg.content === 'string' ? msg.content.toLowerCase() : '').join(' ');
    let bestTopic = 'REQUIREMENTS';
    let highestCount = 0;
    for (const [topic, keywords] of Object.entries(topicKeywords)) {
      const count = keywords.reduce((sum, keyword) => sum + (combinedText.includes(keyword.toLowerCase()) ? 1 : 0), 0);
      if (count > highestCount) {
        highestCount = count;
        bestTopic = topic;
      }
    }
    setCurrentTopic(bestTopic);
  };

  const handleSendMessage = async (message, contextInfo = null) => {
    if (!message || typeof message !== 'string' || message.trim() === '') {
      console.error("Invalid message:", message);
      return;
    }
    
    setIsSending(true);
    try {
      const userMessage = {
        id: messages.length,
        role: 'user',
        content: message,
        timestamp: new Date().toISOString()
      };
      setMessages(prev => [...prev, userMessage]);

      const response = await sendCoachingMessage(sessionId, message, contextInfo);
      
      if (response?.message) {
        // Log response details in a cleaner format
        console.log("Processing coach response:", {
          messageId: messages.length + 1,
          role: response.message.role,
          timestamp: response.message.timestamp,
          hasDiagramSuggestions: !!response.diagramSuggestions
        });

        const responseMessage = {
          id: messages.length + 1,
          role: response.message.role === 'coach' ? 'assistant' : response.message.role,
          content: response.message.content,
          timestamp: response.message.timestamp
        };
        
        setMessages(prev => [...prev, responseMessage]);
        setSession(prev => ({
          ...prev,
          conversation: [
            ...(prev.conversation || []),
            userMessage,
            {
              role: response.message.role,
              content: response.message.content,
              timestamp: response.message.timestamp
            }
          ]
        }));

        if (response.diagramSuggestions) {
          handleDiagramSuggestions(response.diagramSuggestions);
        }
      }
    } catch (error) {
      console.error("Error handling message:", error);
    } finally {
      setIsSending(false);
    }
  };

  const handleGetMaterials = async (topic) => {
    if (!topic || !sessionId) return;
    try {
      setLoading(true);
      const materials = await getCoachingMaterials(sessionId, topic);
      setActiveMaterial(materials);
    } catch (err) {
      console.error("Error fetching materials:", err);
      setError("Failed to load learning materials");
    } finally {
      setLoading(false);
    }
  };

  const handleSendDiagramToCoach = async () => {
    if (!diagramCode || !sessionId) return;
    const message = "Can you provide feedback on my system design diagram?";
    try {
      setIsSending(true);
      const newMessage = {
        id: Date.now(),
        role: 'user',
        content: message,
        timestamp: new Date().toISOString()
      };
      setMessages(prev => [...prev, newMessage]);
      setIsTyping(true);
      const contextInfo = {
        diagramContext: currentDiagramState,
        requestDiagramFeedback: true
      };
      const response = await sendCoachingMessage(sessionId, message, contextInfo);
      if (response?.message) {
        const botMessage = {
          id: Date.now() + 1,
          role: 'assistant',
          content: response.message.content,
          timestamp: new Date().toISOString()
        };
        setMessages(prev => [...prev, botMessage]);
        setSession(prev => ({
          ...prev,
          conversation: [
            ...(prev.conversation || []),
            { role: 'user', content: message },
            { role: 'assistant', content: response.message.content }
          ]
        }));
        if (response.diagramSuggestions) {
          handleDiagramSuggestions(response.diagramSuggestions);
        }
      }
    } catch (err) {
      console.error("Error sending diagram for feedback:", err);
      const errorMessage = {
        id: Date.now() + 1,
        role: 'system',
        content: 'Failed to get diagram feedback. Please try again.',
        error: true,
        timestamp: new Date().toISOString()
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
      setIsSending(false);
    }
  };

  const handleDiagramSuggestions = (suggestions) => {
    if (!suggestions || !suggestions.mermaidCode) return;
    try {
      const { nodes: suggestedNodes, edges: suggestedEdges } = mermaidToReactFlow(suggestions.mermaidCode);
      const markedNodes = suggestedNodes.map(node => ({
        ...node,
        style: { ...node.style, border: '2px dashed #4f46e5' },
        data: { ...node.data, suggested: true }
      }));
      const markedEdges = suggestedEdges.map(edge => ({
        ...edge,
        style: { ...edge.style, strokeDasharray: '5,5', stroke: '#4f46e5' },
        data: { ...edge.data, suggested: true }
      }));
      setDiagramSuggestions({
        nodes: markedNodes,
        edges: markedEdges,
        mermaidCode: suggestions.mermaidCode
      });
      setShowSuggestions(true);
    } catch (err) {
      console.error("Error processing diagram suggestions:", err);
    }
  };

  const handleAcceptSuggestions = () => {
    if (!diagramSuggestions) return;
    const updatedNodes = [...nodes, ...diagramSuggestions.nodes.filter(
      sugNode => !nodes.some(node => node.id === sugNode.id)
    )];
    const updatedEdges = [...edges, ...diagramSuggestions.edges.filter(
      sugEdge => !edges.some(edge => edge.id === sugEdge.id)
    )];
    setNodes(updatedNodes);
    setEdges(updatedEdges);
    setDiagramCode(diagramSuggestions.mermaidCode);
    setCurrentDiagramState({
      nodes: updatedNodes,
      edges: updatedEdges,
      mermaidCode: diagramSuggestions.mermaidCode
    });
    setDiagramSuggestions(null);
    setShowSuggestions(false);
  };

  const handleDiscardSuggestions = () => {
    setDiagramSuggestions(null);
    setShowSuggestions(false);
  };

  const handleSaveDiagram = async () => {
    if (!sessionId) return;
    try {
      setIsSavingDiagram(true);
      const diagramData = {
        mermaidCode: diagramCode,
        reactFlowData: { nodes, edges }
      };
      await saveDiagram(sessionId, diagramData);
      setSession(prev => ({
        ...prev,
        diagram: diagramData
      }));
    } catch (err) {
      console.error("Error saving diagram:", err);
      setError("Failed to save diagram");
    } finally {
      setIsSavingDiagram(false);
    }
  };

  const handleGetDiagramSuggestion = async () => {
    if (!sessionId) return;
    try {
      setLoading(true);
      const suggestion = await getCoachingDiagram(sessionId);
      if (suggestion?.mermaidCode) {
        try {
          const { nodes: convertedNodes, edges: convertedEdges } = mermaidToReactFlow(suggestion.mermaidCode);
          const markedNodes = convertedNodes.map(node => ({
            ...node,
            style: { ...node.style, border: '2px dashed #4f46e5' },
            data: { ...node.data, suggested: true }
          }));
          const markedEdges = convertedEdges.map(edge => ({
            ...edge,
            style: { ...edge.style, strokeDasharray: '5,5', stroke: '#4f46e5' },
            data: { ...edge.data, suggested: true }
          }));
          setDiagramSuggestions({
            nodes: markedNodes,
            edges: markedEdges,
            mermaidCode: suggestion.mermaidCode
          });
          setShowSuggestions(true);
        } catch (err) {
          console.error("Error converting AI diagram:", err);
        }
      }
    } catch (err) {
      console.error("Error getting diagram suggestion:", err);
      setError("Failed to get diagram suggestion");
    } finally {
      setLoading(false);
    }
  };

  const onNodesChange = useCallback(
    (changes) => {
      setNodes(nds => {
        const updatedNodes = applyNodeChanges(changes, nds);
        try {
          const newDiagramCode = reactFlowToMermaid({ nodes: updatedNodes, edges });
          setDiagramCode(newDiagramCode);
          setCurrentDiagramState({ nodes: updatedNodes, edges, mermaidCode: newDiagramCode });
        } catch (err) {
          console.error("Error updating Mermaid code:", err);
        }
        return updatedNodes;
      });
    },
    [edges]
  );

  const onEdgesChange = useCallback(
    (changes) => {
      setEdges(eds => {
        const updatedEdges = applyEdgeChanges(changes, eds);
        try {
          const newDiagramCode = reactFlowToMermaid({ nodes, edges: updatedEdges });
          setDiagramCode(newDiagramCode);
          setCurrentDiagramState({ nodes, edges: updatedEdges, mermaidCode: newDiagramCode });
        } catch (err) {
          console.error("Error updating Mermaid code:", err);
        }
        return updatedEdges;
      });
    },
    [nodes]
  );

  const onConnect = useCallback(
    (params) => {
      const newEdge = { ...params, id: `e${params.source}-${params.target}` };
      setEdges(eds => {
        const updatedEdges = addEdge(newEdge, eds);
        try {
          const newDiagramCode = reactFlowToMermaid({ nodes, edges: updatedEdges });
          setDiagramCode(newDiagramCode);
          setCurrentDiagramState({ nodes, edges: updatedEdges, mermaidCode: newDiagramCode });
        } catch (err) {
          console.error("Error updating Mermaid code:", err);
        }
        return updatedEdges;
      });
    },
    [nodes]
  );

  const handleDiagramUpdate = (diagramData) => {
    const diagramType = activeDiagramTab === 'sequence' ? 'sequence' : 'system';
    
    setWorkbookState(prev => ({
      ...prev,
      diagrams: {
        ...prev.diagrams,
        [diagramType]: {
          ...prev.diagrams?.[diagramType],
          ...diagramData
        }
      }
    }));
  };

  const handleDiagramSave = async () => {
    if (!sessionId) return;
    
    const diagramType = activeDiagramTab === 'sequence' ? 'sequence' : 'system';
    const currentDiagram = workbookState.diagrams?.[diagramType];
    
    try {
      setIsSaving(true);
      await saveDiagram(sessionId, diagramType, currentDiagram);
      setIsSaving(false);
    } catch (error) {
      console.error('Error saving diagram:', error);
      // Handle error
    }
  };

  const renderDiagramEditor = () => {
    // Get active diagram tab
    const activeDiagramTab = diagramTabs.find(tab => tab.active)?.id || 'systems';
    
    if (activeDiagramTab === 'sequence') {
      return (
        <div className="relative h-full">
          <SystemSequenceDiagram 
            initialDiagram={currentDiagramState}
            onDiagramUpdate={handleDiagramUpdate}
          />
        </div>
      );
    }
    
    // Default systems diagram
    if (viewMode === 'edit') {
      return (
        <div className="relative h-full">
          <SystemArchitectureDiagram
            initialNodes={nodes}
            initialEdges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onDiagramUpdate={handleDiagramUpdate}
          />
          {showSuggestions && diagramSuggestions && (
            <div className="absolute inset-0 bg-black bg-opacity-10 z-10 flex flex-col">
              <div className="bg-yellow-50 p-3 border-b border-yellow-200">
                <div className="flex justify-between items-center">
                  <p className="text-sm text-yellow-800">
                    <span className="font-medium">AI has suggested diagram changes</span>
                  </p>
                  <div className="flex space-x-2">
                    <button 
                      onClick={handleAcceptSuggestions}
                      className="px-3 py-1 bg-green-600 text-white text-sm rounded flex items-center"
                    >
                      <CheckCircle className="h-4 w-4 mr-1" />
                      Accept Changes
                    </button>
                    <button 
                      onClick={handleDiscardSuggestions}
                      className="px-3 py-1 bg-gray-600 text-white text-sm rounded flex items-center"
                    >
                      <XCircle className="h-4 w-4 mr-1" />
                      Discard
                    </button>
                  </div>
                </div>
              </div>
              <div className="flex-1 relative">
                <SystemArchitectureDiagram
                  initialNodes={diagramSuggestions.nodes}
                  initialEdges={diagramSuggestions.edges}
                  onNodesChange={() => {}}
                  onEdgesChange={() => {}}
                  onConnect={() => {}}
                />
              </div>
            </div>
          )}
        </div>
      );
    } else if (viewMode === 'preview') {
      return <MermaidRenderer code={diagramCode} />;
    } else {
      return (
        <div className="h-full p-4 flex flex-col">
          <textarea
            value={diagramCode}
            onChange={e => setDiagramCode(e.target.value)}
            className="w-full flex-1 font-mono text-sm p-2 border border-gray-300 rounded"
          />
          <div className="mt-2">
            <button
              onClick={() => {
                try {
                  const { nodes: newNodes, edges: newEdges } = mermaidToReactFlow(diagramCode);
                  setNodes(newNodes);
                  setEdges(newEdges);
                  setViewMode('edit');
                } catch (err) {
                  console.error("Error parsing Mermaid code:", err);
                  alert("Invalid Mermaid code: " + err.message);
                }
              }}
              className="px-3 py-1 bg-blue-600 text-white text-sm rounded"
            >
              Apply Changes
            </button>
          </div>
        </div>
      );
    }
  };

  // Render active workbook component
  const getActiveWorkbookComponent = () => {
    switch (activeWorkbookTab) {
      case 'requirements':
        return <RequirementsPage data={formData.requirements} updateData={(data) => updateFormData('requirements', data)} />;
      case 'api':
        return <APIDesignPage data={formData.api} updateData={(data) => updateFormData('api', data)} />;
      case 'data':
        return <DataModelPage data={formData.data} updateData={(data) => updateFormData('data', data)} />;
      case 'architecture':
        return <SystemArchitecturePage data={formData.architecture} updateData={(data) => updateFormData('architecture', data)} />;
      case 'scaling':
        return <ScalingStrategyPage data={formData.scaling} updateData={(data) => updateFormData('scaling', data)} />;
      case 'reliability':
        return <ReliabilitySecurityPage data={formData.reliability} updateData={(data) => updateFormData('reliability', data)} />;
      default:
        return <RequirementsPage data={formData.requirements} updateData={(data) => updateFormData('requirements', data)} />;
    }
  };

  if (loading && !session) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
        <div className="ml-3 text-gray-600">Loading session data...</div>
      </div>
    );
  }

  if (error && !session && messages.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-screen">
        <div className="text-red-500 mb-4">{error}</div>
        <button
          onClick={() => router.back()}
          className="px-4 py-2 bg-blue-600 text-white rounded"
        >
          Go Back
        </button>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-screen bg-gray-50">
      {/* Header */}
      <header className="bg-white border-b border-gray-200 p-4">
        <div className="flex justify-between items-center">
          <div className="flex items-center">
            <button
              onClick={() => router.push('/coaching')}
              className="p-1 rounded-full hover:bg-gray-100 mr-2"
            >
              <ArrowLeft className="h-5 w-5 text-gray-600" />
            </button>
            <h1 className="text-lg font-semibold">
              {session?.problem?.title || 'System Design Coaching'}
            </h1>
          </div>
          <div className="flex items-center space-x-2">
            <div className="mr-2">
              <div className="flex border border-gray-300 rounded-lg overflow-hidden">
                <button
                  onClick={() => setRightPanelMode('workbook')}
                  className={`px-4 py-2 text-sm font-medium ${
                    rightPanelMode === 'workbook'
                      ? 'bg-blue-600 text-white'
                      : 'bg-white text-gray-700 hover:bg-gray-100'
                  }`}
                >
                  Workbook
                </button>
                <button
                  onClick={() => setRightPanelMode('diagram')}
                  className={`px-4 py-2 text-sm font-medium ${
                    rightPanelMode === 'diagram'
                      ? 'bg-blue-600 text-white'
                      : 'bg-white text-gray-700 hover:bg-gray-100'
                  }`}
                >
                  Diagram
                </button>
              </div>
            </div>
          </div>
        </div>
      </header>

      {/* Main content */}
      <div className="flex-1 flex overflow-hidden">
        {/* Left panel - Chat */}
        <div className="w-1/2 flex flex-col border-r border-gray-200">
          {/* Messages area */}
          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            <div className="bg-white border border-gray-200 rounded-lg mb-4 overflow-hidden">
              <div className="flex justify-between items-center cursor-pointer p-3 bg-indigo-50 border-b border-gray-200" 
                   onClick={() => setTopicGuidedOpen(!topicGuidedOpen)}>
                <h3 className="font-medium text-indigo-700">Topic Guided Coaching</h3>
                {topicGuidedOpen ? (
                  <ChevronUp className="h-5 w-5 text-indigo-600" />
                ) : (
                  <ChevronDown className="h-5 w-5 text-indigo-600" />
                )}
              </div>
              {topicGuidedOpen && (
                <div className="p-3">
                  <TopicGuidedCoaching 
                    currentTopic={currentTopic}
                    onSendMessage={(question) => handleSendMessage(question)}
                    onGetMaterials={handleGetMaterials}
                  />
                </div>
              )}
            </div>
            
            {messages.length > 0 ? (
              messages.map((msg, index) => (
                <div
                  key={msg.id || index}
                  className={`p-3 rounded-lg ${
                    msg.role === 'user'
                      ? 'bg-blue-100 ml-auto max-w-md'
                      : msg.role === 'system'
                        ? 'bg-gray-100 text-gray-700'
                        : 'bg-white border border-gray-200 max-w-lg'
                  } ${msg.error ? 'border-red-300 text-red-600' : ''}`}
                >
                  <ReactMarkdown
                    remarkPlugins={[remarkGfm]}
                    rehypePlugins={[rehypeRaw]}
                    components={{
                      code({ node, inline, className, children, ...props }) {
                        const match = /language-(\w+)/.exec(className || '');
                        return !inline && match ? (
                          <div className="rounded border border-gray-200 overflow-hidden my-2">
                            <div className="bg-gray-50 border-b border-gray-200 px-4 py-1 text-xs text-gray-500 font-mono">
                              {match[1]}
                            </div>
                            <pre className="bg-white p-4 overflow-auto text-sm">
                              <code className={className} {...props}>
                                {children}
                              </code>
                            </pre>
                          </div>
                        ) : (
                          <code className="font-mono text-sm bg-gray-50 px-1 py-0.5 rounded text-pink-600" {...props}>
                            {children}
                          </code>
                        );
                      }
                    }}
                  >
                    {msg.content}
                  </ReactMarkdown>
                </div>
              ))
            ) : (
              <div className="text-center text-gray-500 py-8">
                No messages yet. Start by asking a question about system design.
              </div>
            )}
            {isTyping && (
              <div className="bg-white border border-gray-200 rounded-lg p-3 max-w-lg">
                <div className="flex space-x-2">
                  <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style={{ animationDelay: '0ms' }}></div>
                  <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style={{ animationDelay: '150ms' }}></div>
                  <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style={{ animationDelay: '300ms' }}></div>
                </div>
              </div>
            )}
            <div ref={messagesEndRef} />
          </div>

          {/* Message input */}
          <div className="p-4 border-t border-gray-200">
            <div className="p-3 mb-3 bg-blue-50 border border-blue-100 rounded-lg">
              <div className="flex items-center space-x-6">
                <label className="flex items-center cursor-pointer">
                  <input
                    type="checkbox"
                    className="mr-2 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    checked={includeDiagram}
                    onChange={() => setIncludeDiagram(!includeDiagram)}
                  />
                  <span className="text-blue-700 font-medium">Include current design</span>
                </label>
                <label className="flex items-center cursor-pointer">
                  <input
                    type="checkbox"
                    className="mr-2 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    checked={requestDiagramSuggestions}
                    onChange={() => setRequestDiagramSuggestions(!requestDiagramSuggestions)}
                  />
                  <span className="text-blue-700 font-medium">Request diagram suggestions</span>
                </label>
              </div>
            </div>
            <form
              onSubmit={(e) => {
                e.preventDefault();
                if (messageInput.trim()) {
                  handleSendMessage(messageInput);
                  setMessageInput('');
                }
              }}
              className="flex"
            >
              <textarea
                value={messageInput}
                onChange={(e) => setMessageInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (messageInput.trim()) {
                      handleSendMessage(messageInput);
                      setMessageInput('');
                    }
                  }
                }}
                placeholder="Type your message... (Shift+Enter for new line)"
                className="flex-1 border border-gray-300 rounded-l-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none min-h-[40px] max-h-[120px] overflow-y-auto"
                disabled={isSending}
                rows={1}
              />
              <button
                type="submit"
                className={`px-4 py-2 rounded-r-md flex items-center justify-center ${
                  isSending
                    ? 'bg-gray-300 text-gray-700'
                    : 'bg-blue-600 text-white hover:bg-blue-700'
                }`}
                disabled={isSending}
              >
                {isSending ? (
                  <RefreshCw className="h-5 w-5 animate-spin" />
                ) : (
                  <Send className="h-5 w-5" />
                )}
              </button>
            </form>
          </div>
        </div>

        {/* Right panel - Diagram or Workbook */}
        <div className="w-1/2 flex flex-col">
          {rightPanelMode === 'diagram' ? (
            <>
              {/* Diagram mode controls */}
              <div className="bg-white border-b border-gray-200 p-3">
                <div className="flex justify-between items-center">
                  {/* Diagram type tabs */}
                  <div className="flex space-x-4">
                    {diagramTabs.map(tab => (
                      <button
                        key={tab.id}
                        onClick={() => setActiveDiagramTab(tab.id)}
                        className={`px-4 py-2 text-sm font-medium rounded-lg ${
                          tab.active
                            ? 'bg-blue-100 text-blue-700 border border-blue-200'
                            : 'text-gray-600 hover:bg-gray-100'
                        }`}
                      >
                        {tab.label}
                      </button>
                    ))}
                  </div>
                  
                  {/* Diagram view controls */}
                  <div className="flex space-x-1">
                    <button
                      onClick={() => setViewMode('edit')}
                      className={`px-3 py-1 text-xs rounded-lg border ${
                        viewMode === 'edit'
                          ? 'bg-blue-50 text-blue-700 border-blue-200'
                          : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50'
                      }`}
                    >
                      <Edit className="h-3 w-3 inline mr-1" />
                      Edit
                    </button>
                    <button
                      onClick={() => setViewMode('preview')}
                      className={`px-3 py-1 text-xs rounded-lg border ${
                        viewMode === 'preview'
                          ? 'bg-blue-50 text-blue-700 border-blue-200'
                          : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50'
                      }`}
                    >
                      <Eye className="h-3 w-3 inline mr-1" />
                      Preview
                    </button>
                    <button
                      onClick={() => setViewMode('code')}
                      className={`px-3 py-1 text-xs rounded-lg border ${
                        viewMode === 'code'
                          ? 'bg-blue-50 text-blue-700 border-blue-200'
                          : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50'
                      }`}
                    >
                      <Code className="h-3 w-3 inline mr-1" />
                      Code
                    </button>
                  </div>
                  
                  <button
                    onClick={handleSendDiagramToCoach}
                    className="px-3 py-1 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                  >
                    Get Feedback
                  </button>
                </div>
              </div>
              {/* Diagram content */}
              <div className="flex-1 overflow-hidden">
                {renderDiagramEditor()}
              </div>
            </>
          ) : (
            <>
              {/* Workbook tabs */}
              <div className="bg-white border-b border-gray-200">
                <div className="flex w-full overflow-hidden relative">
                  <div className="flex flex-1 overflow-x-auto">
                    {workbookTabs.map((tab) => (
                      <button
                        key={tab.id}
                        onClick={() => setActiveWorkbookTab(tab.id)}
                        className={`flex items-center py-3 px-4 text-sm font-medium whitespace-nowrap transition-colors ${
                          activeWorkbookTab === tab.id
                            ? 'border-b-2 border-indigo-600 text-indigo-700 bg-indigo-50'
                            : 'border-b-2 border-transparent text-gray-600 hover:text-gray-800 hover:bg-gray-50'
                        }`}
                      >
                        <span className="mr-2">{tab.icon}</span>
                        <span className="truncate">{tab.label}</span>
                      </button>
                    ))}
                  </div>
                  <div className="absolute right-0 top-0 h-full bg-gradient-to-l from-white to-transparent w-12 flex items-center justify-end">
                    <button 
                      onClick={() => setShowWorkbookDropdown(!showWorkbookDropdown)}
                      className="h-full px-2 text-gray-500 hover:text-indigo-600">
                      <ChevronDown size={16} />
                    </button>
                  </div>
                  {/* Workbook tab dropdown */}
                  {showWorkbookDropdown && (
                    <div 
                      ref={workbookDropdownRef}
                      className="absolute right-2 top-12 bg-white shadow-lg border border-gray-200 rounded-md z-10">
                      <div className="py-1">
                        {workbookTabs.map((tab) => (
                          <button
                            key={tab.id}
                            onClick={() => {
                              setActiveWorkbookTab(tab.id);
                              setShowWorkbookDropdown(false);
                            }}
                            className={`flex items-center w-full text-left px-4 py-2 text-sm ${
                              activeWorkbookTab === tab.id
                                ? 'bg-indigo-50 text-indigo-700'
                                : 'text-gray-700 hover:bg-gray-100'
                            }`}
                          >
                            <span className="mr-2">{tab.icon}</span>
                            {tab.label}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </div>
              
              {/* Workbook content area */}
              <div className="flex-1 overflow-auto">
                {getActiveWorkbookComponent()}
              </div>
            </>
          )}
        </div>
      </div>
      
      {/* Learning materials modal */}
      {activeMaterial && (
        <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50">
          <div className="bg-white rounded-lg max-w-3xl max-h-[80vh] w-full overflow-hidden">
            <div className="p-4 border-b border-gray-200 flex justify-between items-center">
              <h3 className="font-medium text-lg">{activeMaterial.title}</h3>
              <button
                onClick={() => setActiveMaterial(null)}
                className="p-1 rounded-full hover:bg-gray-100"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                </svg>
              </button>
            </div>
            <div className="p-4 overflow-y-auto max-h-[calc(80vh-8rem)]">
              <ReactMarkdown>{activeMaterial.content}</ReactMarkdown>
            </div>
            <div className="p-4 border-t border-gray-200 flex justify-end">
              <button
                onClick={() => setActiveMaterial(null)}
                className="px-4 py-2 bg-blue-600 text-white rounded"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default CoachingSessionPage;


================================================================================
# FILE: client\pages\coaching\index.js
# EXTENSION: .js
================================================================================
// client/pages/coaching/index.js
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../../contexts/AuthContext';
import { ArrowRight, School } from 'lucide-react';
import Sidebar from '../../components/Sidebar';
import { getCoachingProblems, startCoachingSession } from '../../utils/api';
import Cookies from 'js-cookie';

export default function CoachingIndexPage() {
  const router = useRouter();
  const { isAuthenticated, isLoading } = useAuth();
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [startingSession, setStartingSession] = useState(false);

  useEffect(() => {
    console.log('Coaching page auth state:', {
      isAuthenticated,
      isLoading,
      hasCookie: !!Cookies.get('auth_token'),
      cookieValue: Cookies.get('auth_token')?.substring(0, 20) + '...'
    });
    
    if (!isLoading && !isAuthenticated) {
      console.log('Redirecting to login - not authenticated');
      router.push('/auth/login');
      return;
    }

    if (isAuthenticated) {
      fetchProblems();
    }
  }, [isAuthenticated, isLoading, router]);

  const fetchProblems = async () => {
    try {
      setLoading(true);
      const data = await getCoachingProblems();
      
      console.log("Coaching problems response:", data);
      
      // Check if data is an array (direct response) or has a problems property
      if (Array.isArray(data)) {
        setProblems(data);
      } else if (data && data.problems) {
        setProblems(data.problems);
      } else {
        console.error("Invalid data format:", data);
      }
    } catch (error) {
      console.error('Error fetching coaching problems:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleStartSession = async (problemId) => {
    try {
      setStartingSession(true);
      // For debugging
      console.log('Starting session for problem:', problemId);
      console.log('startCoachingSession function:', startCoachingSession);
      
      const response = await startCoachingSession(problemId);
      console.log('Start session response:', response);
      
      if (response && response.session && response.session._id) {
        router.push(`/coaching/${response.session._id}`);
      } else if (response && response.id) {
        router.push(`/coaching/${response.id}`);
      } else if (response) {
        const id = response._id || response.sessionId || response.id || problemId;
        router.push(`/coaching/${id}`);
      } else {
        console.error('Invalid response format:', response);
      }
    } catch (error) {
      console.error('Error starting coaching session:', error);
      // Optionally, add user feedback here
      alert('Failed to start coaching session. Please try again.');
    } finally {
      setStartingSession(false);
    }
  };

  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeTab="coaching" />
      
      <div className="flex-1 overflow-auto p-6">
        <div className="mb-8">
          <h1 className="text-2xl font-bold text-gray-900">System Design Coach</h1>
          <p className="text-gray-600 mt-1">Learn system design concepts with guided coaching sessions.</p>
        </div>
        
        {loading ? (
          <div className="flex justify-center mt-12">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {problems.length > 0 ? (
              problems.map(problem => (
                <div 
                  key={problem.id} 
                  className="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden hover:shadow-md transition-shadow"
                >
                  <div className="p-6">
                    <div className="flex items-start justify-between mb-2">
                      <h3 className="text-lg font-semibold text-gray-900">{problem.title}</h3>
                      <span className={`px-2 py-1 rounded text-xs font-medium ${
                        problem.difficulty === 'beginner' ? 'bg-green-100 text-green-800' :
                        problem.difficulty === 'intermediate' ? 'bg-blue-100 text-blue-800' :
                        'bg-purple-100 text-purple-800'
                      }`}>
                        {problem.difficulty}
                      </span>
                    </div>
                    <p className="text-gray-600 text-sm mb-4 line-clamp-2">{problem.description || 'Practice your system design skills with this problem.'}</p>
                    <div className="flex items-center justify-between mt-4">
                      <div className="flex items-center text-sm text-gray-500">
                        <School className="h-4 w-4 mr-1" />
                        <span>{problem.estimatedTime || 30} mins</span>
                      </div>
                      <button
                        onClick={() => handleStartSession(problem.id)}
                        disabled={startingSession}
                        className="flex items-center text-green-600 hover:text-green-800 text-sm font-medium"
                      >
                        Start learning
                        <ArrowRight className="h-4 w-4 ml-1" />
                      </button>
                    </div>
                  </div>
                </div>
              ))
            ) : (
              <div className="col-span-3 bg-white p-6 rounded-lg shadow text-center">
                <p className="text-gray-600">No coaching problems found. Please check back later.</p>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\dashboard.js
# EXTENSION: .js
================================================================================
import Link from 'next/link';
import Sidebar from '../components/Sidebar';
import MetricCard from '../components/MetricCard';
import { Activity, Users, BookOpen, Bookmark, BarChart2 } from 'lucide-react';

export default function Dashboard({ onSelectWorkbook }) {
  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeTab="dashboard" />
      <div className="flex-1 overflow-auto p-6">
        <div className="mb-8">
          <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
          <p className="text-gray-600 mt-1">View your system design practice statistics</p>
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
          <MetricCard 
            title="Sessions Completed" 
            value="12"
            icon={<Activity className="h-6 w-6 text-white" />}
            iconBgColor="bg-blue-500"
            progress={60}
            subtext="20 sessions total"
          />
          <MetricCard 
            title="Hours Practiced" 
            value="24.5"
            icon={<BookOpen className="h-6 w-6 text-white" />}
            iconBgColor="bg-green-500"
            progress={75}
            subtext="Target: 30 hours"
          />
          <MetricCard 
            title="Avg. Score" 
            value="8.4"
            icon={<BarChart2 className="h-6 w-6 text-white" />}
            iconBgColor="bg-purple-500"
            progress={84}
            subtext="Out of 10"
          />
          <MetricCard 
            title="Designs Saved" 
            value="7"
            icon={<Bookmark className="h-6 w-6 text-white" />}
            iconBgColor="bg-orange-500"
            subtext="3 shared with community"
          />
        </div>
        
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-8">
          <h2 className="text-lg font-semibold mb-4">Continue Your Learning</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <button 
              onClick={onSelectWorkbook}
              className="flex items-center p-4 border border-indigo-200 rounded-lg bg-indigo-50 text-indigo-700 hover:bg-indigo-100"
            >
              <div className="rounded-full bg-indigo-100 p-3 mr-4">
                <BookOpen className="h-6 w-6 text-indigo-600" />
              </div>
              <div>
                <h3 className="font-medium">System Design Workbook</h3>
                <p className="text-sm text-indigo-600">Create structured system designs</p>
              </div>
            </button>
            
            <Link href="/interviews">
              <div className="flex items-center p-4 border border-green-200 rounded-lg bg-green-50 text-green-700 hover:bg-green-100 cursor-pointer">
                <div className="rounded-full bg-green-100 p-3 mr-4">
                  <Users className="h-6 w-6 text-green-600" />
                </div>
                <div>
                  <h3 className="font-medium">Practice Interviews</h3>
                  <p className="text-sm text-green-600">Simulate real interviews</p>
                </div>
              </div>
            </Link>
          </div>
        </div>
        
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <h2 className="text-lg font-semibold mb-4">Recent Activity</h2>
          <div className="space-y-4">
            <div className="flex items-start border-b border-gray-100 pb-4">
              <div className="rounded-full bg-blue-100 p-2 mr-4">
                <Activity className="h-5 w-5 text-blue-600" />
              </div>
              <div>
                <h3 className="font-medium">Completed Practice Interview</h3>
                <p className="text-sm text-gray-600">You scored 8.5/10 on "Design Twitter"</p>
                <p className="text-xs text-gray-500 mt-1">2 days ago</p>
              </div>
            </div>
            <div className="flex items-start border-b border-gray-100 pb-4">
              <div className="rounded-full bg-purple-100 p-2 mr-4">
                <BookOpen className="h-5 w-5 text-purple-600" />
              </div>
              <div>
                <h3 className="font-medium">Completed System Design</h3>
                <p className="text-sm text-gray-600">You created "URL Shortener" design</p>
                <p className="text-xs text-gray-500 mt-1">3 days ago</p>
              </div>
            </div>
            <div className="flex items-start">
              <div className="rounded-full bg-green-100 p-2 mr-4">
                <Bookmark className="h-5 w-5 text-green-600" />
              </div>
              <div>
                <h3 className="font-medium">Saved Design Template</h3>
                <p className="text-sm text-gray-600">You saved "E-commerce Platform" template</p>
                <p className="text-xs text-gray-500 mt-1">5 days ago</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\DataModelPage.js
# EXTENSION: .js
================================================================================
import React, { useState } from 'react';
import { MessageSquare, Save, PenTool } from 'lucide-react';

const EnhancedDataModelPage = ({ data = {}, updateData }) => {
  const [formState, setFormState] = useState({
    entities: data.entities || '',
    relationships: data.relationships || '',
    databaseChoice: data.databaseChoice || '',
    schemaDesign: data.schemaDesign || '',
    caching: data.caching || ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    const newState = { ...formState, [name]: value };
    setFormState(newState);
    
    if (updateData) {
      updateData(newState);
    }
  };

  return (
    <div className="flex flex-col h-full bg-white">
      <div className="flex-1 overflow-auto p-6 space-y-8">
        {/* Coach tip box */}
        <div className="bg-purple-50 border border-purple-100 rounded-md p-4 text-sm text-purple-700">
          <strong className="font-medium">Coach tip:</strong> Start by identifying key entities and their attributes. Consider database selection based on access patterns, not just data volume.
        </div>
        
        <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-lg font-semibold text-gray-800">Data Model</h2>
            <button 
              className="text-purple-600 hover:text-purple-800 text-sm font-medium flex items-center"
              onClick={() => {/* Add diagram functionality */}}
            >
              <PenTool size={14} className="mr-1" />
              Add ER diagram
            </button>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Key Entities
            </label>
            <textarea
              name="entities"
              value={formState.entities}
              onChange={handleChange}
              rows={4}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500 text-sm"
              placeholder="List main data entities and their attributes..."
            />
          </div>
          
          <div className="mt-4">
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Entity Relationships
            </label>
            <textarea
              name="relationships"
              value={formState.relationships}
              onChange={handleChange}
              rows={4}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500 text-sm"
              placeholder="Define relationships between entities (1:1, 1:N, M:N)..."
            />
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Database Selection
              </label>
              <textarea
                name="databaseChoice"
                value={formState.databaseChoice}
                onChange={handleChange}
                rows={3}
                className="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500 text-sm"
                placeholder="SQL vs NoSQL, specific database technologies..."
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Schema Design
              </label>
              <textarea
                name="schemaDesign"
                value={formState.schemaDesign}
                onChange={handleChange}
                rows={3}
                className="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500 text-sm"
                placeholder="Tables/collections structure, indexes..."
              />
            </div>
          </div>
          
          <div className="mt-4">
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Caching Strategy
            </label>
            <textarea
              name="caching"
              value={formState.caching}
              onChange={handleChange}
              rows={3}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500 text-sm"
              placeholder="Cache layers, TTL policies, invalidation strategies..."
            />
          </div>

          <div className="mt-6 p-4 bg-gray-100 rounded-md border border-gray-200">
            <h3 className="text-sm font-semibold text-gray-700 mb-2">Database Selection Guide</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
              <div className="border border-gray-300 rounded-md p-2 bg-white hover:bg-purple-50 cursor-pointer">
                <div className="font-medium mb-1 text-purple-700">Relational (SQL)</div>
                <p className="text-gray-600 text-xs">Good for structured data with well-defined schemas and complex relationships. ACID compliance, strong consistency.</p>
              </div>
              <div className="border border-gray-300 rounded-md p-2 bg-white hover:bg-purple-50 cursor-pointer">
                <div className="font-medium mb-1 text-purple-700">Document (NoSQL)</div>
                <p className="text-gray-600 text-xs">Flexible schema, good for semi-structured data, easier horizontal scaling. Examples: MongoDB, Firestore.</p>
              </div>
              <div className="border border-gray-300 rounded-md p-2 bg-white hover:bg-purple-50 cursor-pointer">
                <div className="font-medium mb-1 text-purple-700">Key-Value (NoSQL)</div>
                <p className="text-gray-600 text-xs">Simple data model, high throughput, low latency. Good for caching, session stores. Examples: Redis, DynamoDB.</p>
              </div>
              <div className="border border-gray-300 rounded-md p-2 bg-white hover:bg-purple-50 cursor-pointer">
                <div className="font-medium mb-1 text-purple-700">Graph (NoSQL)</div>
                <p className="text-gray-600 text-xs">Optimized for complex relationships and network structures. Examples: Neo4j, Neptune.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      {/* Footer with actions */}
      <div className="border-t border-gray-200 p-4 flex justify-between">
        <button className="flex items-center px-4 py-2 text-sm bg-purple-50 text-purple-700 rounded-md hover:bg-purple-100 transition-colors">
          <MessageSquare size={16} className="mr-2" />
          Ask Coach
        </button>
        <button className="flex items-center px-4 py-2 text-sm bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors shadow-sm">
          <Save size={16} className="mr-2" />
          Save & Continue
        </button>
      </div>
    </div>
  );
};

export default EnhancedDataModelPage;


================================================================================
# FILE: client\pages\index.js
# EXTENSION: .js
================================================================================
import React, { useState } from 'react';
import Dashboard from './dashboard';
import WorkbookLayout from './WorkbookLayout';

export default function Home() {
  const [view, setView] = useState('dashboard');
  
  if (view === 'workbook') {
    return <WorkbookLayout onBack={() => setView('dashboard')} />;
  }
  
  return <Dashboard onSelectWorkbook={() => setView('workbook')} />;
}


================================================================================
# FILE: client\pages\interviews\[id].js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../../contexts/AuthContext';
import { Clock, Send, Clipboard } from 'lucide-react';
import Sidebar from '../../components/Sidebar';
import { getInterview, sendInterviewMessage, completeInterview as completeInterviewApi } from '../../utils/api';

export default function InterviewPage() {
  const router = useRouter();
  const { id } = router.query;
  const { isAuthenticated, user } = useAuth();
  const [interview, setInterview] = useState(null);
  const [message, setMessage] = useState('');
  const [loading, setLoading] = useState(true);
  const [sending, setSending] = useState(false);
  const [timeRemaining, setTimeRemaining] = useState(null);
  const messagesEndRef = useRef(null);
  const timerRef = useRef(null);

  // Fetch interview data when component mounts or ID changes
  useEffect(() => {
    if (!isAuthenticated) {
      router.push('/auth/login');
      return;
    }

    if (id) {
      console.log("Fetching interview with ID:", id);
      fetchInterview();
    }
  }, [id, isAuthenticated, router]);

  // Set up timer to update time remaining
  useEffect(() => {
    if (interview?.startTime) {
      const intervalId = setInterval(updateTimeRemaining, 1000);
      return () => clearInterval(intervalId);
    }
  }, [interview]);

  // Auto-scroll to bottom of messages when conversation updates
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [interview?.conversation]);

  // Function to fetch interview data from API
  const fetchInterview = async () => {
    try {
      setLoading(true);
      // Make API call to get interview data
      console.log("Making API call to get interview:", id);
      const data = await getInterview(id);
      console.log("Received interview data:", data);
      
      // If we get valid data, use it
      if (data && data.interview) {
        setInterview(data.interview);
      } else {
        // Otherwise, use a mock interview for development
        console.log("Using mock interview data");
        setInterview({
          id: id,
          problemId: "url-shortener",
          status: "in_progress",
          currentStage: "introduction",
          startTime: new Date().toISOString(),
          timeLimit: 45,
          conversation: [
            {
              role: "interviewer",
              content: "Welcome to your system design interview. Today I'd like you to design a URL shortener service like TinyURL or bit.ly. We have about 45 minutes for this discussion. Could you start by telling me how you understand this problem and what key requirements we should consider?",
              stage: "introduction",
              timestamp: new Date().toISOString()
            }
          ]
        });
      }
      
      updateTimeRemaining();
    } catch (error) {
      console.error('Error fetching interview:', error);
      
      // Even on error, provide mock data so the UI works
      setInterview({
        id: id,
        problemId: "url-shortener",
        status: "in_progress",
        currentStage: "introduction",
        startTime: new Date().toISOString(),
        timeLimit: 45,
        conversation: [
          {
            role: "interviewer",
            content: "Welcome to your system design interview. Today I'd like you to design a URL shortener service like TinyURL or bit.ly. We have about 45 minutes for this discussion. Could you start by telling me how you understand this problem and what key requirements we should consider?",
            stage: "introduction",
            timestamp: new Date().toISOString()
          }
        ]
      });
    } finally {
      setLoading(false);
    }
  };

  // Function to update time remaining in interview
  const updateTimeRemaining = () => {
    if (!interview?.startTime) return;
    
    // Calculate time remaining based on start time and time limit
    const startTime = new Date(interview.startTime).getTime();
    const timeLimit = interview.timeLimit * 60 * 1000; // convert minutes to ms
    const now = Date.now();
    const elapsed = now - startTime;
    const remaining = Math.max(0, timeLimit - elapsed);
    
    setTimeRemaining(remaining);
    
    // If time is up and interview is still in progress, automatically complete it
    if (remaining === 0 && interview.status === 'in_progress') {
      handleCompleteInterview();
    }
  };

  // Function to format milliseconds as minutes:seconds
  const formatTime = (ms) => {
    if (ms === null) return '--:--';
    
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  };

  // Function to handle sending a new message
  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!message.trim() || sending) return;
    
    try {
      setSending(true);
      
      // Immediately update UI with user's message for better UX
      const updatedInterview = {
        ...interview,
        conversation: [
          ...interview.conversation,
          {
            role: "candidate",
            content: message,
            stage: interview.currentStage,
            timestamp: new Date().toISOString()
          }
        ]
      };
      setInterview(updatedInterview);
      
      // Clear input field immediately
      setMessage('');
      
      // Then send to server and get response
      console.log("Sending message to interview:", id, message);
      const response = await sendInterviewMessage(id, message);
      
      if (response && response.interview) {
        setInterview(response.interview);
      } else {
        // If API fails, simulate a response
        setTimeout(() => {
          const mockedResponse = {
            ...updatedInterview,
            conversation: [
              ...updatedInterview.conversation,
              {
                role: "interviewer",
                content: "That's a good point. Could you elaborate more on how you would handle scaling this system to millions of users?",
                stage: updatedInterview.currentStage,
                timestamp: new Date().toISOString()
              }
            ]
          };
          setInterview(mockedResponse);
        }, 1000);
      }
    } catch (error) {
      console.error('Error sending message:', error);
      
      // On error, still provide a simulated response
      setTimeout(() => {
        const mockedResponse = {
          ...interview,
          conversation: [
            ...interview.conversation,
            {
              role: "interviewer",
              content: "Interesting approach. Let's talk about how you'd handle the database design for this system.",
              stage: interview.currentStage,
              timestamp: new Date().toISOString()
            }
          ]
        };
        setInterview(mockedResponse);
      }, 1000);
    } finally {
      setSending(false);
    }
  };

  // Function to handle completing the interview
  // FIXED: Renamed from completeInterview to handleCompleteInterview to avoid recursion
  const handleCompleteInterview = async () => {
    try {
      // Call the imported API function
      console.log("Completing interview:", id);
      const response = await completeInterviewApi(id);
      
      if (response && response.interview) {
        setInterview(response.interview);
      }
      
      // Navigate to results page
      router.push(`/interviews/results/${id}`);
    } catch (error) {
      console.error('Error completing interview:', error);
      
      // Even on error, navigate to results
      router.push(`/interviews/results/${id}`);
    }
  };

  // Show loading state
  if (loading) {
    return (
      <div className="flex h-screen">
        <Sidebar activeTab="interviews" />
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading interview...</p>
          </div>
        </div>
      </div>
    );
  }

  // Show error state if interview not found
  if (!interview) {
    return (
      <div className="flex h-screen">
        <Sidebar activeTab="interviews" />
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <p className="text-red-600 mb-4">Interview not found</p>
            <button 
              onClick={() => router.push('/interviews')}
              className="bg-indigo-600 text-white px-4 py-2 rounded"
            >
              Back to Interviews
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Main interview UI
  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeTab="interviews" />
      
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* Header section with timer and controls */}
        <div className="bg-white border-b border-gray-200 p-4 flex justify-between items-center">
          <div>
            <h1 className="text-xl font-semibold">{interview.problem?.title || 'System Design Interview'}</h1>
            <p className="text-sm text-gray-500">
              Current stage: <span className="font-medium capitalize">{interview.currentStage}</span>
            </p>
          </div>
          
          <div className="flex items-center space-x-4">
            <div className={`flex items-center space-x-2 px-3 py-1 rounded-full ${
              timeRemaining < 300000 ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'
            }`}>
              <Clock className="h-4 w-4" />
              <span className="font-mono font-medium">{formatTime(timeRemaining)}</span>
            </div>
            
            <button 
              onClick={handleCompleteInterview}
              className="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded text-sm"
            >
              End Interview
            </button>
          </div>
        </div>
        
        {/* Chat message area */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {interview.conversation.map((msg, index) => (
            <div 
              key={index} 
              className={`flex ${msg.role === 'interviewer' ? 'justify-start' : 'justify-end'}`}
            >
              <div className={`max-w-3xl rounded-lg p-4 ${
                msg.role === 'interviewer' 
                  ? 'bg-white border border-gray-200 text-gray-800' 
                  : 'bg-indigo-600 text-white'
              }`}>
                <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                {msg.role === 'interviewer' && (
                  <p className="text-xs text-gray-500 mt-1 capitalize">
                    {msg.stage} phase
                  </p>
                )}
              </div>
            </div>
          ))}
          <div ref={messagesEndRef} />
        </div>
        
        {/* Message input area */}
        <div className="bg-white border-t border-gray-200 p-4">
          <form onSubmit={handleSendMessage} className="flex space-x-4">
            <input
              type="text"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              placeholder="Type your response..."
              className="flex-1 border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              disabled={interview.status !== 'in_progress'}
            />
            <button
              type="submit"
              disabled={!message.trim() || sending || interview.status !== 'in_progress'}
              className="bg-indigo-600 text-white px-4 py-2 rounded-lg disabled:bg-indigo-300 flex items-center"
            >
              {sending ? (
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
              ) : (
                <>
                  <Send className="h-5 w-5 mr-2" />
                  Send
                </>
              )}
            </button>
          </form>
        </div>
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\interviews\index.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Sidebar from '../../components/Sidebar';
import { Activity, Clock, Users, BookOpen } from 'lucide-react';
import { useAuth } from '../../contexts/AuthContext';
import { getInterviewProblems, startInterview } from '../../utils/api';

export default function InterviewsPage() {
  const router = useRouter();
  const { isAuthenticated, isLoading } = useAuth();
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedProblem, setSelectedProblem] = useState(null);
  const [starting, setStarting] = useState(false);

  // Check authentication and fetch problems when component mounts
  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      router.push('/auth/login');
      return;
    }

    if (isAuthenticated) {
      fetchProblems();
    }
  }, [isAuthenticated, isLoading, router]);

  // Fetch problem data from API with debugging
  const fetchProblems = async () => {
    try {
      setLoading(true);
      const data = await getInterviewProblems();
      console.log("API Response:", data); // Debug the API response
      
      // Handle both possible data structures
      if (data && data.problems) {
        setProblems(data.problems);
      } else if (Array.isArray(data)) {
        setProblems(data);
      } else {
        // Fallback to hardcoded problems if API returns unexpected format
        setProblems([
          {
            id: "url-shortener",
            title: "Design a URL Shortener",
            difficulty: "intermediate",
            description: "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly.",
            estimatedTime: 45
          },
          {
            id: "social-feed",
            title: "Design a Social Media Feed",
            difficulty: "advanced",
            description: "Design a news feed system that can handle millions of users posting and viewing content in real-time.",
            estimatedTime: 60
          },
          {
            id: "distributed-cache",
            title: "Design a Distributed Cache",
            difficulty: "intermediate",
            description: "Design a distributed caching system that can scale to handle high traffic and provide fast access to frequently used data.",
            estimatedTime: 50
          }
        ]);
      }
    } catch (error) {
      console.error('Error fetching problems:', error);
      setError('Failed to load interview problems. Using demo problems instead.');
      
      // Set fallback problems on error
      setProblems([
        {
          id: "url-shortener",
          title: "Design a URL Shortener",
          difficulty: "intermediate",
          description: "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly.",
          estimatedTime: 45
        },
        {
          id: "social-feed",
          title: "Design a Social Media Feed",
          difficulty: "advanced",
          description: "Design a news feed system that can handle millions of users posting and viewing content in real-time.",
          estimatedTime: 60
        },
        {
          id: "distributed-cache",
          title: "Design a Distributed Cache",
          difficulty: "intermediate",
          description: "Design a distributed caching system that can scale to handle high traffic and provide fast access to frequently used data.",
          estimatedTime: 50
        }
      ]);
    } finally {
      setLoading(false);
    }
  };

  // Handle starting a new interview
  const handleStartInterview = async (problemId) => {
    try {
      setStarting(true);
      const response = await startInterview(problemId);
      
      // Determine the ID to use for navigation
      const interviewId = response?.interview?.id || "1";
      router.push(`/interviews/${interviewId}`);
    } catch (error) {
      console.error('Error starting interview:', error);
      setError('Failed to start interview. Please try again later.');
      
      // On error, still navigate to a demo interview
      router.push('/interviews/1');
      setStarting(false);
    }
  };

  // Show problem details when a card is clicked
  const openProblemDetails = (problem) => {
    setSelectedProblem(problem);
  };

  // Close the problem details modal
  const closeProblemDetails = () => {
    setSelectedProblem(null);
  };

  // Loading state while fetching problems
  if (isLoading || loading) {
    return (
      <div className="flex h-screen">
        <Sidebar activeTab="interviews" />
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading interview problems...</p>
          </div>
        </div>
      </div>
    );
  }

  // Now log the current problems to debug
  console.log("Problems state before render:", problems);

  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeTab="interviews" />
      
      <div className="flex-1 p-8 overflow-auto">
        <div className="max-w-7xl mx-auto">
          <div className="mb-8">
            <h1 className="text-2xl font-bold mb-2">Practice Interviews</h1>
            <p className="text-gray-600">
              Select a system design problem to start a simulated interview session. Each interview will guide you through the key aspects of system design.
            </p>
          </div>
          
          {error && (
            <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md mb-6">
              {error}
            </div>
          )}
          
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {problems && problems.length > 0 ? (
              // Map through actual problems if available
              problems.map((problem, index) => (
                <div 
                  key={problem.id || index}
                  className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 hover:shadow-md transition-shadow cursor-pointer"
                  onClick={() => openProblemDetails(problem)}
                >
                  <div className="flex justify-between items-start mb-4">
                    <h3 className="text-lg font-semibold">{problem.title}</h3>
                    <span className={`text-xs px-2 py-1 rounded-full ${
                      problem.difficulty === 'beginner' ? 'bg-green-100 text-green-800' :
                      problem.difficulty === 'intermediate' ? 'bg-blue-100 text-blue-800' :
                      'bg-purple-100 text-purple-800'
                    }`}>
                      {problem.difficulty.charAt(0).toUpperCase() + problem.difficulty.slice(1)}
                    </span>
                  </div>
                  <p className="text-gray-600 text-sm mb-4 line-clamp-2">
                    {problem.description}
                  </p>
                  <div className="flex justify-between items-center text-sm text-gray-500">
                    <div className="flex items-center">
                      <Clock className="h-4 w-4 mr-1" />
                      <span>{problem.estimatedTime} minutes</span>
                    </div>
                    <span>Google, Amazon</span>
                  </div>
                </div>
              ))
            ) : (
              // Show placeholder cards if no problems found
              Array.from({ length: 3 }).map((_, index) => (
                <div 
                  key={index}
                  className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 hover:shadow-md transition-shadow cursor-pointer"
                  onClick={() => openProblemDetails({
                    id: index === 0 ? "url-shortener" : index === 1 ? "social-feed" : "distributed-cache",
                    title: index === 0 ? "Design a URL Shortener" : index === 1 ? "Design a Social Media Feed" : "Design a Distributed Cache",
                    difficulty: index === 0 ? "intermediate" : index === 1 ? "advanced" : "intermediate",
                    description: index === 0 
                      ? "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly." 
                      : index === 1 
                      ? "Design a news feed system that can handle millions of users posting and viewing content in real-time." 
                      : "Design a distributed caching system that can scale to handle high traffic and provide fast access to frequently used data.",
                    estimatedTime: index === 0 ? 45 : index === 1 ? 60 : 50
                  })}
                >
                  <div className="flex justify-between items-start mb-4">
                    <h3 className="text-lg font-semibold">
                      {index === 0 ? "Design a URL Shortener" : 
                      index === 1 ? "Design a Social Media Feed" : 
                      "Design a Distributed Cache"}
                    </h3>
                    <span className="text-xs px-2 py-1 rounded-full bg-blue-100 text-blue-800">
                      {index === 0 ? "Intermediate" : index === 1 ? "Advanced" : "Intermediate"}
                    </span>
                  </div>
                  <p className="text-gray-600 text-sm mb-4">
                    {index === 0 ? "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly." :
                    index === 1 ? "Design a news feed system that can handle millions of users posting and viewing content in real-time." :
                    "Design a distributed caching system that can scale to handle high traffic and provide fast access to frequently used data."}
                  </p>
                  <div className="flex justify-between items-center text-sm text-gray-500">
                    <div className="flex items-center">
                      <Clock className="h-4 w-4 mr-1" />
                      <span>{index === 0 ? "45" : index === 1 ? "60" : "50"} minutes</span>
                    </div>
                    <span>{index === 0 ? "Google, Uber" : index === 1 ? "Facebook, Twitter" : "Amazon, Netflix"}</span>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </div>
      
      {/* Problem Detail Modal */}
      {selectedProblem && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-auto">
            <div className="p-6">
              <div className="flex justify-between items-start mb-4">
                <h2 className="text-xl font-bold">{selectedProblem.title}</h2>
                <span className={`text-xs px-2 py-1 rounded-full ${
                  selectedProblem.difficulty === 'beginner' ? 'bg-green-100 text-green-800' :
                  selectedProblem.difficulty === 'intermediate' ? 'bg-blue-100 text-blue-800' :
                  'bg-purple-100 text-purple-800'
                }`}>
                  {selectedProblem.difficulty.charAt(0).toUpperCase() + selectedProblem.difficulty.slice(1)}
                </span>
              </div>
              
              <p className="text-gray-600 mb-6">
                {selectedProblem.description}
              </p>
              
              <div className="grid grid-cols-2 gap-4 mb-6">
                <div className="bg-gray-50 p-4 rounded-lg">
                  <div className="flex items-center mb-2">
                    <Clock className="h-5 w-5 text-gray-400 mr-2" />
                    <span className="font-medium">Duration</span>
                  </div>
                  <p className="text-gray-600">{selectedProblem.estimatedTime} minutes</p>
                </div>
                
                <div className="bg-gray-50 p-4 rounded-lg">
                  <div className="flex items-center mb-2">
                    <Activity className="h-5 w-5 text-gray-400 mr-2" />
                    <span className="font-medium">Focus Areas</span>
                  </div>
                  <p className="text-gray-600">Scalability, Data modeling, APIs</p>
                </div>
              </div>
              
              <div className="mb-6">
                <h3 className="font-medium mb-2">Interview Guidance</h3>
                <ul className="text-gray-600 space-y-2">
                  <li> Think out loud throughout the interview</li>
                  <li> Ask clarifying questions before diving into solutions</li>
                  <li> Consider trade-offs in your design decisions</li>
                  <li> Focus on high-level architecture first, then dive deeper</li>
                </ul>
              </div>
              
              <div className="flex space-x-3">
                <button
                  onClick={closeProblemDetails}
                  className="flex-1 px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
                >
                  Cancel
                </button>
                <button
                  onClick={() => handleStartInterview(selectedProblem.id)}
                  disabled={starting}
                  className="flex-1 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 disabled:bg-indigo-300"
                >
                  {starting ? 'Starting...' : 'Start Interview'}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}


================================================================================
# FILE: client\pages\interviews\results\[id].js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../../../contexts/AuthContext';
import { 
  CheckCircle, 
  XCircle, 
  AlertCircle, 
  Award, 
  BarChart2,
  MessageSquare,
  Clock
} from 'lucide-react';
import Sidebar from '../../../components/Sidebar';
import { getInterviewResults } from '../../../utils/api';

export default function InterviewResultsPage() {
  const router = useRouter();
  const { id } = router.query;
  const { isAuthenticated } = useAuth();
  const [results, setResults] = useState(null);
  const [conversation, setConversation] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [activeTab, setActiveTab] = useState('summary');

  // Fetch results when component mounts
  useEffect(() => {
    if (!isAuthenticated) {
      router.push('/auth/login');
      return;
    }

    if (id) {
      console.log("Fetching results for interview:", id);
      fetchResults();
    }
  }, [id, isAuthenticated, router]);

  // Function to fetch interview results
  const fetchResults = async () => {
    try {
      setLoading(true);
      
      // Make API call to get results
      console.log("Making API call to get results:", id);
      const data = await getInterviewResults(id);
      console.log("Received results data:", data);
      
      // If we get valid data, use it
      if (data && data.results) {
        setResults(data.results);
        setConversation(data.conversation || []);
      } else {
        // Otherwise, use mock results for development
        console.log("Using mock results data");
        setResults({
          requirementsScore: 8,
          scaleEstimationScore: 7,
          architectureScore: 8,
          componentDesignScore: 7,
          tradeoffsScore: 6,
          communicationScore: 9,
          overallScore: 7.5,
          feedback: "You did a good job of identifying key requirements and proposing a reasonable architecture. Your communication was clear and structured. To improve, consider exploring more trade-offs and edge cases in your design. You might also want to think more about how to handle very large scale scenarios, particularly around database sharding and caching strategies."
        });
        
        // Set mock conversation if needed
        if (!data || !data.conversation) {
          setConversation([
            {
              role: "interviewer",
              content: "Welcome to your system design interview. Today I'd like you to design a URL shortener service like TinyURL or bit.ly. We have about 45 minutes for this discussion. Could you start by telling me how you understand this problem and what key requirements we should consider?",
              stage: "introduction",
              timestamp: new Date(Date.now() - 3600000).toISOString()
            },
            {
              role: "candidate",
              content: "I understand that we need to design a service that takes long URLs and creates shorter ones that redirect to the original URL when accessed. Key requirements would include the ability to generate unique short URLs, redirect efficiently, handle high traffic, and ensure the system is scalable and reliable.",
              stage: "introduction",
              timestamp: new Date(Date.now() - 3540000).toISOString()
            },
            {
              role: "interviewer",
              content: "Great start! Let's focus on clarifying the requirements. What functional and non-functional requirements do you think are important for a URL shortening service?",
              stage: "requirements",
              timestamp: new Date(Date.now() - 3500000).toISOString()
            }
          ]);
        }
      }
    } catch (error) {
      console.error('Error fetching results:', error);
      setError('Failed to load interview results. Please try again later.');
      
      // Use mock data even on error
      setResults({
        requirementsScore: 8,
        scaleEstimationScore: 7,
        architectureScore: 8,
        componentDesignScore: 7,
        tradeoffsScore: 6,
        communicationScore: 9,
        overallScore: 7.5,
        feedback: "You did a good job of identifying key requirements and proposing a reasonable architecture. Your communication was clear and structured. To improve, consider exploring more trade-offs and edge cases in your design."
      });
    } finally {
      setLoading(false);
    }
  };

  // Function to determine color based on score
  const getScoreColor = (score) => {
    if (score >= 8) return 'text-green-600';
    if (score >= 6) return 'text-yellow-600';
    return 'text-red-600';
  };

  // Function to get appropriate icon based on score
  const getScoreIcon = (score) => {
    if (score >= 8) return <CheckCircle className="h-5 w-5 text-green-600" />;
    if (score >= 6) return <AlertCircle className="h-5 w-5 text-yellow-600" />;
    return <XCircle className="h-5 w-5 text-red-600" />;
  };

  // Show loading state
  if (loading) {
    return (
      <div className="flex h-screen">
        <Sidebar activeTab="interviews" />
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading interview results...</p>
          </div>
        </div>
      </div>
    );
  }

  // Show error state
  if (error || !results) {
    return (
      <div className="flex h-screen">
        <Sidebar activeTab="interviews" />
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <p className="text-red-600 mb-4">{error || 'Results not found'}</p>
            <button 
              onClick={() => router.push('/interviews')}
              className="bg-indigo-600 text-white px-4 py-2 rounded"
            >
              Back to Interviews
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Main results UI
  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeTab="interviews" />
      
      <div className="flex-1 overflow-auto">
        <div className="max-w-7xl mx-auto p-6">
          <div className="mb-6">
            <h1 className="text-2xl font-bold mb-2">Interview Results</h1>
            <p className="text-gray-600">
              Review your performance and feedback from your system design interview.
            </p>
          </div>
          
          {/* Results summary card */}
          <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
            <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between mb-6">
              <div>
                <h2 className="text-xl font-bold mb-1">Overall Performance</h2>
                <p className="text-gray-600">
                  Your interview assessment and detailed feedback
                </p>
              </div>
              
              <div className="mt-4 lg:mt-0 flex items-center">
                <div className="flex items-center justify-center h-16 w-16 rounded-full bg-indigo-50 mr-4">
                  <span className="text-2xl font-bold text-indigo-600">
                    {results.overallScore}
                  </span>
                </div>
                <div>
                  <p className="font-medium">Overall Score</p>
                  <p className="text-sm text-gray-500">Out of 10</p>
                </div>
              </div>
            </div>
            
            {/* Detailed scores grid */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.requirementsScore)}
                </div>
                <div>
                  <p className="font-medium">Requirements Gathering</p>
                  <p className={`${getScoreColor(results.requirementsScore)} font-medium`}>
                    {results.requirementsScore}/10
                  </p>
                </div>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.scaleEstimationScore)}
                </div>
                <div>
                  <p className="font-medium">Scale Estimation</p>
                  <p className={`${getScoreColor(results.scaleEstimationScore)} font-medium`}>
                    {results.scaleEstimationScore}/10
                  </p>
                </div>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.architectureScore)}
                </div>
                <div>
                  <p className="font-medium">Architecture Design</p>
                  <p className={`${getScoreColor(results.architectureScore)} font-medium`}>
                    {results.architectureScore}/10
                  </p>
                </div>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.componentDesignScore)}
                </div>
                <div>
                  <p className="font-medium">Component Design</p>
                  <p className={`${getScoreColor(results.componentDesignScore)} font-medium`}>
                    {results.componentDesignScore}/10
                  </p>
                </div>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.tradeoffsScore)}
                </div>
                <div>
                  <p className="font-medium">Trade-offs Analysis</p>
                  <p className={`${getScoreColor(results.tradeoffsScore)} font-medium`}>
                    {results.tradeoffsScore}/10
                  </p>
                </div>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.communicationScore)}
                </div>
                <div>
                  <p className="font-medium">Communication</p>
                  <p className={`${getScoreColor(results.communicationScore)} font-medium`}>
                    {results.communicationScore}/10
                  </p>
                </div>
              </div>
            </div>
            
            {/* Feedback section */}
            <div className="mb-6">
              <h3 className="font-medium mb-3">Detailed Feedback</h3>
              <div className="bg-gray-50 p-4 rounded-lg">
                <p className="text-gray-700 whitespace-pre-line">
                  {results.feedback}
                </p>
              </div>
            </div>
            
            {/* Action buttons */}
            <div className="flex flex-wrap gap-3 border-t pt-6">
              <button
                onClick={() => router.push('/interviews')}
                className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700"
              >
                Practice Another Problem
              </button>
              
              <button
                onClick={() => setActiveTab('conversation')}
                className="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
              >
                Review Conversation
              </button>
            </div>
          </div>
          
          {/* Conversation review tab */}
          {activeTab === 'conversation' && (
            <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
              <h2 className="text-xl font-bold mb-4">Interview Conversation</h2>
              
              <div className="space-y-4">
                {conversation.map((msg, index) => (
                  <div 
                    key={index} 
                    className={`flex ${msg.role === 'interviewer' ? 'justify-start' : 'justify-end'}`}
                  >
                    <div className={`max-w-3xl rounded-lg p-4 ${
                      msg.role === 'interviewer' 
                        ? 'bg-gray-50 border border-gray-200 text-gray-800' 
                        : 'bg-indigo-50 border border-indigo-200 text-gray-800'
                    }`}>
                      <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                      <p className="text-xs text-gray-500 mt-2">
                        {msg.role === 'interviewer' ? 'Interviewer' : 'You'}  {msg.stage} stage
                      </p>
                    </div>
                  </div>
                ))}
              </div>
              
              <div className="mt-6">
                <button
                  onClick={() => setActiveTab('summary')}
                  className="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
                >
                  Back to Results
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\ReliabilitySecurityPage.js
# EXTENSION: .js
================================================================================
import React, { useState } from 'react';
import { MessageSquare, Save, ChevronDown, ChevronUp, Plus, Trash2, Shield, Activity, PenTool } from 'lucide-react';

const ReliabilitySecurityPage = ({ data = {}, updateData }) => {
  // Reliability state
  const [reliabilityTargets, setReliabilityTargets] = useState(
    data.reliabilityTargets ? JSON.parse(data.reliabilityTargets) : [
      { id: 1, metric: 'Availability', target: '99.9', unit: '%', notes: 'Maximum 8.76 hours downtime per year' },
      { id: 2, metric: 'Response Time', target: '200', unit: 'ms', notes: 'P95 latency' }
    ]
  );
  
  const [failureScenarios, setFailureScenarios] = useState(
    data.failureScenarios ? JSON.parse(data.failureScenarios) : [
      { id: 1, component: '', scenario: '', mitigation: '' }
    ]
  );
  
  // Security state
  const [authMethods, setAuthMethods] = useState(
    data.authMethods ? JSON.parse(data.authMethods) : {
      jwt: false,
      oauth: false,
      apiKey: false,
      sessionCookie: false,
      custom: false,
      customDetails: ''
    }
  );
  
  const [dataProtection, setDataProtection] = useState(
    data.dataProtection ? JSON.parse(data.dataProtection) : {
      encryption: {
        inTransit: false,
        atRest: false,
        endToEnd: false,
        notes: ''
      },
      accessControl: {
        rbac: false,
        acl: false,
        customPolicy: false,
        notes: ''
      }
    }
  );
  
  const [securityMeasures, setSecurityMeasures] = useState(
    data.securityMeasures ? JSON.parse(data.securityMeasures) : [
      { id: 1, type: 'Input Validation', implemented: false, details: '' }
    ]
  );
  
  const [complianceRequirements, setComplianceRequirements] = useState(
    data.complianceRequirements ? JSON.parse(data.complianceRequirements) : [
      { id: 1, standard: '', requirements: '', implemented: false }
    ]
  );
  
  // Reliability section handlers
  const addReliabilityTarget = () => {
    const newId = reliabilityTargets.length > 0 
      ? Math.max(...reliabilityTargets.map(t => t.id)) + 1 
      : 1;
    
    const updatedTargets = [
      ...reliabilityTargets,
      { id: newId, metric: '', target: '', unit: '', notes: '' }
    ];
    setReliabilityTargets(updatedTargets);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        reliabilityTargets: JSON.stringify(updatedTargets)
      });
    }
  };
  
  const updateReliabilityTarget = (id, field, value) => {
    const updatedTargets = reliabilityTargets.map(target => 
      target.id === id ? { ...target, [field]: value } : target
    );
    setReliabilityTargets(updatedTargets);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        reliabilityTargets: JSON.stringify(updatedTargets)
      });
    }
  };
  
  const removeReliabilityTarget = (id) => {
    const updatedTargets = reliabilityTargets.filter(target => target.id !== id);
    setReliabilityTargets(updatedTargets);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        reliabilityTargets: JSON.stringify(updatedTargets)
      });
    }
  };
  
  const addFailureScenario = () => {
    const newId = failureScenarios.length > 0 
      ? Math.max(...failureScenarios.map(s => s.id)) + 1 
      : 1;
    
    const updatedScenarios = [
      ...failureScenarios,
      { id: newId, component: '', scenario: '', mitigation: '' }
    ];
    setFailureScenarios(updatedScenarios);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        failureScenarios: JSON.stringify(updatedScenarios)
      });
    }
  };
  
  const updateFailureScenario = (id, field, value) => {
    const updatedScenarios = failureScenarios.map(scenario => 
      scenario.id === id ? { ...scenario, [field]: value } : scenario
    );
    setFailureScenarios(updatedScenarios);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        failureScenarios: JSON.stringify(updatedScenarios)
      });
    }
  };
  
  const removeFailureScenario = (id) => {
    const updatedScenarios = failureScenarios.filter(scenario => scenario.id !== id);
    setFailureScenarios(updatedScenarios);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        failureScenarios: JSON.stringify(updatedScenarios)
      });
    }
  };
  
  // Security section handlers
  const updateAuthMethod = (method, value) => {
    const updatedAuthMethods = {
      ...authMethods,
      [method]: value
    };
    setAuthMethods(updatedAuthMethods);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        authMethods: JSON.stringify(updatedAuthMethods)
      });
    }
  };
  
  const updateDataProtection = (category, field, value) => {
    const updatedDataProtection = {
      ...dataProtection,
      [category]: {
        ...dataProtection[category],
        [field]: value
      }
    };
    setDataProtection(updatedDataProtection);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        dataProtection: JSON.stringify(updatedDataProtection)
      });
    }
  };
  
  const addSecurityMeasure = () => {
    const newId = securityMeasures.length > 0 
      ? Math.max(...securityMeasures.map(m => m.id)) + 1 
      : 1;
    
    const updatedMeasures = [
      ...securityMeasures,
      { id: newId, type: '', implemented: false, details: '' }
    ];
    
    setSecurityMeasures(updatedMeasures);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        securityMeasures: JSON.stringify(updatedMeasures)
      });
    }
  };
  
  const updateSecurityMeasure = (id, field, value) => {
    const updatedMeasures = securityMeasures.map(measure => 
      measure.id === id ? { ...measure, [field]: value } : measure
    );
    setSecurityMeasures(updatedMeasures);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        securityMeasures: JSON.stringify(updatedMeasures)
      });
    }
  };
  
  const removeSecurityMeasure = (id) => {
    const updatedMeasures = securityMeasures.filter(measure => measure.id !== id);
    setSecurityMeasures(updatedMeasures);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        securityMeasures: JSON.stringify(updatedMeasures)
      });
    }
  };
  
  const addComplianceRequirement = () => {
    const newId = complianceRequirements.length > 0 
      ? Math.max(...complianceRequirements.map(r => r.id)) + 1 
      : 1;
    
    const updatedRequirements = [
      ...complianceRequirements,
      { id: newId, standard: '', requirements: '', implemented: false }
    ];
    
    setComplianceRequirements(updatedRequirements);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        complianceRequirements: JSON.stringify(updatedRequirements)
      });
    }
  };
  
  const updateComplianceRequirement = (id, field, value) => {
    const updatedRequirements = complianceRequirements.map(req => 
      req.id === id ? { ...req, [field]: value } : req
    );
    setComplianceRequirements(updatedRequirements);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        complianceRequirements: JSON.stringify(updatedRequirements)
      });
    }
  };
  
  const removeComplianceRequirement = (id) => {
    const updatedRequirements = complianceRequirements.filter(req => req.id !== id);
    setComplianceRequirements(updatedRequirements);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        complianceRequirements: JSON.stringify(updatedRequirements)
      });
    }
  };
  
  // UI state
  const [expandedSections, setExpandedSections] = useState(
    data.expandedSections ? JSON.parse(data.expandedSections) : {
      reliabilityTargets: true,
      failureScenarios: true,
      authMethods: true,
      dataProtection: true,
      securityMeasures: true,
      compliance: true
    }
  );
  
  const toggleSection = (section) => {
    const updatedSections = {
      ...expandedSections,
      [section]: !expandedSections[section]
    };
    setExpandedSections(updatedSections);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        expandedSections: JSON.stringify(updatedSections)
      });
    }
  };
  
  return (
    <div className="flex flex-col h-full bg-white">
      <div className="flex-1 overflow-auto p-6 space-y-8">
        {/* Coach tip box */}
        <div className="bg-red-50 border border-red-100 rounded-md p-4 text-sm text-red-700">
          <strong className="font-medium">Coach tip:</strong> Define specific reliability targets with measurable metrics and create comprehensive failure scenarios with detailed mitigation strategies.
        </div>
      
        {/* Reliability Section */}
        <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center">
              <Activity className="h-5 w-5 text-red-500 mr-2" />
              <h2 className="text-lg font-semibold text-gray-800">Reliability & Availability</h2>
            </div>
            <button 
              className="text-red-600 hover:text-red-800 text-sm font-medium flex items-center"
              onClick={() => {/* Add diagram functionality */}}
            >
              <PenTool size={14} className="mr-1" />
              Add diagram
            </button>
          </div>
          
          {/* Reliability Targets */}
          <div className="mb-6">
            <div 
              className="flex justify-between items-center cursor-pointer"
              onClick={() => toggleSection('reliabilityTargets')}
            >
              <h3 className="text-md font-medium text-gray-700">Reliability Targets</h3>
              {expandedSections.reliabilityTargets ? (
                <ChevronUp size={20} className="text-gray-500" />
              ) : (
                <ChevronDown size={20} className="text-gray-500" />
              )}
            </div>
            
            {expandedSections.reliabilityTargets && (
              <div className="mt-2 space-y-3">
                {reliabilityTargets.map(target => (
                  <div key={target.id} className="grid grid-cols-12 gap-2 items-center">
                    <div className="col-span-3">
                      <input
                        type="text"
                        value={target.metric}
                        onChange={(e) => updateReliabilityTarget(target.id, 'metric', e.target.value)}
                        placeholder="Metric"
                        className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                      />
                    </div>
                    <div className="col-span-2">
                      <div className="flex">
                        <input
                          type="text"
                          value={target.target}
                          onChange={(e) => updateReliabilityTarget(target.id, 'target', e.target.value)}
                          placeholder="Value"
                          className="w-full px-3 py-2 border border-gray-300 rounded-l text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                        />
                        <span className="bg-gray-100 px-3 py-2 border border-l-0 border-gray-300 rounded-r text-sm text-gray-500">
                          <input
                            type="text"
                            value={target.unit}
                            onChange={(e) => updateReliabilityTarget(target.id, 'unit', e.target.value)}
                            placeholder="unit"
                            className="w-10 bg-transparent border-none p-0 text-sm text-center focus:ring-0"
                          />
                        </span>
                      </div>
                    </div>
                    <div className="col-span-6">
                      <input
                        type="text"
                        value={target.notes}
                        onChange={(e) => updateReliabilityTarget(target.id, 'notes', e.target.value)}
                        placeholder="Notes"
                        className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                      />
                    </div>
                    <div className="col-span-1 flex justify-end">
                      <button 
                        onClick={() => removeReliabilityTarget(target.id)}
                        className="text-red-500 hover:text-red-700"
                      >
                        <Trash2 size={16} />
                      </button>
                    </div>
                  </div>
                ))}
                
                <button 
                  onClick={addReliabilityTarget}
                  className="flex items-center text-sm text-red-600 hover:text-red-800 font-medium"
                >
                  <Plus size={16} className="mr-1" />
                  Add Reliability Metric
                </button>
                
                <div className="text-xs text-gray-500 bg-gray-100 p-3 rounded mt-2">
                  <p className="font-medium mb-1">Common reliability targets:</p>
                  <ul className="list-disc list-inside space-y-1">
                    <li>Availability (uptime): 99.9% to 99.999%</li>
                    <li>Latency: P95, P99 response times</li>
                    <li>Error Rate: % of failed requests</li>
                    <li>Recovery Time (RTO/RPO): Minutes/hours/data loss limits</li>
                  </ul>
                </div>
              </div>
            )}
          </div>
          
          {/* Failure Scenarios */}
          <div>
            <div 
              className="flex justify-between items-center cursor-pointer"
              onClick={() => toggleSection('failureScenarios')}
            >
              <h3 className="text-md font-medium text-gray-700">Failure Scenarios & Mitigations</h3>
              {expandedSections.failureScenarios ? (
                <ChevronUp size={20} className="text-gray-500" />
              ) : (
                <ChevronDown size={20} className="text-gray-500" />
              )}
            </div>
            
            {expandedSections.failureScenarios && (
              <div className="mt-2 space-y-3">
                {failureScenarios.map(scenario => (
                  <div key={scenario.id} className="border border-gray-300 rounded-md p-3 bg-white shadow-sm">
                    <div className="grid grid-cols-12 gap-3">
                      <div className="col-span-4">
                        <label className="block text-xs font-medium text-gray-700 mb-1">Component/Service</label>
                        <input
                          type="text"
                          value={scenario.component}
                          onChange={(e) => updateFailureScenario(scenario.id, 'component', e.target.value)}
                          placeholder="Which component can fail?"
                          className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                        />
                      </div>
                      <div className="col-span-8">
                        <label className="block text-xs font-medium text-gray-700 mb-1">Failure Scenario</label>
                        <input
                          type="text"
                          value={scenario.scenario}
                          onChange={(e) => updateFailureScenario(scenario.id, 'scenario', e.target.value)}
                          placeholder="What could go wrong?"
                          className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                        />
                      </div>
                      <div className="col-span-12">
                        <label className="block text-xs font-medium text-gray-700 mb-1">Mitigation Strategy</label>
                        <textarea
                          value={scenario.mitigation}
                          onChange={(e) => updateFailureScenario(scenario.id, 'mitigation', e.target.value)}
                          placeholder="How will you handle this failure?"
                          className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                          rows="2"
                        />
                      </div>
                    </div>
                    <div className="flex justify-end mt-2">
                      <button 
                        onClick={() => removeFailureScenario(scenario.id)}
                        className="text-red-500 hover:text-red-700 text-sm flex items-center"
                      >
                        <Trash2 size={14} className="mr-1" />
                        Remove
                      </button>
                    </div>
                  </div>
                ))}
                
                <button 
                  onClick={addFailureScenario}
                  className="flex items-center text-sm text-red-600 hover:text-red-800 font-medium"
                >
                  <Plus size={16} className="mr-1" />
                  Add Failure Scenario
                </button>
                
                <div className="text-xs text-gray-500 bg-gray-100 p-3 rounded mt-2">
                  <p className="font-medium mb-1">Common failure scenarios to consider:</p>
                  <ul className="list-disc list-inside space-y-1">
                    <li>Service instance failure</li>
                    <li>Network partitions</li>
                    <li>Database unavailability</li>
                    <li>Region/zone outages</li>
                    <li>Dependency failures</li>
                    <li>Traffic spikes/DDoS</li>
                  </ul>
                </div>
              </div>
            )}
          </div>
        </div>
        
        {/* Security Section */}
        <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <div className="flex items-center mb-4">
            <Shield className="h-5 w-5 text-red-500 mr-2" />
            <h2 className="text-lg font-semibold text-gray-800">Security & Privacy</h2>
          </div>
          
          {/* Authentication Methods */}
          <div className="mb-6">
            <div 
              className="flex justify-between items-center cursor-pointer"
              onClick={() => toggleSection('authMethods')}
            >
              <h3 className="text-md font-medium text-gray-700">Authentication & Authorization</h3>
              {expandedSections.authMethods ? (
                <ChevronUp size={20} className="text-gray-500" />
              ) : (
                <ChevronDown size={20} className="text-gray-500" />
              )}
            </div>
            
            {expandedSections.authMethods && (
              <div className="mt-2 space-y-3">
                <div className="grid grid-cols-2 gap-3">
                  <div className="col-span-1">
                    <h4 className="text-sm font-medium text-gray-700 mb-2">Authentication Methods</h4>
                    <div className="space-y-2">
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={authMethods.jwt}
                          onChange={(e) => updateAuthMethod('jwt', e.target.checked)}
                          className="rounded text-red-600 focus:ring-red-500 mr-2"
                        />
                        <span className="text-sm">JWT Tokens</span>
                      </label>
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={authMethods.oauth}
                          onChange={(e) => updateAuthMethod('oauth', e.target.checked)}
                          className="rounded text-red-600 focus:ring-red-500 mr-2"
                        />
                        <span className="text-sm">OAuth 2.0</span>
                      </label>
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={authMethods.apiKey}
                          onChange={(e) => updateAuthMethod('apiKey', e.target.checked)}
                          className="rounded text-red-600 focus:ring-red-500 mr-2"
                        />
                        <span className="text-sm">API Keys</span>
                      </label>
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={authMethods.sessionCookie}
                          onChange={(e) => updateAuthMethod('sessionCookie', e.target.checked)}
                          className="rounded text-red-600 focus:ring-red-500 mr-2"
                        />
                        <span className="text-sm">Session Cookies</span>
                      </label>
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={authMethods.custom}
                          onChange={(e) => updateAuthMethod('custom', e.target.checked)}
                          className="rounded text-red-600 focus:ring-red-500 mr-2"
                        />
                        <span className="text-sm">Custom Solution</span>
                      </label>
                      
                      {authMethods.custom && (
                        <textarea
                          value={authMethods.customDetails}
                          onChange={(e) => updateAuthMethod('customDetails', e.target.value)}
                          placeholder="Describe your custom authentication method"
                          className="w-full mt-2 px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                          rows="2"
                        />
                      )}
                    </div>
                  </div>
                  
                  <div className="col-span-1">
                    <h4 className="text-sm font-medium text-gray-700 mb-2">Authorization Strategy</h4>
                    <div className="space-y-2">
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={dataProtection.accessControl.rbac}
                          onChange={(e) => updateDataProtection('accessControl', 'rbac', e.target.checked)}
                          className="rounded text-red-600 focus:ring-red-500 mr-2"
                        />
                        <span className="text-sm">Role-Based Access Control (RBAC)</span>
                      </label>
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={dataProtection.accessControl.acl}
                          onChange={(e) => updateDataProtection('accessControl', 'acl', e.target.checked)}
                          className="rounded text-red-600 focus:ring-red-500 mr-2"
                        />
                        <span className="text-sm">Access Control Lists (ACL)</span>
                      </label>
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={dataProtection.accessControl.customPolicy}
                          onChange={(e) => updateDataProtection('accessControl', 'customPolicy', e.target.checked)}
                          className="rounded text-red-600 focus:ring-red-500 mr-2"
                        />
                        <span className="text-sm">Custom Policy Engine</span>
                      </label>
                      
                      <textarea
                        value={dataProtection.accessControl.notes}
                        onChange={(e) => updateDataProtection('accessControl', 'notes', e.target.value)}
                        placeholder="Additional notes about authorization"
                        className="w-full mt-2 px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                        rows="2"
                      />
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
          
          {/* Data Protection */}
          <div className="mb-6">
            <div 
              className="flex justify-between items-center cursor-pointer"
              onClick={() => toggleSection('dataProtection')}
            >
              <h3 className="text-md font-medium text-gray-700">Data Protection</h3>
              {expandedSections.dataProtection ? (
                <ChevronUp size={20} className="text-gray-500" />
              ) : (
                <ChevronDown size={20} className="text-gray-500" />
              )}
            </div>
            
            {expandedSections.dataProtection && (
              <div className="mt-2 space-y-3">
                <h4 className="text-sm font-medium text-gray-700">Encryption Strategies</h4>
                <div className="space-y-2">
                  <label className="flex items-center">
                    <input
                      type="checkbox"
                      checked={dataProtection.encryption.inTransit}
                      onChange={(e) => updateDataProtection('encryption', 'inTransit', e.target.checked)}
                      className="rounded text-red-600 focus:ring-red-500 mr-2"
                    />
                    <span className="text-sm">Encryption in Transit (TLS/SSL)</span>
                  </label>
                  <label className="flex items-center">
                    <input
                      type="checkbox"
                      checked={dataProtection.encryption.atRest}
                      onChange={(e) => updateDataProtection('encryption', 'atRest', e.target.checked)}
                      className="rounded text-red-600 focus:ring-red-500 mr-2"
                    />
                    <span className="text-sm">Encryption at Rest</span>
                  </label>
                  <label className="flex items-center">
                    <input
                      type="checkbox"
                      checked={dataProtection.encryption.endToEnd}
                      onChange={(e) => updateDataProtection('encryption', 'endToEnd', e.target.checked)}
                      className="rounded text-red-600 focus:ring-red-500 mr-2"
                    />
                    <span className="text-sm">End-to-End Encryption</span>
                  </label>
                  
                  <textarea
                    value={dataProtection.encryption.notes}
                    onChange={(e) => updateDataProtection('encryption', 'notes', e.target.value)}
                    placeholder="Additional notes about encryption"
                    className="w-full mt-2 px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                    rows="2"
                  />
                </div>
              </div>
            )}
          </div>
          
          {/* Security Measures */}
          <div className="mb-6">
            <div 
              className="flex justify-between items-center cursor-pointer"
              onClick={() => toggleSection('securityMeasures')}
            >
              <h3 className="text-md font-medium text-gray-700">Security Measures</h3>
              {expandedSections.securityMeasures ? (
                <ChevronUp size={20} className="text-gray-500" />
              ) : (
                <ChevronDown size={20} className="text-gray-500" />
              )}
            </div>
            
            {expandedSections.securityMeasures && (
              <div className="mt-2 space-y-3">
                {securityMeasures.map(measure => (
                  <div key={measure.id} className="flex items-start space-x-2 border-b border-gray-200 pb-2">
                    <input
                      type="checkbox"
                      checked={measure.implemented}
                      onChange={(e) => updateSecurityMeasure(measure.id, 'implemented', e.target.checked)}
                      className="rounded text-red-600 focus:ring-red-500 mt-1"
                    />
                    <div className="flex-1 grid grid-cols-3 gap-2">
                      <div className="col-span-1">
                        <input
                          type="text"
                          value={measure.type}
                          onChange={(e) => updateSecurityMeasure(measure.id, 'type', e.target.value)}
                          placeholder="Security Measure"
                          className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                        />
                      </div>
                      <div className="col-span-2">
                        <input
                          type="text"
                          value={measure.details}
                          onChange={(e) => updateSecurityMeasure(measure.id, 'details', e.target.value)}
                          placeholder="Implementation details"
                          className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                        />
                      </div>
                    </div>
                    <button 
                      onClick={() => removeSecurityMeasure(measure.id)}
                      className="text-red-500 hover:text-red-700"
                    >
                      <Trash2 size={16} />
                    </button>
                  </div>
                ))}
                
                <button 
                  onClick={addSecurityMeasure}
                  className="flex items-center text-sm text-red-600 hover:text-red-800 font-medium"
                >
                  <Plus size={16} className="mr-1" />
                  Add Security Measure
                </button>
                
                <div className="text-xs text-gray-500 bg-gray-100 p-3 rounded mt-2">
                  <p className="font-medium mb-1">Common security measures to consider:</p>
                  <ul className="grid grid-cols-2 gap-1 list-disc list-inside">
                    <li>Input validation</li>
                    <li>Rate limiting</li>
                    <li>WAF (Web App Firewall)</li>
                    <li>DDoS protection</li>
                    <li>Audit logging</li>
                    <li>Secure dependencies</li>
                    <li>CSRF protection</li>
                    <li>XSS prevention</li>
                    <li>SQL injection prevention</li>
                    <li>Secret management</li>
                  </ul>
                </div>
              </div>
            )}
          </div>
          
          {/* Compliance */}
          <div>
            <div 
              className="flex justify-between items-center cursor-pointer"
              onClick={() => toggleSection('compliance')}
            >
              <h3 className="text-md font-medium text-gray-700">Compliance Requirements</h3>
              {expandedSections.compliance ? (
                <ChevronUp size={20} className="text-gray-500" />
              ) : (
                <ChevronDown size={20} className="text-gray-500" />
              )}
            </div>
            
            {expandedSections.compliance && (
              <div className="mt-2 space-y-3">
                {complianceRequirements.map(req => (
                  <div key={req.id} className="flex items-start space-x-2 border-b border-gray-200 pb-2">
                    <input
                      type="checkbox"
                      checked={req.implemented}
                      onChange={(e) => updateComplianceRequirement(req.id, 'implemented', e.target.checked)}
                      className="rounded text-red-600 focus:ring-red-500 mt-1"
                    />
                    <div className="flex-1 grid grid-cols-3 gap-2">
                      <div className="col-span-1">
                        <input
                          type="text"
                          value={req.standard}
                          onChange={(e) => updateComplianceRequirement(req.id, 'standard', e.target.value)}
                          placeholder="Standard/Regulation"
                          className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                        />
                      </div>
                      <div className="col-span-2">
                        <input
                          type="text"
                          value={req.requirements}
                          onChange={(e) => updateComplianceRequirement(req.id, 'requirements', e.target.value)}
                          placeholder="Specific requirements"
                          className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-red-500 focus:border-red-500"
                        />
                      </div>
                    </div>
                    <button 
                      onClick={() => removeComplianceRequirement(req.id)}
                      className="text-red-500 hover:text-red-700"
                    >
                      <Trash2 size={16} />
                    </button>
                  </div>
                ))}
                
                <button 
                  onClick={addComplianceRequirement}
                  className="flex items-center text-sm text-red-600 hover:text-red-800 font-medium"
                >
                  <Plus size={16} className="mr-1" />
                  Add Compliance Requirement
                </button>
                
                <div className="text-xs text-gray-500 bg-gray-100 p-3 rounded mt-2">
                  <p className="font-medium mb-1">Common compliance standards:</p>
                  <ul className="grid grid-cols-2 gap-1 list-disc list-inside">
                    <li>GDPR (EU data privacy)</li>
                    <li>CCPA/CPRA (California)</li>
                    <li>HIPAA (Healthcare)</li>
                    <li>PCI DSS (Payment)</li>
                    <li>SOC 2 (Security)</li>
                    <li>ISO 27001 (Security)</li>
                    <li>NIST (Federal)</li>
                    <li>FedRAMP (Federal Cloud)</li>
                  </ul>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
      
      {/* Footer with actions */}
      <div className="border-t border-gray-200 p-4 flex justify-between">
        <button className="flex items-center px-4 py-2 text-sm bg-red-50 text-red-700 rounded-md hover:bg-red-100 transition-colors">
          <MessageSquare size={16} className="mr-2" />
          Ask Coach
        </button>
        <button className="flex items-center px-4 py-2 text-sm bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors shadow-sm">
          <Save size={16} className="mr-2" />
          Save & Continue
        </button>
      </div>
    </div>
  );
};

export default ReliabilitySecurityPage;


================================================================================
# FILE: client\pages\RequirementsPage.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect, useCallback } from 'react';
import { Plus, Trash2, MessageSquare, Save, Check, Clock, PenTool } from 'lucide-react';
import WorkbookPageWrapper from './WorkbookPageWrapper';
import DiagramPanel from '../components/diagram/DiagramPanel';
import { toast } from 'react-toastify';
import { useSession } from '../hooks/useSession';

const EnhancedRequirementsPage = ({ data = {}, updateData }) => {
  const [functionalReqs, setFunctionalReqs] = useState(
    data.functionalReqs ? JSON.parse(data.functionalReqs) : [
      { id: 1, text: '', completed: false }
    ]
  );
  
  const [nonFunctionalReqs, setNonFunctionalReqs] = useState(
    data.nonFunctionalReqs ? JSON.parse(data.nonFunctionalReqs) : [
      { id: 1, category: 'Performance', text: '' },
      { id: 2, category: 'Scalability', text: '' },
      { id: 3, category: 'Reliability', text: '' },
      { id: 4, category: 'Security', text: '' }
    ]
  );
  
  const [constraints, setConstraints] = useState(data.constraints || '');
  const [assumptions, setAssumptions] = useState(data.assumptions || '');
  const [isSaving, setIsSaving] = useState(false);
  const [lastSaved, setLastSaved] = useState(null);
  const [showDiagramPanel, setShowDiagramPanel] = useState(false);
  const [aiSuggestions, setAiSuggestions] = useState([]);
  const { sessionId, sessionType } = useSession();
  const [isDiagramOpen, setIsDiagramOpen] = useState(false);

  const updateFunctionalReq = (id, text) => {
    const updatedReqs = functionalReqs.map(req =>
      req.id === id ? { ...req, text } : req
    );
    setFunctionalReqs(updatedReqs);

    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        functionalReqs: JSON.stringify(updatedReqs)
      });
    }
  };

  const toggleFunctionalReq = (id) => {
    const updatedReqs = functionalReqs.map(req =>
      req.id === id ? { ...req, completed: !req.completed } : req
    );
    setFunctionalReqs(updatedReqs);

    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        functionalReqs: JSON.stringify(updatedReqs)
      });
    }
  };

  const updateNonFunctionalReq = (id, text) => {
    const updatedReqs = nonFunctionalReqs.map(req =>
      req.id === id ? { ...req, text } : req
    );
    setNonFunctionalReqs(updatedReqs);

    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        nonFunctionalReqs: JSON.stringify(updatedReqs)
      });
    }
  };

  // Auto-save functionality
  useEffect(() => {
    const saveTimer = setTimeout(async () => {
      if (hasUnsavedChanges()) {
        await handleAutoSave();
      }
    }, 30000); // Auto-save every 30 seconds if there are changes

    return () => clearTimeout(saveTimer);
  }, [functionalReqs, nonFunctionalReqs, constraints, assumptions]);

  const hasUnsavedChanges = useCallback(() => {
    // Implementation of unsaved changes detection
    return false;
  }, [functionalReqs, nonFunctionalReqs]);

  const handleAutoSave = async () => {
    if (isSaving) return;

    setIsSaving(true);
    try {
      const formattedData = {
        functionalReqs: JSON.stringify(functionalReqs),
        nonFunctionalReqs: JSON.stringify(nonFunctionalReqs),
        constraints,
        assumptions,
        lastUpdated: new Date().toISOString()
      };

      await updateData(formattedData);
      setLastSaved(new Date());
      toast({
        title: "Progress Saved",
        description: "Your changes have been automatically saved",
        status: "success",
        duration: 2000,
        isClosable: true,
      });
    } catch (error) {
      toast({
        title: "Auto-save Failed",
        description: "Changes couldn't be saved automatically. Please save manually.",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    } finally {
      setIsSaving(false);
    }
  };

  const handleAddFunctionalReq = () => {
    const newId = Math.max(...functionalReqs.map(req => req.id), 0) + 1;
    setFunctionalReqs([...functionalReqs, { id: newId, text: '', completed: false }]);
  };

  const handleAddNonFunctionalReq = () => {
    const newId = Math.max(...nonFunctionalReqs.map(req => req.id), 0) + 1;
    setNonFunctionalReqs([...nonFunctionalReqs, { id: newId, category: 'Other', text: '' }]);
  };

  const handleDeleteReq = (index, type) => {
    if (type === 'functional') {
      setFunctionalReqs(functionalReqs.filter((_, i) => i !== index));
    } else {
      setNonFunctionalReqs(nonFunctionalReqs.filter((_, i) => i !== index));
    }
  };

  const handleDiagramOpen = () => setIsDiagramOpen(true);
  const handleDiagramClose = () => setIsDiagramOpen(false);

  const handleDiagramSave = async (diagramData) => {
    try {
      await updateData({
        ...data,
        diagrams: [...(data.diagrams || []), diagramData]
      });
      toast({
        title: "Diagram Saved",
        description: "Your diagram has been saved successfully",
        status: "success",
        duration: 2000,
      });
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to save diagram",
        status: "error",
        duration: 3000,
      });
    }
  };

  const handleAiSuggest = async () => {
    try {
      const response = await fetch('/api/ai/suggest-requirements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          functionalReqs,
          nonFunctionalReqs,
          constraints,
          assumptions
        })
      });
      
      const suggestions = await response.json();
      setAiSuggestions(suggestions);
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to get AI suggestions",
        status: "error",
        duration: 3000,
      });
    }
  };

  const handleSaveAndContinue = async () => {
    // Validate all requirements
    const isValid = functionalReqs.some(req => req.text.trim().length > 0) &&
      nonFunctionalReqs.every(req => req.text.trim().length > 0) &&
      constraints.trim().length > 0 &&
      assumptions.trim().length > 0;

    if (!isValid) {
      toast({
        title: "Validation Error",
        description: "Please fill in all required fields before continuing",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    // Format data for saving
    const formattedData = {
      functionalReqs: JSON.stringify(functionalReqs),
      nonFunctionalReqs: JSON.stringify(nonFunctionalReqs),
      constraints,
      assumptions,
      lastUpdated: new Date().toISOString()
    };

    try {
      await updateData(formattedData);
      toast({
        title: "Progress Saved",
        description: "Moving to API Design section",
        status: "success",
        duration: 2000,
      });
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to save progress. Please try again.",
        status: "error",
        duration: 3000,
      });
    }
  };

  return (
    <WorkbookPageWrapper
      onSaveAndContinue={handleSaveAndContinue}
      isValid={functionalReqs.some(req => req.text.trim().length > 0)}
      nextSection="API Design"
    >
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-xl font-semibold">Requirements Definition</h2>
        <div className="flex items-center gap-2 text-sm text-gray-600">
          {isSaving && (
            <div className="flex items-center">
              <Clock className="w-4 h-4 mr-1 animate-spin" />
              Saving...
            </div>
          )}
          {lastSaved && !isSaving && (
            <div className="flex items-center">
              <Check className="w-4 h-4 mr-1 text-green-500" />
              Last saved {new Date(lastSaved).toLocaleTimeString()}
            </div>
          )}
        </div>
      </div>
      
      <div className="flex flex-col h-full bg-white">
        <div className="flex-1 overflow-auto p-6 space-y-8">
          {/* Coach tip box */}
          <div className="bg-indigo-50 border border-indigo-100 rounded-md p-4 text-sm text-indigo-700">
            <strong className="font-medium">Coach tip:</strong> Start with clear user stories to identify key functional requirements. Define non-functional requirements with specific, measurable metrics.
          </div>
          
          {/* Functional Requirements */}
          <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
            <div className="flex justify-between items-center mb-3">
              <h2 className="text-lg font-semibold text-gray-800">Functional Requirements</h2>
              <button 
                className="text-indigo-600 hover:text-indigo-800 text-sm font-medium flex items-center"
                onClick={() => {/* Add diagram functionality */}}
              >
                <PenTool size={14} className="mr-1" />
                Add diagram
              </button>
            </div>
            <p className="text-sm text-gray-600 mb-4">What specific features and capabilities must the system provide?</p>
            
            <div className="space-y-2">
              {functionalReqs.map(req => (
                <div key={req.id} className="flex items-start gap-2">
                  <div className={`mt-1.5 rounded-md w-5 h-5 flex items-center justify-center border ${req.completed ? 'bg-indigo-500 border-indigo-500' : 'border-gray-300'}`}
                    onClick={() => toggleFunctionalReq(req.id)}
                  >
                    {req.completed && <Check size={14} className="text-white" />}
                  </div>
                  <input
                    type="text"
                    value={req.text}
                    onChange={(e) => updateFunctionalReq(req.id, e.target.value)}
                    placeholder="Enter requirement..."
                    className="flex-1 p-2 border border-gray-300 rounded text-sm"
                  />
                  <button 
                    onClick={() => handleDeleteReq(req.id, 'functional')}
                    className="p-1 text-gray-400 hover:text-red-500 transition-colors"
                  >
                    <Trash2 size={16} />
                  </button>
                </div>
              ))}
            </div>
            
            <button 
              onClick={handleAddFunctionalReq}
              className="mt-3 flex items-center text-sm text-indigo-600 hover:text-indigo-800 font-medium"
            >
              <Plus size={16} className="mr-1" />
              Add Requirement
            </button>
          </div>
          
          {/* Non-Functional Requirements */}
          <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
            <h2 className="text-lg font-semibold text-gray-800 mb-3">Non-Functional Requirements</h2>
            <p className="text-sm text-gray-600 mb-4">Quality attributes that define how the system should perform</p>
            
            <div className="space-y-3">
              {nonFunctionalReqs.map(req => (
                <div key={req.id} className="flex flex-col">
                  <label className="font-medium text-sm text-gray-700">{req.category}</label>
                  <input
                    type="text"
                    value={req.text}
                    onChange={(e) => updateNonFunctionalReq(req.id, e.target.value)}
                    placeholder={`Enter ${req.category.toLowerCase()} requirements...`}
                    className="p-2 border border-gray-300 rounded text-sm mt-1 w-full"
                  />
                </div>
              ))}
            </div>
          </div>
          
          {/* Constraints & Assumptions */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
              <h2 className="text-lg font-semibold text-gray-800 mb-3">Constraints</h2>
              <p className="text-sm text-gray-600 mb-4">What limitations must be considered?</p>
              <textarea
                value={constraints}
                onChange={(e) => updateConstraints(e.target.value)}
                placeholder="Enter system constraints..."
                className="w-full h-32 p-2 border border-gray-300 rounded text-sm"
              />
            </div>
            
            <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
              <h2 className="text-lg font-semibold text-gray-800 mb-3">Assumptions</h2>
              <p className="text-sm text-gray-600 mb-4">What are you assuming about the system?</p>
              <textarea
                value={assumptions}
                onChange={(e) => updateAssumptions(e.target.value)}
                placeholder="Enter your assumptions..."
                className="w-full h-32 p-2 border border-gray-300 rounded text-sm"
              />
            </div>
          </div>
        </div>
        
        {/* Enhanced footer with actions */}
        <div className="border-t border-gray-200 p-4 flex justify-between">
          <button className="flex items-center px-4 py-2 text-sm bg-indigo-50 text-indigo-700 rounded-md hover:bg-indigo-100 transition-colors">
            <MessageSquare size={16} className="mr-2" />
            Ask Coach
          </button>
          <button className="flex items-center px-4 py-2 text-sm bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors shadow-sm">
            <Save size={16} className="mr-2" />
            Save & Continue
          </button>
        </div>
      </div>
    </WorkbookPageWrapper>
  );
};

export default EnhancedRequirementsPage;


================================================================================
# FILE: client\pages\ScalingStrategyPage.js
# EXTENSION: .js
================================================================================
import React, { useState } from 'react';
import { MessageSquare, Save, ChevronDown, ChevronUp, Check, Plus, Trash2, PenTool } from 'lucide-react';

const EnhancedScalingStrategyPage = ({ data = {}, updateData }) => {
  // Preserve original state management for functionality
  const [sections, setSections] = useState(
    data.sections ? JSON.parse(data.sections) : [
      {
        id: 'traffic',
        title: 'Traffic Estimation',
        description: 'Estimate the scale and volume of your system',
        expanded: true,
        fields: [
          { id: 'dau', label: 'Daily Active Users (DAU)', value: '', unit: 'users' },
          { id: 'requestsPerUser', label: 'Requests per user per day', value: '', unit: 'requests' },
          { id: 'peakQPS', label: 'Peak QPS (Queries Per Second)', value: '', unit: 'QPS' }
        ]
      },
      {
        id: 'storage',
        title: 'Storage Requirements',
        description: 'Calculate how much data you need to store',
        expanded: false,
        fields: [
          { id: 'objectSize', label: 'Average object size', value: '', unit: 'KB' },
          { id: 'dailyNewData', label: 'New data per day', value: '', unit: 'GB' },
          { id: 'retentionPeriod', label: 'Data retention period', value: '', unit: 'days' },
          { id: 'totalStorage', label: 'Total storage needed', value: '', unit: 'TB' }
        ]
      },
      {
        id: 'bandwidth',
        title: 'Bandwidth Estimation',
        description: 'Estimate inbound and outbound network traffic',
        expanded: false,
        fields: [
          { id: 'inboundTraffic', label: 'Inbound traffic per day', value: '', unit: 'GB' },
          { id: 'outboundTraffic', label: 'Outbound traffic per day', value: '', unit: 'GB' },
          { id: 'peakBandwidth', label: 'Peak bandwidth requirement', value: '', unit: 'Mbps' }
        ]
      },
      {
        id: 'memory',
        title: 'Memory Requirements',
        description: 'Estimate cache and working memory needs',
        expanded: false,
        fields: [
          { id: 'cacheSize', label: 'Total cache size', value: '', unit: 'GB' },
          { id: 'cacheHitRate', label: 'Target cache hit rate', value: '', unit: '%' }
        ]
      }
    ]
  );

  const [strategies, setStrategies] = useState(
    data.strategies ? JSON.parse(data.strategies) : [
      {
        id: 'horizontal',
        title: 'Horizontal Scaling',
        applied: false,
        description: '',
        components: []
      },
      {
        id: 'vertical',
        title: 'Vertical Scaling',
        applied: false,
        description: '',
        components: []
      },
      {
        id: 'caching',
        title: 'Caching Strategy',
        applied: false,
        description: '',
        layers: []
      },
      {
        id: 'database',
        title: 'Database Scaling',
        applied: false,
        description: '',
        techniques: []
      }
    ]
  );

  const [bottlenecks, setBottlenecks] = useState(
    data.bottlenecks ? JSON.parse(data.bottlenecks) : [
      { id: 1, description: '', solution: '' }
    ]
  );

  // Toggle section expansion
  const toggleSection = (sectionId) => {
    const updatedSections = sections.map(section => 
      section.id === sectionId 
        ? { ...section, expanded: !section.expanded } 
        : section
    );
    setSections(updatedSections);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        sections: JSON.stringify(updatedSections)
      });
    }
  };

  // Update field value
  const updateFieldValue = (sectionId, fieldId, value) => {
    const updatedSections = sections.map(section => 
      section.id === sectionId 
        ? {
            ...section,
            fields: section.fields.map(field => 
              field.id === fieldId ? { ...field, value } : field
            )
          } 
        : section
    );
    setSections(updatedSections);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        sections: JSON.stringify(updatedSections)
      });
    }
  };

  // Toggle a scaling strategy's applied status
  const toggleStrategy = (strategyId) => {
    const updatedStrategies = strategies.map(strategy => 
      strategy.id === strategyId 
        ? { ...strategy, applied: !strategy.applied } 
        : strategy
    );
    setStrategies(updatedStrategies);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        strategies: JSON.stringify(updatedStrategies)
      });
    }
  };

  // Update strategy description
  const updateStrategyDescription = (strategyId, description) => {
    const updatedStrategies = strategies.map(strategy => 
      strategy.id === strategyId 
        ? { ...strategy, description } 
        : strategy
    );
    setStrategies(updatedStrategies);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        strategies: JSON.stringify(updatedStrategies)
      });
    }
  };

  // Add a component to a strategy
  const addStrategyComponent = (strategyId) => {
    const updatedStrategies = strategies.map(strategy => {
      if (strategy.id === strategyId) {
        return {
          ...strategy,
          components: [
            ...strategy.components,
            { id: Date.now(), name: '', details: '' }
          ]
        };
      }
      return strategy;
    });
    
    setStrategies(updatedStrategies);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        strategies: JSON.stringify(updatedStrategies)
      });
    }
  };

  // Update a component in a strategy
  const updateStrategyComponent = (strategyId, componentId, field, value) => {
    const updatedStrategies = strategies.map(strategy => {
      if (strategy.id === strategyId) {
        return {
          ...strategy,
          components: strategy.components.map(component => 
            component.id === componentId 
              ? { ...component, [field]: value } 
              : component
          )
        };
      }
      return strategy;
    });
    
    setStrategies(updatedStrategies);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        strategies: JSON.stringify(updatedStrategies)
      });
    }
  };

  // Remove a component from a strategy
  const removeStrategyComponent = (strategyId, componentId) => {
    const updatedStrategies = strategies.map(strategy => {
      if (strategy.id === strategyId) {
        return {
          ...strategy,
          components: strategy.components.filter(component => component.id !== componentId)
        };
      }
      return strategy;
    });
    
    setStrategies(updatedStrategies);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        strategies: JSON.stringify(updatedStrategies)
      });
    }
  };

  // Add a bottleneck
  const addBottleneck = () => {
    const updatedBottlenecks = [
      ...bottlenecks,
      { id: Date.now(), description: '', solution: '' }
    ];
    
    setBottlenecks(updatedBottlenecks);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        bottlenecks: JSON.stringify(updatedBottlenecks)
      });
    }
  };

  // Update a bottleneck
  const updateBottleneck = (bottleneckId, field, value) => {
    const updatedBottlenecks = bottlenecks.map(bottleneck => 
      bottleneck.id === bottleneckId 
        ? { ...bottleneck, [field]: value } 
        : bottleneck
    );
    
    setBottlenecks(updatedBottlenecks);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        bottlenecks: JSON.stringify(updatedBottlenecks)
      });
    }
  };

  // Remove a bottleneck
  const removeBottleneck = (bottleneckId) => {
    const updatedBottlenecks = bottlenecks.filter(bottleneck => bottleneck.id !== bottleneckId);
    
    setBottlenecks(updatedBottlenecks);
    
    // Update parent component's data
    if (updateData) {
      updateData({
        ...data,
        bottlenecks: JSON.stringify(updatedBottlenecks)
      });
    }
  };

  return (
    <div className="flex flex-col h-full bg-white">
      <div className="flex-1 overflow-auto p-6 space-y-8">
        {/* Coach tip box */}
        <div className="bg-orange-50 border border-orange-100 rounded-md p-4 text-sm text-orange-700">
          <strong className="font-medium">Coach tip:</strong> Focus on concrete metrics when estimating scale. Consider growth projections over time and identify potential bottlenecks early in your design.
        </div>
        
        {/* Estimations Sections */}
        <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-lg font-semibold text-gray-800">Scale Estimations</h2>
            <button 
              className="text-orange-600 hover:text-orange-800 text-sm font-medium flex items-center"
              onClick={() => {/* Add diagram functionality */}}
            >
              <PenTool size={14} className="mr-1" />
              Add diagram
            </button>
          </div>
          
          <div className="space-y-4">
            {sections.map(section => (
              <div key={section.id} className="border border-gray-300 rounded-md shadow-sm">
                <div 
                  className="flex justify-between items-center p-3 bg-gray-100 cursor-pointer"
                  onClick={() => toggleSection(section.id)}
                >
                  <div>
                    <h3 className="font-medium text-gray-800">{section.title}</h3>
                    <p className="text-sm text-gray-600">{section.description}</p>
                  </div>
                  <div>
                    {section.expanded ? (
                      <ChevronUp size={20} className="text-gray-500" />
                    ) : (
                      <ChevronDown size={20} className="text-gray-500" />
                    )}
                  </div>
                </div>
                
                {section.expanded && (
                  <div className="p-3 border-t border-gray-300 bg-white">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      {section.fields.map(field => (
                        <div key={field.id} className="flex flex-col">
                          <label className="text-sm font-medium text-gray-700 mb-1">{field.label}</label>
                          <div className="flex">
                            <input
                              type="text"
                              value={field.value}
                              onChange={(e) => updateFieldValue(section.id, field.id, e.target.value)}
                              className="flex-1 px-3 py-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-1 focus:ring-orange-500 focus:border-orange-500"
                              placeholder="Enter value"
                            />
                            <span className="bg-gray-100 px-3 py-2 border border-l-0 border-gray-300 rounded-r-md text-gray-500">
                              {field.unit}
                            </span>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>
        
        {/* Scaling Strategies */}
        <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <h2 className="text-lg font-semibold text-gray-800 mb-4">Scaling Approaches</h2>
          
          <div className="space-y-4">
            {strategies.map(strategy => (
              <div key={strategy.id} className="border border-gray-300 rounded-md overflow-hidden shadow-sm">
                <div className="p-3 bg-white">
                  <div className="flex items-start justify-between">
                    <div className="flex items-start">
                      <div className="mt-0.5 mr-3">
                        <button 
                          onClick={() => toggleStrategy(strategy.id)}
                          className={`w-5 h-5 rounded flex items-center justify-center ${
                            strategy.applied ? 'bg-orange-500 text-white' : 'border border-gray-300'
                          }`}
                        >
                          {strategy.applied && <Check size={14} />}
                        </button>
                      </div>
                      <div className="flex-1">
                        <h3 className="font-medium text-gray-800">{strategy.title}</h3>
                        <textarea
                          value={strategy.description}
                          onChange={(e) => updateStrategyDescription(strategy.id, e.target.value)}
                          placeholder={`Describe your ${strategy.title.toLowerCase()} approach...`}
                          className="mt-2 w-full px-3 py-2 border border-gray-300 rounded text-sm focus:outline-none focus:ring-1 focus:ring-orange-500 focus:border-orange-500"
                          rows="3"
                        />
                      </div>
                    </div>
                  </div>
                  
                  {strategy.applied && (
                    <div className="mt-4">
                      <h4 className="text-sm font-medium text-gray-700 mb-2">Components to Scale</h4>
                      
                      {strategy.components.map(component => (
                        <div key={component.id} className="flex items-start mb-2">
                          <input
                            type="text"
                            value={component.name}
                            onChange={(e) => updateStrategyComponent(strategy.id, component.id, 'name', e.target.value)}
                            placeholder="Component name"
                            className="w-48 px-3 py-2 border border-gray-300 rounded-l-md text-sm focus:ring-1 focus:ring-orange-500 focus:border-orange-500"
                          />
                          <input
                            type="text"
                            value={component.details}
                            onChange={(e) => updateStrategyComponent(strategy.id, component.id, 'details', e.target.value)}
                            placeholder="How to scale this component"
                            className="flex-1 px-3 py-2 border-t border-b border-r border-gray-300 text-sm focus:ring-1 focus:ring-orange-500 focus:border-orange-500"
                          />
                          <button 
                            onClick={() => removeStrategyComponent(strategy.id, component.id)}
                            className="px-3 py-2 bg-gray-100 border border-l-0 border-gray-300 rounded-r-md text-gray-500 hover:text-red-500"
                          >
                            <Trash2 size={14} />
                          </button>
                        </div>
                      ))}
                      
                      <button 
                        onClick={() => addStrategyComponent(strategy.id)}
                        className="flex items-center text-xs text-orange-600 hover:text-orange-800 mt-2 font-medium"
                      >
                        <Plus size={14} className="mr-1" />
                        Add Component
                      </button>
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
        
        {/* Bottlenecks and Solutions */}
        <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <h2 className="text-lg font-semibold text-gray-800 mb-4">Potential Bottlenecks & Solutions</h2>
          
          <div className="space-y-4">
            {bottlenecks.map(bottleneck => (
              <div key={bottleneck.id} className="grid grid-cols-1 md:grid-cols-2 gap-4 border border-gray-300 rounded-md p-4 bg-white shadow-sm">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">Bottleneck</label>
                  <textarea
                    value={bottleneck.description}
                    onChange={(e) => updateBottleneck(bottleneck.id, 'description', e.target.value)}
                    placeholder="Describe a potential bottleneck"
                    className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-orange-500 focus:border-orange-500"
                    rows="3"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">Solution</label>
                  <textarea
                    value={bottleneck.solution}
                    onChange={(e) => updateBottleneck(bottleneck.id, 'solution', e.target.value)}
                    placeholder="Describe your solution"
                    className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-orange-500 focus:border-orange-500"
                    rows="3"
                  />
                </div>
                <div className="md:col-span-2 flex justify-end">
                  <button 
                    onClick={() => removeBottleneck(bottleneck.id)}
                    className="text-red-500 hover:text-red-700 text-sm flex items-center"
                  >
                    <Trash2 size={14} className="mr-1" />
                    Remove
                  </button>
                </div>
              </div>
            ))}
            
            <button 
              onClick={addBottleneck}
              className="flex items-center text-sm text-orange-600 hover:text-orange-800 mt-2 font-medium"
            >
              <Plus size={16} className="mr-1" />
              Add Another Bottleneck
            </button>
          </div>
        </div>
      </div>
      
      {/* Footer with actions */}
      <div className="border-t border-gray-200 p-4 flex justify-between">
        <button className="flex items-center px-4 py-2 text-sm bg-orange-50 text-orange-700 rounded-md hover:bg-orange-100 transition-colors">
          <MessageSquare size={16} className="mr-2" />
          Ask Coach
        </button>
        <button className="flex items-center px-4 py-2 text-sm bg-orange-600 text-white rounded-md hover:bg-orange-700 transition-colors shadow-sm">
          <Save size={16} className="mr-2" />
          Save & Continue
        </button>
      </div>
    </div>
  );
};

export default EnhancedScalingStrategyPage;


================================================================================
# FILE: client\pages\SystemArchitecturePage.js
# EXTENSION: .js
================================================================================
import React, { useState } from 'react';
import { MessageSquare, Save, PenTool } from 'lucide-react';

const EnhancedSystemArchitecturePage = ({ data = {}, updateData }) => {
  const [formState, setFormState] = useState({
    overview: data.overview || '',
    components: data.components || '',
    dataFlow: data.dataFlow || '',
    technologies: data.technologies || '',
    deploymentModel: data.deploymentModel || ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    const newState = { ...formState, [name]: value };
    setFormState(newState);
    
    if (updateData) {
      updateData(newState);
    }
  };

  return (
    <div className="flex flex-col h-full bg-white">
      <div className="flex-1 overflow-auto p-6 space-y-8">
        {/* Coach tip box */}
        <div className="bg-blue-50 border border-blue-100 rounded-md p-4 text-sm text-blue-700">
          <strong className="font-medium">Coach tip:</strong> Start with a high-level architecture diagram. Define clear boundaries between components and specify how data flows through the system.
        </div>
        
        <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-lg font-semibold text-gray-800">System Architecture</h2>
            <button 
              className="text-blue-600 hover:text-blue-800 text-sm font-medium flex items-center"
              onClick={() => {/* Add diagram functionality */}}
            >
              <PenTool size={14} className="mr-1" />
              Add diagram
            </button>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Architecture Overview
            </label>
            <textarea
              name="overview"
              value={formState.overview}
              onChange={handleChange}
              rows={4}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm"
              placeholder="High-level description of the architecture (monolith, microservices, etc.)..."
            />
          </div>
          
          <div className="mt-4">
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Key Components
            </label>
            <textarea
              name="components"
              value={formState.components}
              onChange={handleChange}
              rows={4}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm"
              placeholder="Services, modules, and their responsibilities..."
            />
          </div>
          
          <div className="mt-4">
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Data Flow
            </label>
            <textarea
              name="dataFlow"
              value={formState.dataFlow}
              onChange={handleChange}
              rows={4}
              className="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm"
              placeholder="How data flows between components and services..."
            />
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Technologies & Frameworks
              </label>
              <textarea
                name="technologies"
                value={formState.technologies}
                onChange={handleChange}
                rows={3}
                className="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm"
                placeholder="Key technologies, frameworks, and libraries..."
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Deployment Model
              </label>
              <textarea
                name="deploymentModel"
                value={formState.deploymentModel}
                onChange={handleChange}
                rows={3}
                className="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm"
                placeholder="Cloud infrastructure, containerization, etc..."
              />
            </div>
          </div>

          <div className="mt-6 p-4 bg-gray-100 rounded-md border border-gray-200">
            <h3 className="text-sm font-semibold text-gray-700 mb-2">Architecture Pattern Suggestions</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
              <div className="border border-gray-300 rounded-md p-2 bg-white cursor-pointer hover:bg-blue-50">
                <div className="font-medium mb-1 text-blue-700">Microservices</div>
                <p className="text-gray-600 text-xs">Decompose application into small, independent services. Good for complex applications that need independent scaling.</p>
              </div>
              <div className="border border-gray-300 rounded-md p-2 bg-white cursor-pointer hover:bg-blue-50">
                <div className="font-medium mb-1 text-blue-700">Event-Driven</div>
                <p className="text-gray-600 text-xs">Components communicate through events, reducing coupling. Good for systems with asynchronous workflows.</p>
              </div>
              <div className="border border-gray-300 rounded-md p-2 bg-white cursor-pointer hover:bg-blue-50">
                <div className="font-medium mb-1 text-blue-700">Layered Architecture</div>
                <p className="text-gray-600 text-xs">Organize code into layers with specific responsibilities. Classic pattern for many applications.</p>
              </div>
              <div className="border border-gray-300 rounded-md p-2 bg-white cursor-pointer hover:bg-blue-50">
                <div className="font-medium mb-1 text-blue-700">CQRS</div>
                <p className="text-gray-600 text-xs">Separate read and write operations for better performance and scalability. Good for complex domains.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      {/* Footer with actions */}
      <div className="border-t border-gray-200 p-4 flex justify-between">
        <button className="flex items-center px-4 py-2 text-sm bg-blue-50 text-blue-700 rounded-md hover:bg-blue-100 transition-colors">
          <MessageSquare size={16} className="mr-2" />
          Ask Coach
        </button>
        <button className="flex items-center px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors shadow-sm">
          <Save size={16} className="mr-2" />
          Save & Continue
        </button>
      </div>
    </div>
  );
};

export default EnhancedSystemArchitecturePage;


================================================================================
# FILE: client\pages\test-flow.js
# EXTENSION: .js
================================================================================
import dynamic from 'next/dynamic';

const SimpleFlow = dynamic(() => import('../components/SimpleFlow'), { 
  ssr: false,
  loading: () => (
    <div className="flex h-full items-center justify-center bg-gray-50">
      <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500"></div>
    </div>
  )
});

export default function TestPage() {
  return (
    <div style={{ width: '100%', height: '100vh', padding: '20px' }}>
      <h1 className="text-2xl font-bold mb-4">React Flow Test Page</h1>
      <div style={{ width: '100%', height: 'calc(100vh - 100px)', border: '1px solid #ccc' }}>
        <SimpleFlow />
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\WorkbookLayout.js
# EXTENSION: .js
================================================================================
// pages/WorkbookLayout.js
import React, { useState } from 'react';
import { ClipboardList, Database, Code, Layout, BarChart, Shield, MessageSquare, LogOut, Menu, X, User, Save, ChevronRight, CheckCircle, AlertCircle } from 'lucide-react';
import ExperienceLevelSelector from '../components/ExperienceLevelSelector';
import ConciseModeToggle from '../components/ConciseModeToggle';
import { getEvaluation } from '../utils/api';

// Import page components from the correct location
// If they're directly in the pages directory:
import RequirementsPage from './RequirementsPage';
import APIDesignPage from './APIDesignPage';
import DataModelPage from './DataModelPage';
import SystemArchitecturePage from './SystemArchitecturePage';
import ScalingStrategyPage from './ScalingStrategyPage';
import ReliabilitySecurityPage from './ReliabilitySecurityPage';

// The color mapping function for tabs
const getTabStyles = (tabId, isActive) => {
  switch(tabId) {
    case 'requirements':
      return isActive 
        ? "border-indigo-500 text-indigo-600" 
        : "text-gray-500 hover:text-indigo-700 hover:border-gray-300";
    case 'api':
      return isActive 
        ? "border-green-500 text-green-600" 
        : "text-gray-500 hover:text-green-700 hover:border-gray-300";
    case 'data':
      return isActive 
        ? "border-purple-500 text-purple-600" 
        : "text-gray-500 hover:text-purple-700 hover:border-gray-300";
    case 'architecture':
      return isActive 
        ? "border-blue-500 text-blue-600" 
        : "text-gray-500 hover:text-blue-700 hover:border-gray-300";
    case 'scaling':
      return isActive 
        ? "border-orange-500 text-orange-600" 
        : "text-gray-500 hover:text-orange-700 hover:border-gray-300";
    case 'reliability':
      return isActive 
        ? "border-red-500 text-red-600" 
        : "text-gray-500 hover:text-red-700 hover:border-gray-300";
    default:
      return isActive 
        ? "border-gray-500 text-gray-600" 
        : "text-gray-500 hover:text-gray-700 hover:border-gray-300";
  }
};

// The mobile menu styles
const getMobileTabStyles = (tabId, isActive) => {
  switch(tabId) {
    case 'requirements':
      return isActive ? "bg-indigo-50 text-indigo-700" : "text-gray-600 hover:bg-gray-50 hover:text-gray-900";
    case 'api':
      return isActive ? "bg-green-50 text-green-700" : "text-gray-600 hover:bg-gray-50 hover:text-gray-900";
    case 'data':
      return isActive ? "bg-purple-50 text-purple-700" : "text-gray-600 hover:bg-gray-50 hover:text-gray-900";
    case 'architecture':
      return isActive ? "bg-blue-50 text-blue-700" : "text-gray-600 hover:bg-gray-50 hover:text-gray-900";
    case 'scaling':
      return isActive ? "bg-orange-50 text-orange-700" : "text-gray-600 hover:bg-gray-50 hover:text-gray-900";
    case 'reliability':
      return isActive ? "bg-red-50 text-red-700" : "text-gray-600 hover:bg-gray-50 hover:text-gray-900";
    default:
      return isActive ? "bg-gray-50 text-gray-700" : "text-gray-600 hover:bg-gray-50 hover:text-gray-900";
  }
};

// The coach button styles
const getCoachButtonStyles = (tabId) => {
  switch(tabId) {
    case 'requirements':
      return "bg-indigo-600 hover:bg-indigo-700";
    case 'api':
      return "bg-green-600 hover:bg-green-700";
    case 'data':
      return "bg-purple-600 hover:bg-purple-700";
    case 'architecture':
      return "bg-blue-600 hover:bg-blue-700";
    case 'scaling':
      return "bg-orange-600 hover:bg-orange-700";
    case 'reliability':
      return "bg-red-600 hover:bg-red-700";
    default:
      return "bg-gray-600 hover:bg-gray-700";
  }
};

// The progress bar style
const getProgressBarStyles = (tabId) => {
  switch(tabId) {
    case 'requirements':
      return "bg-indigo-600";
    case 'api':
      return "bg-green-600";
    case 'data':
      return "bg-purple-600";
    case 'architecture':
      return "bg-blue-600";
    case 'scaling':
      return "bg-orange-600";
    case 'reliability':
      return "bg-red-600";
    default:
      return "bg-gray-600";
  }
};

// Export button style
const getExportButtonStyles = (tabId) => {
  switch(tabId) {
    case 'requirements':
      return "text-indigo-600 hover:text-indigo-800";
    case 'api':
      return "text-green-600 hover:text-green-800";
    case 'data':
      return "text-purple-600 hover:text-purple-800";
    case 'architecture':
      return "text-blue-600 hover:text-blue-800";
    case 'scaling':
      return "text-orange-600 hover:text-orange-800";
    case 'reliability':
      return "text-red-600 hover:text-red-800";
    default:
      return "text-gray-600 hover:text-gray-800";
  }
};

// Coach panel background style
const getCoachPanelBgStyle = (tabId) => {
  switch(tabId) {
    case 'requirements':
      return "bg-indigo-50";
    case 'api':
      return "bg-green-50";
    case 'data':
      return "bg-purple-50";
    case 'architecture':
      return "bg-blue-50";
    case 'scaling':
      return "bg-orange-50";
    case 'reliability':
      return "bg-red-50";
    default:
      return "bg-gray-50";
  }
};

// Coach panel text style
const getCoachPanelTextStyle = (tabId) => {
  switch(tabId) {
    case 'requirements':
      return "text-indigo-700";
    case 'api':
      return "text-green-700";
    case 'data':
      return "text-purple-700";
    case 'architecture':
      return "text-blue-700";
    case 'scaling':
      return "text-orange-700";
    case 'reliability':
      return "text-red-700";
    default:
      return "text-gray-700";
  }
};

// Coach input focus style
const getCoachInputFocusStyle = (tabId) => {
  switch(tabId) {
    case 'requirements':
      return "focus:ring-indigo-500";
    case 'api':
      return "focus:ring-green-500";
    case 'data':
      return "focus:ring-purple-500";
    case 'architecture':
      return "focus:ring-blue-500";
    case 'scaling':
      return "focus:ring-orange-500";
    case 'reliability':
      return "focus:ring-red-500";
    default:
      return "focus:ring-gray-500";
  }
};

const WorkbookLayout = ({ onBack, sessionId }) => {
  const [activeTab, setActiveTab] = useState('requirements');
  const [showCoach, setShowCoach] = useState(false);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [userLevel, setUserLevel] = useState('mid-level');
  const [conciseMode, setConciseMode] = useState(true);
  const [showSaveModal, setShowSaveModal] = useState(false);
  const [progressPercent, setProgressPercent] = useState(35);
  const [isSaving, setIsSaving] = useState(false);
  const [workbookName, setWorkbookName] = useState('E-commerce Platform Design');
  const [workbookTags, setWorkbookTags] = useState('e-commerce, scalability, web');
  const [saveStatus, setSaveStatus] = useState('idle'); // 'idle' | 'saving' | 'saved' | 'error'
  
  const [formData, setFormData] = useState({
    requirements: {},
    api: {},
    data: {},
    architecture: {},
    scaling: {},
    reliability: {}
  });
  
  // Define tabs for navigation
  const tabs = [
    { id: 'requirements', label: 'Requirements', icon: <ClipboardList size={18} /> },
    { id: 'api', label: 'API Design', icon: <Code size={18} /> },
    { id: 'data', label: 'Data Model', icon: <Database size={18} /> },
    { id: 'architecture', label: 'Architecture', icon: <Layout size={18} /> },
    { id: 'scaling', label: 'Scaling Strategy', icon: <BarChart size={18} /> },
    { id: 'reliability', label: 'Reliability & Security', icon: <Shield size={18} /> }
  ];
  
  // Mock function for updating form data
  const updateFormData = (section, data) => {
    setFormData({
      ...formData,
      [section]: data
    });
  };
  
  const getActivePageComponent = () => {
    switch (activeTab) {
      case 'requirements':
        return <RequirementsPage 
          data={formData.requirements} 
          updateData={(data) => updateFormData('requirements', data)} 
        />;
      case 'api':
        return <APIDesignPage 
          data={formData.api} 
          updateData={(data) => updateFormData('api', data)} 
        />;
      case 'data':
        return <DataModelPage 
          data={formData.data} 
          updateData={(data) => updateFormData('data', data)} 
        />;
      case 'architecture':
        return <SystemArchitecturePage 
          data={formData.architecture} 
          updateData={(data) => updateFormData('architecture', data)} 
        />;
      case 'scaling':
        return <ScalingStrategyPage 
          data={formData.scaling} 
          updateData={(data) => updateFormData('scaling', data)} 
        />;
      case 'reliability':
        return <ReliabilitySecurityPage 
          data={formData.reliability} 
          updateData={(data) => updateFormData('reliability', data)} 
        />;
      default:
        return <RequirementsPage 
          data={formData.requirements} 
          updateData={(data) => updateFormData('requirements', data)} 
        />;
    }
  };
  
  // Handler for "Ask Coach" button clicks with shift-click functionality
  const handleAskCoach = async (e) => {
    // Check if shift key was pressed
    const isShiftClick = e && e.shiftKey;
    
    // If this is a shift-click, handle differently
    if (isShiftClick) {
      console.log("Shift-click detected on Ask Coach button");
      // Example: Show an alert or perform a different action
      alert("Shift-click detected! You can implement special functionality here, like advanced coaching options.");
      return;
    }
    
    // Regular ask coach functionality
    const currentData = {
      ...formData[activeTab],
      userLevel,
      conciseMode,
      currentPage: activeTab
    };
    
    try {
      // Get all workbook content for evaluation
      if (sessionId) {
        const allWorkbookData = {
          requirements: formData.requirements,
          api: formData.api,
          data: formData.data,
          architecture: formData.architecture,
          scaling: formData.scaling,
          reliability: formData.reliability
        };
        
        // Get evaluation in background (don't await to keep UI responsive)
        getEvaluation(sessionId, allWorkbookData, userLevel, conciseMode)
          .catch(err => console.error('Background evaluation error:', err));
      }
    } catch (error) {
      console.error('Error in handleAskCoach:', error);
    }
    
    setShowCoach(true);
  };

  const handleSave = async () => {
    console.log('Save button clicked');
    if (!sessionId || !workbookData) {
      console.error('Missing required data for save');
      return;
    }
    
    try {
      setSaveStatus('saving');
      await autoSaveWorkbook(sessionId, workbookData, userId, setSaveStatus);
    } catch (error) {
      console.error('Save error:', error);
      setSaveStatus('error');
    }
  };
  
  return (
    <div className="flex flex-col h-screen bg-gray-50">
      {/* Top Navigation Bar */}
      <header className="bg-white border-b border-gray-200 shadow-sm">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between h-16">
            <div className="flex">
              <div className="flex-shrink-0 flex items-center">
                <Layout className="h-8 w-8 text-indigo-600" />
                <span className="font-bold text-lg text-gray-900 ml-2">System Design Coach</span>
              </div>
              
              <div className="hidden md:ml-6 md:flex md:items-center md:space-x-4">
                <button 
                  onClick={onBack}
                  className="text-gray-500 hover:text-gray-700 px-3 py-2 rounded-md text-sm font-medium"
                >
                  Dashboard
                </button>
                <button className="bg-indigo-50 text-indigo-700 px-3 py-2 rounded-md text-sm font-medium">
                  Workbook
                </button>
                <button className="text-gray-500 hover:text-gray-700 px-3 py-2 rounded-md text-sm font-medium">
                  History
                </button>
              </div>
            </div>
            
            <div className="hidden md:flex md:items-center md:space-x-4">
              {/* Progress indicator */}
              <div className="flex items-center mr-4">
                <div className="w-32 mr-2">
                  <div className="w-full bg-gray-200 rounded-full h-2.5">
                    <div className={`${getProgressBarStyles(activeTab)} h-2.5 rounded-full`} style={{ width: `${progressPercent}%` }}></div>
                  </div>
                </div>
                <span className="text-sm text-gray-600">{progressPercent}%</span>
              </div>
            </div>
            
            <div className="flex items-center">
              <button 
                onClick={(e) => handleAskCoach(e)}
                className={`flex items-center px-4 py-2 ${getCoachButtonStyles(activeTab)} text-white rounded`}
              >
                <MessageSquare size={18} className="mr-2" />
                <span className="hidden md:inline">Ask Coach</span>
              </button>
              
              <div className="ml-4 relative">
                <button className="flex items-center text-gray-500 hover:text-gray-700">
                  <span className="sr-only">Open user menu</span>
                  <LogOut size={18} />
                </button>
              </div>
              
              <div className="-mr-2 flex items-center md:hidden">
                <button
                  onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
                  className="inline-flex items-center justify-center p-2 rounded-md text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:bg-gray-100 focus:text-gray-500"
                >
                  <span className="sr-only">Open main menu</span>
                  {mobileMenuOpen ? <X size={24} /> : <Menu size={24} />}
                </button>
              </div>
            </div>
          </div>
        </div>
      </header>
      
      {/* Tabs Navigation */}
      <div className="hidden md:block bg-white border-b border-gray-200">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex">
            {tabs.map((tab) => (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                className={`flex items-center py-4 px-4 text-sm font-medium relative ${
                  activeTab === tab.id
                    ? `border-b-2 ${getTabStyles(tab.id, true)}`
                    : getTabStyles(tab.id, false)
                }`}
              >
                {tab.icon}
                <span className="ml-2">{tab.label}</span>
                {tab.id === 'requirements' && (
                  <span className="ml-2 bg-green-100 text-green-800 text-xs px-2 py-0.5 rounded-full">
                    Complete
                  </span>
                )}
              </button>
            ))}
          </div>
        </div>
      </div>
      
      {/* Mobile menu */}
      {mobileMenuOpen && (
        <div className="md:hidden">
          <div className="pt-2 pb-3 space-y-1">
            {tabs.map((tab) => (
              <button
                key={tab.id}
                onClick={() => {
                  setActiveTab(tab.id);
                  setMobileMenuOpen(false);
                }}
                className={`flex items-center w-full px-3 py-2 text-base font-medium ${
                  getMobileTabStyles(tab.id, activeTab === tab.id)
                }`}
              >
                {tab.icon}
                <span className="ml-3">{tab.label}</span>
                {tab.id === 'requirements' && (
                  <span className="ml-2 bg-green-100 text-green-800 text-xs px-2 py-0.5 rounded-full">
                    Complete
                  </span>
                )}
              </button>
            ))}
          </div>
          
          {/* Mobile Settings */}
          <div className="pt-4 pb-3 border-t border-gray-200">
            <div className="flex items-center px-4">
              <div className="flex-shrink-0">
                <User className="h-10 w-10 text-gray-400" />
              </div>
              <div className="ml-3">
                <div className="text-base font-medium text-gray-800">Settings</div>
              </div>
            </div>
            <div className="mt-3 space-y-1">
              <div className="px-4 py-2 flex justify-between items-center">
                <span className="text-base font-medium text-gray-800">Concise Mode</span>
                <ConciseModeToggle 
                  isEnabled={conciseMode}
                  onToggle={setConciseMode}
                />
              </div>
              <div className="px-4 py-2">
                <div className="flex justify-between items-center">
                  <span className="text-base font-medium text-gray-800">Experience Level</span>
                  <ExperienceLevelSelector 
                    currentLevel={userLevel}
                    onLevelChange={setUserLevel}
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
      
      {/* Main content area */}
      <main className="flex-1 overflow-auto">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
          <div className="mb-6 flex justify-between items-center">
            <h1 className="text-2xl font-bold text-gray-900">{workbookName}</h1>
            <div className="flex space-x-3">
              <button className={`flex items-center ${getExportButtonStyles(activeTab)}`}>
                <Save size={16} className="mr-1" />
                <span className="text-sm font-medium">Export PDF</span>
              </button>
            </div>
          </div>
          
          {/* Tab Content */}
          {getActivePageComponent()}
        </div>
      </main>
      
      {/* Coach Interface (Sliding Panel) */}
      {showCoach && (
        <div className="fixed inset-y-0 right-0 max-w-md w-full bg-white shadow-lg transform transition-transform duration-300 ease-in-out translate-x-0">
          <div className="h-full flex flex-col">
            <div className="px-4 py-3 border-b border-gray-200 flex justify-between items-center">
              <h3 className="text-lg font-medium text-gray-900">System Design Coach</h3>
              <button 
                onClick={() => setShowCoach(false)}
                className="text-gray-400 hover:text-gray-500"
              >
                <X size={20} />
              </button>
            </div>
            
            <div className="flex-1 overflow-auto p-4">
              <div className="bg-gray-100 rounded-lg p-4 mb-4">
                <p className="text-gray-800 mb-2">I've reviewed your {tabs.find(tab => tab.id === activeTab)?.label.toLowerCase()} section and have some suggestions:</p>
                <ul className="list-disc pl-5 space-y-2 text-gray-700 text-sm">
                  <li>Consider adding more specific metrics for your non-functional requirements</li>
                  <li>Your user types are clear, but you might want to add user personas</li>
                  <li>For scale & load, include data growth projections over time</li>
                </ul>
              </div>
              
              <div className={`${getCoachPanelBgStyle(activeTab)} rounded-lg p-4 mb-4`}>
                <p className={`${getCoachPanelTextStyle(activeTab)} mb-2 font-medium`}>Questions to consider:</p>
                <ul className="list-disc pl-5 space-y-2 text-indigo-700 text-sm">
                  <li>What are the main user flows through your system?</li>
                  <li>Are there any regulatory requirements that might affect your design?</li>
                  <li>Do you need to support international users?</li>
                </ul>
              </div>
              
              <div className="bg-gray-100 rounded-lg p-4">
                <p className="text-gray-800 mb-2">Here's an example of how you might elaborate:</p>
                <div className="bg-white p-3 rounded border border-gray-200 text-sm text-gray-700">
                  <p><strong>Scale & Load:</strong></p>
                  <p>- Daily active users: ~50,000</p>
                  <p>- Peak traffic: 1,000 requests/second during business hours</p>
                  <p>- Data growth: 5TB/year initially, expected to grow 40% YoY</p>
                  <p>- Average session duration: 15 minutes</p>
                  <p>- Read to write ratio: 80:20</p>
                </div>
              </div>
            </div>
            
            <div className="px-4 py-3 border-t border-gray-200">
              <div className="relative">
                <input
                  type="text"
                  placeholder="Ask a question..."
                  className={`w-full border border-gray-300 rounded-lg pl-3 pr-10 py-2 focus:outline-none focus:ring-2 ${getCoachInputFocusStyle(activeTab)}`}
                />
                <button className={`absolute right-2 top-2 ${getExportButtonStyles(activeTab)}`}>
                  <ChevronRight size={20} />
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
      
      {/* Save Modal */}
      {showSaveModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-10">
          <div className="bg-white rounded-lg max-w-md w-full p-6">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium text-gray-900">Save Workbook</h3>
              <button 
                onClick={() => setShowSaveModal(false)}
                className="text-gray-400 hover:text-gray-500"
              >
                <X size={20} />
              </button>
            </div>
            
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Workbook Name
              </label>
              <input
                type="text"
                className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                value={workbookName}
                onChange={(e) => setWorkbookName(e.target.value)}
              />
            </div>
            
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Tags
              </label>
              <input
                type="text"
                className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                value={workbookTags}
                onChange={(e) => setWorkbookTags(e.target.value)}
              />
            </div>
            
            <div className="flex justify-end mt-4">
              <button
                onClick={() => setShowSaveModal(false)}
                className="mr-3 px-4 py-2 text-sm text-gray-700 hover:text-gray-900"
              >
                Cancel
              </button>
              <button
                onClick={handleSave}
                className={`px-4 py-2 rounded flex items-center ${
                  saveStatus === 'error' 
                    ? 'bg-red-600 hover:bg-red-700' 
                    : 'bg-indigo-600 hover:bg-indigo-700'
                } text-white`}
                disabled={isSaving}
              >
                {isSaving ? (
                  <>
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
                    Saving...
                  </>
                ) : saveStatus === 'saved' ? (
                  <>
                    <CheckCircle size={16} className="mr-2 text-green-300" />
                    Saved
                  </>
                ) : saveStatus === 'error' ? (
                  <>
                    <AlertCircle size={16} className="mr-2" />
                    Retry Save
                  </>
                ) : (
                  <>
                    <Save size={16} className="mr-2" />
                    Save
                  </>
                )}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default WorkbookLayout;


================================================================================
# FILE: client\pages\WorkbookPageWrapper.js
# EXTENSION: .js
================================================================================
import React from 'react';
import { Box, Container, Paper } from '@mui/material';

const WorkbookPageWrapper = ({ children }) => {
  return (
    <Container maxWidth="xl">
      <Box sx={{ mt: 4, mb: 4 }}>
        <Paper elevation={3} sx={{ p: 3 }}>
          {children}
        </Paper>
      </Box>
    </Container>
  );
};

export default WorkbookPageWrapper;


================================================================================
# FILE: client\postcss.config.js
# EXTENSION: .js
================================================================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


================================================================================
# FILE: client\src\config\api.js
# EXTENSION: .js
================================================================================
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add auth token to requests if available
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default api;


================================================================================
# FILE: client\styles\theme.js
# EXTENSION: .js
================================================================================
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#556cd6',
    },
    secondary: {
      main: '#19857b',
    },
    error: {
      main: '#ff1744',
    },
    background: {
      default: '#fff',
    },
  },
});

export default theme;


================================================================================
# FILE: client\tailwind.config.js
# EXTENSION: .js
================================================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}",
    "./src/**/*.{js,ts,jsx,tsx}"
  ],
  theme: {
    extend: {},
  },
  plugins: [],
  safelist: [
    // Tab colors
    'border-indigo-500', 'text-indigo-600', 'hover:text-indigo-700',
    'border-green-500', 'text-green-600', 'hover:text-green-700',
    'border-purple-500', 'text-purple-600', 'hover:text-purple-700',
    'border-blue-500', 'text-blue-600', 'hover:text-blue-700',
    'border-orange-500', 'text-orange-600', 'hover:text-orange-700',
    'border-red-500', 'text-red-600', 'hover:text-red-700',
    
    // Mobile menu
    'bg-indigo-50', 'text-indigo-700', 
    'bg-green-50', 'text-green-700',
    'bg-purple-50', 'text-purple-700',
    'bg-blue-50', 'text-blue-700',
    'bg-orange-50', 'text-orange-700',
    'bg-red-50', 'text-red-700',
    
    // Buttons
    'bg-indigo-600', 'hover:bg-indigo-700',
    'bg-green-600', 'hover:bg-green-700',
    'bg-purple-600', 'hover:bg-purple-700',
    'bg-blue-600', 'hover:bg-blue-700',
    'bg-orange-600', 'hover:bg-orange-700',
    'bg-red-600', 'hover:bg-red-700'
  ]
  }


================================================================================
# FILE: client\utils\api.js
# EXTENSION: .js
================================================================================
import axios from 'axios';
import Cookies from 'js-cookie';

const isDevelopment = process.env.NODE_ENV === 'development';

const api = axios.create({
  baseURL: isDevelopment ? '' : process.env.NEXT_PUBLIC_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

api.interceptors.request.use((config) => {
  const token = Cookies.get('auth_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export const getMe = async () => {
  try {
    // In development, use the mock API route
    const response = await api.get('/api/auth/me');
    return response.data;
  } catch (error) {
    console.error('Get Me API Error:', {
      status: error.response?.status,
      data: error.response?.data,
      message: error.message
    });
    throw error;
  }
};

export const getCoachingProblems = async () => {
  try {
    const response = await api.get('/coaching/problems');
    
    // Handle both possible response formats
    if (response.data?.success && response.data?.problems) {
      return response.data.problems;
    } else if (response.data?.problems) {
      return response.data.problems;
    } else if (Array.isArray(response.data)) {
      return response.data;
    }

    // Fallback data if response format is unexpected
    return [
      {
        id: "url-shortener",
        title: "Design a URL Shortener",
        difficulty: "intermediate",
        description: "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly.",
        estimatedTime: 45
      },
      {
        id: "social-feed",
        title: "Design a Social Media Feed",
        difficulty: "advanced",
        description: "Design a news feed system that can handle millions of users posting and viewing content in real-time.",
        estimatedTime: 60
      }
    ];
  } catch (error) {
    console.error('Error fetching coaching problems:', error);
    
    if (process.env.NODE_ENV === 'development') {
      // Return mock data in development
      return [
        {
          id: "url-shortener",
          title: "Design a URL Shortener",
          difficulty: "intermediate",
          description: "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly.",
          estimatedTime: 45
        },
        {
          id: "social-feed",
          title: "Design a Social Media Feed",
          difficulty: "advanced",
          description: "Design a news feed system that can handle millions of users posting and viewing content in real-time.",
          estimatedTime: 60
        }
      ];
    }
    
    throw error;
  }
};

export const loginUser = async (email, password) => {
  try {
    // Always use the Next.js API route in development
    const response = await api.post('/api/auth/login', { email, password });
    return response.data;
  } catch (error) {
    console.error('Login API Error:', {
      status: error.response?.status,
      data: error.response?.data,
      message: error.message
    });
    throw error;
  }
};

export const getCoachingSession = async (sessionId) => {
  try {
    // Use the mock API path that matches our existing mock file structure
    const response = await api.get(`/api/mock/coaching/sessions/${sessionId}`);
    return response.data.session || response.data;
  } catch (error) {
    console.error('Error fetching coaching session:', error);
    throw error;
  }
};

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api';

export const sendCoachingMessage = async (sessionId, message, contextInfo = null) => {
  try {
    const response = await fetch(`/api/mock/coaching/message`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messages: [{  // Changed to match the expected format
          role: 'user',
          content: message
        }],
        options: {  // Added options object
          sessionId,
          contextInfo,
          timestamp: new Date().toISOString()
        }
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    
    if (!data?.message?.content) {
      return {
        message: {
          role: 'assistant',
          content: 'I encountered an issue. Could you please rephrase your question?',
          timestamp: new Date().toISOString()
        }
      };
    }

    return data;
  } catch (error) {
    console.error('Error in sendCoachingMessage:', error);
    throw error;
  }
};

export const startCoachingSession = async (problemId) => {
  try {
    const response = await api.post('/coaching/sessions', { 
      problemId: problemId 
    });
    return response.data;
  } catch (error) {
    // If we're in development mode, use mock data
    if (process.env.NODE_ENV === 'development') {
      return {
        session: {
          _id: `mock-session-${Date.now()}`,
          problemId: problemId,
          status: 'active',
          startedAt: new Date().toISOString()
        }
      };
    }
    console.error('Error starting coaching session:', error);
    throw error;
  }
};

export const sendMessage = async (sessionId, message, context = {}) => {
  const response = await fetch(`${API_BASE_URL}/ai/message`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ sessionId, message, context }),
  });
  
  if (!response.ok) {
    throw new Error('Failed to send message');
  }
  
  return response.json();
};

export const analyzeDiagram = async (sessionId, diagram) => {
  const response = await fetch(`${API_BASE_URL}/ai/analyze-diagram`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ sessionId, diagram }),
  });
  
  if (!response.ok) {
    throw new Error('Failed to analyze diagram');
  }
  
  return response.json();
};

export const reviewCode = async (code, context = {}) => {
  const response = await fetch(`${API_BASE_URL}/ai/review-code`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ code, context }),
  });
  
  if (!response.ok) {
    throw new Error('Failed to review code');
  }
  
  return response.json();
};

export default api;


================================================================================
# FILE: client\utils\createEmotionCache.js
# EXTENSION: .js
================================================================================
import createCache from '@emotion/cache';

export default function createEmotionCache() {
  return createCache({ key: 'css', prepend: true });
}


================================================================================
# FILE: client\utils\workbookStorage.js
# EXTENSION: .js
================================================================================
import { saveDiagram } from './api';

const debounce = (func, wait) => {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
};

export const saveWorkbookData = async (sessionId, workbookData, userId, onSaveStatus) => {
  console.log('Saving workbook data:', { sessionId, userId });
  
  if (!sessionId) {
    console.error('Missing sessionId');
    throw new Error('Session ID is required');
  }

  try {
    console.log('Setting save status to saving');
    onSaveStatus?.('saving');

    // Save diagram data separately
    if (workbookData.diagram) {
      console.log('Saving diagram data');
      await saveDiagram(sessionId, workbookData.diagram);
    }

    console.log('Sending workbook data to API');
    const response = await fetch(`/api/workbook/${sessionId}/save`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        userId,
        apis: workbookData.apis,
        apiType: workbookData.apiType,
        requirements: workbookData.requirements,
        architecture: workbookData.architecture,
        lastModified: new Date()
      }),
    });

    if (!response.ok) {
      throw new Error(`Failed to save workbook data: ${response.statusText}`);
    }

    const result = await response.json();
    console.log('Save successful:', result);
    onSaveStatus?.('saved');
    return result;
  } catch (error) {
    console.error('Error in saveWorkbookData:', error);
    onSaveStatus?.('error');
    throw error;
  }
};

// Debounced version for auto-save
export const autoSaveWorkbook = debounce((sessionId, workbookData, userId, onSaveStatus) => {
  console.log('Auto-save triggered');
  return saveWorkbookData(sessionId, workbookData, userId, onSaveStatus);
}, 3000);



================================================================================
# FILE: components\WorkbookLayout.js
# EXTENSION: .js
================================================================================
const WorkbookLayout = ({ sessionId }) => {
  const [state, setState] = useState({
    workbook: initialWorkbookState,
    progress: workbookProgress,
    activeSection: null,
    diagrams: {
      sequence: new Map(),
      system: new Map()
    }
  });

  const handleSectionUpdate = async (section, content) => {
    // Update completion and trigger coach feedback
    const sectionProgress = calculateSectionProgress(section, content);
    const coachFeedback = await getCoachFeedback(section, content);
    
    setState(prev => ({
      ...prev,
      workbook: {
        ...prev.workbook,
        sections: {
          ...prev.workbook.sections,
          [section]: {
            content,
            status: sectionProgress.status,
            feedback: coachFeedback
          }
        }
      },
      progress: updateProgress(prev.progress, section, sectionProgress)
    }));
  };

  const handleDiagramUpdate = async (type, diagram) => {
    const mermaidCode = generateMermaidCode(type, diagram);
    const coachSuggestions = await getCoachDiagramFeedback(type, diagram);
    
    setState(prev => ({
      ...prev,
      diagrams: {
        ...prev.diagrams,
        [type]: {
          ...diagram,
          mermaid: mermaidCode,
          suggestions: coachSuggestions
        }
      }
    }));
  };

  // ... rest of the component
};


================================================================================
# FILE: data\diagram_structure.js
# EXTENSION: .js
================================================================================
const diagramStructure = {
  sequence: {
    metadata: {
      type: 'sequence',
      title: String,
      description: String
    },
    components: {
      actors: [{
        id: String,
        name: String,
        type: 'user' | 'service' | 'database'
      }],
      messages: [{
        from: String, // actor id
        to: String,   // actor id
        label: String,
        order: Number,
        type: 'sync' | 'async' | 'return'
      }]
    },
    mermaid: {
      template: `sequenceDiagram
    {{#each actors}}
    participant {{id}} as {{name}}
    {{/each}}
    {{#each messages}}
    {{from}}->>{{to}}: {{label}}
    {{/each}}`,
      generated: String // final mermaid code
    }
  },
  system: {
    metadata: {
      type: 'system',
      title: String,
      description: String
    },
    components: {
      nodes: [{
        id: String,
        type: 'service' | 'database' | 'cache' | 'loadbalancer' | 'gateway' | 'queue',
        label: String,
        position: { x: Number, y: Number }
      }],
      connections: [{
        from: String,
        to: String,
        type: 'sync' | 'async' | 'depends',
        label: String
      }]
    },
    mermaid: {
      template: `graph TD
    {{#each nodes}}
    {{id}}[{{label}}]
    {{/each}}
    {{#each connections}}
    {{from}} -->|{{label}}| {{to}}
    {{/each}}`,
      generated: String
    }
  }
};


================================================================================
# FILE: data\enhanced_skills.js
# EXTENSION: .js
================================================================================
const skillsFramework = {
  technical: {
    requirements_engineering: {
      weight: 0.15,
      completion_criteria: {
        functional: 0.3,
        nonFunctional: 0.3,
        constraints: 0.2,
        capacity: 0.2
      },
      subskills: [
        'requirement_gathering',
        'constraint_analysis',
        'capacity_planning',
        'edge_case_identification'
      ],
      levels: {
        1: 'Basic requirements listing only',
        2: 'Functional and non-functional separation',
        3: 'Comprehensive with constraints',
        4: 'Detailed capacity planning',
        5: 'Expert-level analysis with edge cases'
      },
      evaluation_points: {
        clarity: 'Requirements are clearly stated and unambiguous',
        completeness: 'All necessary requirements are captured',
        feasibility: 'Requirements are technically feasible',
        testability: 'Requirements can be verified and tested'
      }
    },
    api_design: {
      weight: 0.15,
      completion_criteria: {
        endpoints: 0.3,
        schemas: 0.3,
        security: 0.2,
        documentation: 0.2
      },
      subskills: [
        'rest_principles',
        'authentication_authorization',
        'api_versioning',
        'error_handling'
      ],
      levels: {
        1: 'Basic CRUD endpoints',
        2: 'RESTful design with documentation',
        3: 'Security and rate limiting',
        4: 'Advanced patterns and versioning',
        5: 'Comprehensive API ecosystem design'
      },
      evaluation_points: {
        restfulness: 'Follows REST principles correctly',
        security: 'Implements proper security measures',
        documentation: 'Clear and complete API documentation',
        consistency: 'Consistent naming and response patterns'
      }
    },
    data_modeling: {
      weight: 0.2,
      completion_criteria: {
        schema: 0.4,
        relationships: 0.3,
        optimization: 0.3
      },
      subskills: [
        'schema_design',
        'relationship_modeling',
        'indexing_strategy',
        'partition_planning'
      ],
      levels: {
        1: 'Basic table structure',
        2: 'Proper relationships defined',
        3: 'Normalized with indexes',
        4: 'Optimized for access patterns',
        5: 'Advanced partitioning and scaling'
      },
      evaluation_points: {
        normalization: 'Appropriate level of normalization',
        relationships: 'Correct relationship definitions',
        performance: 'Optimized for query performance',
        scalability: 'Designed for future scaling'
      }
    },
    system_architecture: {
      weight: 0.25,
      completion_criteria: {
        components: 0.3,
        interactions: 0.3,
        scalability: 0.2,
        reliability: 0.2
      },
      subskills: [
        'component_design',
        'service_communication',
        'fault_tolerance',
        'performance_optimization'
      ],
      levels: {
        1: 'Basic component identification',
        2: 'Clear component interactions',
        3: 'Scalability considerations',
        4: 'Advanced patterns and tradeoffs',
        5: 'Comprehensive distributed system design'
      },
      evaluation_points: {
        separation: 'Clear separation of concerns',
        coupling: 'Appropriate level of coupling',
        resilience: 'System fault tolerance',
        scalability: 'Ability to scale components'
      }
    },
    scalability_design: {
    
      weight: 0.15,
      completion_criteria: {
        bottlenecks: 0.3,
        solutions: 0.3,
        tradeoffs: 0.2,
        metrics: 0.2
      },
      subskills: [
        'load_balancing',
        'caching_strategy',
        'database_scaling',
        'performance_monitoring'
      ],
      levels: {
        1: 'Basic bottleneck identification',
        2: 'Common scaling solutions',
        3: 'Detailed capacity planning',
        4: 'Advanced optimization strategies',
        5: 'Expert-level distributed scaling'
      },
      evaluation_points: {
        bottlenecks: 'Identification of system bottlenecks',
        solutions: 'Appropriate scaling solutions',
        monitoring: 'Performance monitoring strategy',
        cost: 'Cost-effectiveness of solutions'
      }
    }
  },
  soft: {
    communication: {
      weight: 0.1,
      completion_criteria: {
        clarity: 0.4,
        structure: 0.3,
        terminology: 0.3
      },
      subskills: [
        'technical_explanation',
        'diagram_communication',
        'tradeoff_discussion',
        'requirement_clarification'
      ],
      levels: {
        1: 'Basic technical vocabulary',
        2: 'Clear explanation of concepts',
        3: 'Effective tradeoff discussion',
        4: 'Excellent diagram communication',
        5: 'Expert system presentation'
      },
      evaluation_points: {
        clarity: 'Clear and concise communication',
        audience: 'Appropriate for technical audience',
        completeness: 'All key points covered',
        engagement: 'Maintains audience engagement'
      }
    },
    problem_solving: {
      weight: 0.1,
      completion_criteria: {
        approach: 0.4,
        adaptability: 0.3,
        reasoning: 0.3
      },
      subskills: [
        'problem_breakdown',
        'solution_analysis',
        'tradeoff_evaluation',
        'edge_case_handling'
      ],
      levels: {
        1: 'Basic problem breakdown',
        2: 'Structured approach',
        3: 'Effective tradeoff analysis',
        4: 'Creative solution finding',
        5: 'Expert problem optimization'
      },
      evaluation_points: {
        methodology: 'Structured problem-solving approach',
        creativity: 'Creative solution generation',
        practicality: 'Practical and implementable solutions',
        completeness: 'Comprehensive problem coverage'
      }
    }
  }
};

// Enhanced utility functions
module.exports = {
  skillsFramework,
  
  calculateSkillLevel: (skill, metrics) => {
    const criteria = skillsFramework[skill.category][skill.name].completion_criteria;
    const weightedScore = Object.entries(criteria).reduce((total, [key, weight]) => {
      return total + (metrics[key] || 0) * weight;
    }, 0);
    
    // Return both raw score and level
    return {
      score: weightedScore,
      level: Math.min(5, Math.ceil(weightedScore * 5))
    };
  },

  getSkillFeedback: (skill, metrics) => {
    const skillInfo = skillsFramework[skill.category][skill.name];
    const { score, level } = module.exports.calculateSkillLevel(skill, metrics);
    
    return {
      currentLevel: skillInfo.levels[level],
      nextLevel: level < 5 ? skillInfo.levels[level + 1] : null,
      gap: 1 - (score % 1),
      strengths: Object.entries(metrics)
        .filter(([_, value]) => value >= 0.8)
        .map(([key]) => skillInfo.evaluation_points[key]),
      improvements: Object.entries(metrics)
        .filter(([_, value]) => value < 0.6)
        .map(([key]) => skillInfo.evaluation_points[key])
    };
  },

  evaluateSkillProgress: (skill, previousMetrics, currentMetrics) => {
    const previous = module.exports.calculateSkillLevel(skill, previousMetrics);
    const current = module.exports.calculateSkillLevel(skill, currentMetrics);
    
    return {
      improvement: current.score - previous.score,
      levelChange: current.level - previous.level,
      significantAreas: Object.keys(currentMetrics).filter(key => 
        (currentMetrics[key] - (previousMetrics[key] || 0)) > 0.2
      )
    };
  },

  getSkillRequirements: (skill, targetLevel) => {
    const skillInfo = skillsFramework[skill.category][skill.name];
    return {
      required: skillInfo.subskills.slice(0, targetLevel * 2),
      recommended: skillInfo.subskills.slice(targetLevel * 2),
      evaluationCriteria: Object.entries(skillInfo.evaluation_points)
        .reduce((acc, [key, value]) => {
          acc[key] = {
            description: value,
            minimumScore: targetLevel / 5
          };
          return acc;
        }, {})
    };
  }
};



================================================================================
# FILE: data\persona\coachPersona.js
# EXTENSION: .js
================================================================================
// server/data/persona/coachPersona.js

module.exports = {
  id: "coach",
  name: "Design Coach",
  problems: {
    "url-shortener": {
      title: "URL Shortener System Design",
      greeting: "Welcome to the URL Shortener System Design session! \n\nWe'll be designing a service like bit.ly that takes long URLs and creates short, memorable links. When users visit the short link, they'll be redirected to the original URL.\n\nTo begin, what key components do you think we'll need for this service?",
      description: "A URL shortening service that creates compact links",
      example: "Converting long URLs into short, memorable links",
      stages: {
        requirements: {
          questions: [
            "What are the core features we need?",
            "What's our expected scale (traffic, storage)?",
            "What are the performance requirements?"
          ]
        },
        architecture: {
          components: [
            "Load Balancer",
            "Web Servers",
            "Database",
            "Cache Layer"
          ]
        }
      }
    },
    "social-feed": {
      title: "Social Media Feed System Design",
      greeting: "Welcome to the Social Media Feed design session! \n\nWe'll be designing a news feed system similar to Facebook or Twitter that can handle millions of users posting and viewing content in real-time.\n\nLet's start with the basic requirements. What features should our feed system support?",
      description: "A scalable social media feed system",
      example: "Real-time content delivery to millions of users",
      stages: {
        requirements: {
          questions: [
            "What types of content should we support?",
            "How many daily active users do we expect?",
            "What are our latency requirements?"
          ]
        },
        architecture: {
          components: [
            "Frontend Servers",
            "Feed Service",
            "Content Store",
            "User Graph Service"
          ]
        }
      }
    }
  },
  systemPrompt: `You are a System Design Coach specializing in helping users learn and apply system design concepts. Your purpose is to guide users through the learning process without directly solving their problems. Adapt your teaching style based on the user's demonstrated knowledge level while remaining supportive and educational.

When starting a new session, ALWAYS begin with a clear problem introduction that includes:
1. A welcoming greeting
2. A brief, clear description of what we're building
3. A simple real-world example of how it works
4. An open-ended question to start the discussion`
};



================================================================================
# FILE: data\persona\graderPersona.js
# EXTENSION: .js
================================================================================
// server/data/personas/graderPersona.js

module.exports = {
   id: "grader",
   name: "Design Grader",
   role: "grader",
   description:
     "An objective system design grader that evaluates designs based on a structured rubric. Provide both numerical scores and qualitative feedback without being overly critical.",
   systemPrompt: `
 You are a System Design Grader responsible for evaluating system design solutions.
 Use a consistent, objective evaluation framework that covers requirements analysis, architecture, data modeling, scalability, and reliability.
 Provide a brief summary assessment with numerical scores and actionable feedback for improvement.
 Your tone is neutral and analytical, focusing on substance rather than presentation style.
 
 EVALUATION FRAMEWORK:
 - Requirements Analysis: Assess clarity and completeness.
 - System Interface: Evaluate API design and consistency.
 - Capacity Estimation: Review assumptions and calculations.
 - Data Modeling: Examine schema design and relationships.
 - High-Level Architecture: Consider component interactions.
 - Scalability & Performance: Check for bottlenecks and optimization.
 - Reliability & Fault Tolerance: Evaluate redundancy and failure recovery.
 
 Provide your feedback with both scores and specific suggestions for improvement.
 `,
   suggestions: [
     "What are the most critical gaps in this design?",
     "How could the scalability be improved?",
     "What trade-offs should be considered to optimize performance?"
   ],
   responsePatterns: {
     default:
       "Provide a structured evaluation with a summary, dimensional breakdown, and prioritized improvements.",
     concise:
       "Give a brief summary of strengths and weaknesses along with key improvement suggestions."
   }
 };
 


================================================================================
# FILE: data\persona\interviewerPersona.js
# EXTENSION: .js
================================================================================
// server/data/personas/interviewerPersona.js

module.exports = {
    id: "interviewer",
    name: "Design Interviewer",
    role: "interviewer",
    description:
      "A professional system design interviewer who simulates a FAANG-level technical interview. You assess system design skills by asking challenging questions and probing the candidates reasoning.",
    systemPrompt: `
  You are a System Design Interviewer simulating a realistic FAANG-level technical interview.
  Your role is to challenge the candidate with probing questions while maintaining a neutral, professional tone.
  Ask clear, focused questions and request trade-off justifications without giving direct solutions.
  
  INTERVIEW STRUCTURE:
  1. Clarify the problem statement.
  2. Ask about functional and non-functional requirements.
  3. Probe the high-level architecture and component interactions.
  4. Challenge the candidate on scalability, performance, and reliability aspects.
  5. Wrap up by summarizing strengths and weaknesses.
  
  Keep your responses concise and use a Socratic approach. Do not provide direct solutions.
  `,
    suggestions: [
      "Can you explain how your design handles a sudden traffic spike?",
      "What are the trade-offs of your chosen architecture?",
      "How do you plan to monitor and scale this system?"
    ],
    pageSuggestions: {
      general: [
        "Could you clarify your assumptions?",
        "What alternative approaches did you consider?"
      ]
    },
    responsePatterns: {
      default:
        "Ask follow-up questions to probe deeper into the candidate's design decisions.",
      concise:
        "Pose a clear, focused question that challenges the candidate to justify their choices."
    }
  };
  


================================================================================
# FILE: data\problems.js
# EXTENSION: .js
================================================================================
// server/data/problems.js
// This file exports an array of detailed problem contexts for your system design challenges.
// Each problem includes extensive details such as constraints, scale requirements, architecture notes,
// business requirements, user stories, performance metrics, and additional considerations.

module.exports = [
    {
      id: "url-shortener", // Changed to match coachPersona.js
      title: "URL Shortener Service",
      description: "Design a scalable URL shortener service similar to TinyURL or bit.ly. The service must generate unique short URLs that redirect to the original long URLs.",
      additionalInfo: "The service should support high-frequency URL creation and redirection, include URL analytics, abuse prevention, custom aliases, and expiration policies.",
      constraints: {
        shortCodeLength: 7,
        redirectionLatency: "Target <50ms under peak load",
        availability: "99.99% uptime with multi-region support",
        security: "Validate URLs to prevent injection; enforce rate limiting and anti-abuse measures",
        dataConsistency: "Eventual consistency for URL mappings; strong consistency for analytics data"
      },
      scaleRequirements: {
        estimatedQPS: "Approximately 1000 QPS during peak hours",
        expectedDataVolume: "Billions of URL mappings over time",
        storage: "In-memory caches (e.g., Redis) for fast lookups plus persistent storage (e.g., NoSQL) for durability",
        cachingStrategy: "Aggressive caching for redirection paths with periodic persistence updates"
      },
      architectureNotes: "Consider a distributed microservice architecture with components for URL generation, redirection, and analytics. Use a distributed hash table for mappings and plan for collision resolution, custom aliases, and URL expiration.",
      businessRequirements: "Monetization via premium custom URLs and analytics dashboards; integration with third-party platforms via a robust API.",
      userStories: [
        "As a user, I want to quickly shorten a long URL for easy sharing.",
        "As an admin, I need to monitor URL usage and detect abuse.",
        "As a developer, I want a reliable API for URL shortening integration."
      ],
      performanceMetrics: {
        averageResponseTime: "<50ms for redirects",
        throughput: "Support at least 1 million redirections per day",
        errorRate: "<0.1% failed redirections"
      },
      additionalConsiderations: "Handle duplicate requests, custom alias conflicts, and periodic cleanup of expired URLs."
    },
    {
      id: "socialMediaFeed",
      title: "Social Media Feed",
      description: "Design a system to provide a personalized, real-time feed for a social media platform that aggregates posts, images, videos, and trending topics.",
      additionalInfo: "The feed must support both algorithmic and chronological ordering and enable user interactions (likes, comments, shares) with continuous updates.",
      constraints: {
        personalization: "Tailor feed ranking based on user behavior and interests",
        refreshLatency: "Feed updates within 200ms for active users",
        availability: "99.9% uptime during peak usage",
        consistency: "Eventual consistency for feed data; strong consistency for critical interactions"
      },
      scaleRequirements: {
        estimatedQPS: "Tens of thousands of QPS during peak periods",
        expectedDataVolume: "Billions of posts, comments, and media references",
        storage: "Distributed storage for posts/media, with CDNs for media delivery",
        caching: "In-memory caching for frequently accessed timelines and trending topics"
      },
      architectureNotes: "Adopt a hybrid approach using both push and pull for feed updates. Employ message queues for notifications and microservices for separation of concerns across post management, user interactions, and trending analytics.",
      businessRequirements: "Integration with advertising platforms, monetization through sponsored posts, and developer APIs for third-party integrations.",
      userStories: [
        "As a user, I want a feed that updates to reflect my interests.",
        "As a content creator, I need analytics on engagement.",
        "As a marketer, I want targeted advertising based on trends."
      ],
      performanceMetrics: {
        refreshTime: "Under 200ms for timeline updates",
        dailyActiveUsers: "Support up to 100 million users",
        errorRate: "<0.5% feed failures during peak load"
      },
      additionalConsiderations: "Address content moderation, spam filtering, and bot content; balance algorithmic recommendations with user control."
    },
    {
      id: "rideSharing",
      title: "Ride Sharing Application",
      description: "Design a ride-sharing system that efficiently matches drivers with riders in real-time, handling dynamic pricing and high availability.",
      additionalInfo: "The application must process real-time location data, perform rapid driver-rider matching, and support surge pricing along with robust notifications and in-app payments.",
      constraints: {
        realTimeProcessing: "Process location updates and matching within 100ms",
        dynamicPricing: "Implement a transparent, near real-time surge pricing algorithm",
        availability: "High fault tolerance with multi-region redundancy",
        security: "Secure user data (location, payment) with encryption and strong authentication"
      },
      scaleRequirements: {
        estimatedQPS: "Support thousands of concurrent ride requests during peak events",
        dataVolume: "Continuous streams of geolocation data from many users",
        storage: "Geospatial databases for tracking and scalable messaging systems (e.g., Kafka) for real-time data",
        caching: "Caching for high-frequency lookups of driver availability and nearby requests"
      },
      architectureNotes: "Use a microservices architecture with dedicated services for matching, pricing, notifications, and payments. Employ event-driven communication for real-time updates and design regional clusters to minimize latency.",
      businessRequirements: "Include driver and rider ratings, in-app payments, and support for scheduled/on-demand rides; integrate with mapping/navigation APIs.",
      userStories: [
        "As a rider, I want to request a ride quickly and see my pickup time.",
        "As a driver, I need clear ride requests with pickup/drop-off details.",
        "As an operator, I want to monitor ride activity and adjust surge pricing dynamically."
      ],
      performanceMetrics: {
        matchingLatency: "<100ms for pairing",
        systemUptime: "99.95% uptime",
        successRate: "Over 99% ride completion success"
      },
      additionalConsiderations: "Plan for cancellations, no-shows, and traffic variations; consider integration with public transit data and robust peak-load handling."
    }
  ];
  


================================================================================
# FILE: data\workbook_progress.js
# EXTENSION: .js
================================================================================
const workbookProgress = {
  overall: {
    completion: {
      percentage: Number,
      sections: Map<string, number>, // section -> completion %
      lastUpdated: Date
    },
    excellence: {
      areas: [{
        section: String,
        score: Number,
        highlights: [String]
      }],
      threshold: 0.85 // 85% for excellence
    },
    improvements: {
      priority: [{
        section: String,
        aspect: String,
        suggestion: String,
        impact: 'high' | 'medium' | 'low'
      }],
      optional: [{
        section: String,
        suggestion: String,
        benefit: String
      }]
    }
  },
  sections: {
    requirements: {
      status: {
        completion: Number,
        quality: Number,
        lastFeedback: Date
      },
      feedback: {
        strengths: [String],
        improvements: [String],
        coachNotes: String
      }
    }
    // ... similar for other sections
  }
};


================================================================================
# FILE: server\app.js
# EXTENSION: .js
================================================================================
const express = require('express');
const cors = require('cors');
const connectDB = require('./config/db');
const logger = require('./utils/logger');

const app = express();

// Connect Database
connectDB();

// Middleware
app.use(cors());
app.use(express.json());

// Basic health check route
app.get('/', (req, res) => {
  res.json({ status: 'ok', message: 'Server is running' });
});

// API Routes
app.use('/api/auth', require('./routes/auth'));
app.use('/api/users', require('./routes/users'));
app.use('/api/problems', require('./routes/problems'));
app.use('/api/interviews', require('./routes/interviews'));
app.use('/api/workbook', require('./routes/workbook'));
app.use('/api/coaching', require('./routes/api/coaching'));

// Error handling middleware
app.use((err, req, res, next) => {
  logger.error(err.stack);
  res.status(500).json({ success: false, error: 'Server error' });
});

module.exports = app;



================================================================================
# FILE: server\config\aiConfig.js
# EXTENSION: .js
================================================================================
const AI_PROVIDER = 'claude';
const CLAUDE_MODEL = 'claude-3-7-sonnet-latest';  // Single source of truth

const providers = {
  claude: {
    name: 'claude',
    model: CLAUDE_MODEL,
    maxTokens: 4096,
    temperature: 0.7,
    apiKey: process.env.ANTHROPIC_API_KEY,
    defaultSystemPrompt: "You are an expert system design coach helping developers improve their architecture and implementation decisions."
  }
};

module.exports = {
  activeProvider: AI_PROVIDER,
  config: providers[AI_PROVIDER],
  providers,
  CLAUDE_MODEL  // Export the constant
};



================================================================================
# FILE: server\config\db.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');
const logger = require('../utils/logger');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI);
    logger.info(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    logger.error(`Error: ${error.message}`);
    process.exit(1);
  }
};

// Handle connection errors after initial connection
mongoose.connection.on('error', (err) => {
  logger.error(`MongoDB connection error: ${err}`);
});

mongoose.connection.on('disconnected', () => {
  logger.warn('MongoDB disconnected');
});

module.exports = connectDB;


================================================================================
# FILE: server\index.js
# EXTENSION: .js
================================================================================
require('dotenv').config();
const app = require('./app');
const logger = require('./utils/logger');

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  logger.info(`Server running on port ${PORT}`);
});



================================================================================
# FILE: server\middleware\auth.js
# EXTENSION: .js
================================================================================
const jwt = require('jsonwebtoken');

module.exports = (req, res, next) => {
  try {
    // Get token from header or cookie
    const authHeader = req.header('Authorization');
    const token = authHeader ? authHeader.replace('Bearer ', '') : req.cookies?.auth_token;

    if (!token) {
      return res.status(401).json({
        success: false,
        error: 'No token, authorization denied'
      });
    }

    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Add user info to request
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({
      success: false,
      error: 'Token is not valid'
    });
  }
};


================================================================================
# FILE: server\models\Diagram.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');

const DiagramSchema = new mongoose.Schema({
  sessionId: {
    type: String,
    required: true,
    index: true
  },
  diagramId: {
    type: String,
    required: true,
    index: true
  },
  type: {
    type: String,
    required: true,
    enum: ['system', 'sequence']
  },
  // Store both ReactFlow and Mermaid representations
  reactFlow: {
    nodes: [{
      id: String,
      type: String,
      position: {
        x: Number,
        y: Number
      },
      data: mongoose.Schema.Types.Mixed,
      // Additional positioning metadata
      mermaidPosition: {
        order: Number,      // For sequence diagrams
        level: Number,      // For system diagrams, vertical level
        column: Number      // For system diagrams, horizontal position
      }
    }],
    edges: [{
      id: String,
      source: String,
      target: String,
      type: String,
      sourceHandle: String,
      targetHandle: String,
      data: mongoose.Schema.Types.Mixed,
      // Store exact positions for recreation
      sourcePosition: {
        x: Number,
        y: Number
      },
      targetPosition: {
        x: Number,
        y: Number
      }
    }]
  },
  mermaidCode: {
    type: String,
    required: true
  },
  currentScore: Number,
  lastUpdated: {
    type: Date,
    default: Date.now
  }
});

// Indexes for efficient querying
DiagramSchema.index({ sessionId: 1, diagramId: 1 }, { unique: true });
DiagramSchema.index({ lastUpdated: -1 });
DiagramSchema.index({ currentScore: -1 });

module.exports = mongoose.model('Diagram', DiagramSchema);



================================================================================
# FILE: server\models\Evaluation.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');

const EvaluationSchema = new mongoose.Schema({
  sessionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Session',
    required: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  problemId: {
    type: String,
    required: true
  },
  criteria: [{
    name: String,
    score: Number,
    feedback: String
  }],
  overallScore: {
    type: Number,
    required: true
  },
  feedback: {
    strengths: [String],
    improvements: [String],
    generalComments: String
  },
  evaluatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

EvaluationSchema.index({ sessionId: 1 }, { name: 'evaluation_session_id' });
EvaluationSchema.index({ userId: 1 }, { name: 'evaluation_user_id' });
EvaluationSchema.index({ problemId: 1 }, { name: 'evaluation_problem_id' });

const Evaluation = mongoose.model('Evaluation', EvaluationSchema);
module.exports = Evaluation;



================================================================================
# FILE: server\models\Interview.js
# EXTENSION: .js
================================================================================
// server/models/Interview.js
const mongoose = require('mongoose');

const interviewSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  problemId: {
    type: String,
    required: true
  },
  // Add type field to distinguish between interview and coaching sessions
  type: {
    type: String,
    enum: ['interview', 'coaching'],
    default: 'interview'
  },
  status: {
    type: String,
    enum: ['pending', 'in_progress', 'completed'],
    default: 'in_progress'
  },
  conversation: [{
    role: {
      type: String,
      // Add coach and student roles
      enum: ['interviewer', 'candidate', 'coach', 'student', 'system'],
      required: true
    },
    
    content: {
      type: String,
      required: true
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    metadata: {
      type: Map,
      of: mongoose.Schema.Types.Mixed
    }
  }],
    diagrams: [{
        type: {
        type: String,
        enum: ['architecture', 'sequence', 'systems', 'er', 'component'],
        default: 'architecture'
        },
        mermaidCode: {
        type: String,
        required: true
        },
        reactFlowData: {
        type: Object  // Store React Flow's JSON representation
        },
        name: {
        type: String,
        default: 'System Design'
        },
        createdAt: {
        type: Date,
        default: Date.now
        },
        updatedAt: {
        type: Date,
        default: Date.now
        },
        history: [{
        mermaidCode: String,
        reactFlowData: Object,
        timestamp: {
            type: Date,
            default: Date.now
        }
        }]
  }],
  currentStage: {
    type: String,
    // Don't use enum here to allow flexibility between interview and coaching stages
    default: 'intro'
  },
  currentQuestion: {
    type: Number,
    default: 0
  },
  evaluation: {
    score: Number,
    feedback: String,
    strengths: [String],
    weaknesses: [String],
    areas_to_improve: [String],
    criteriaScores: {
      type: Map,
      of: Number
    }
  },
  duration: {
    type: Number,  // Interview duration in seconds
    default: 0
  },
  startedAt: {
    type: Date,
    default: Date.now
  },
  completedAt: Date
});

// Add index for faster queries - include type for better filtering
interviewSchema.index({ userId: 1, status: 1, type: 1 });

module.exports = mongoose.model('Interview', interviewSchema);


================================================================================
# FILE: server\models\Problem.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');

const ProblemSchema = new mongoose.Schema({
  id: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  title: {
    type: String,
    required: true
  },
  difficulty: {
    type: String,
    enum: ['easy', 'medium', 'hard'],
    required: true
  },
  category: {
    type: String,
    required: true,
    index: true
  },
  requirements: {
    functional: [String],
    nonFunctional: [String]
  },
  constraints: {
    scale: String,
    storage: String,
    bandwidth: String
  },
  expectedComponents: [String],
  evaluation: {
    criteria: [{
      name: String,
      weight: Number,
      description: String
    }],
    rubric: {
      excellent: String,
      good: String,
      fair: String,
      poor: String
    }
  },
  metadata: {
    createdAt: {
      type: Date,
      default: Date.now
    },
    updatedAt: {
      type: Date,
      default: Date.now
    }
  }
});

ProblemSchema.index({ difficulty: 1, category: 1 });

const Problem = mongoose.model('Problem', ProblemSchema);
module.exports = Problem;


================================================================================
# FILE: server\models\Session.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');

const SessionSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  type: {
    type: String,
    enum: ['interview', 'coaching'],
    required: true
  },
  status: {
    type: String,
    enum: ['active', 'completed', 'cancelled'],
    default: 'active'
  },
  startTime: {
    type: Date,
    default: Date.now
  },
  endTime: Date
}, {
  timestamps: true
});

SessionSchema.index({ userId: 1 }, { name: 'session_user_id' });
SessionSchema.index({ status: 1 }, { name: 'session_status' });

const Session = mongoose.model('Session', SessionSchema);
module.exports = Session;



================================================================================
# FILE: server\models\User.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');

const UserSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  email: {
    type: String,
    required: true,
    unique: true // This will create the index automatically
  },
  password: {
    type: String,
    required: true
  },
  experience: {
    type: String,
    enum: ['beginner', 'intermediate', 'expert'],
    default: 'beginner'
  }
}, {
  timestamps: true
});

// Remove explicit index definition since we're using unique: true in the schema
// UserSchema.index({ email: 1 }, { unique: true, name: 'user_email_unique' });

const User = mongoose.model('User', UserSchema);
module.exports = User;



================================================================================
# FILE: server\models\Workbook.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');

const DiagramSchema = new mongoose.Schema({
  type: {
    type: String,
    enum: ['system', 'sequence'],
    required: true
  },
  nodes: [{
    id: String,
    type: String,
    position: {
      x: Number,
      y: Number
    },
    data: mongoose.Schema.Types.Mixed
  }],
  edges: [{
    id: String,
    source: String,
    target: String,
    type: String,
    data: mongoose.Schema.Types.Mixed
  }],
  mermaidCode: String,
  metadata: {
    lastUpdated: {
      type: Date,
      default: Date.now
    },
    version: {
      type: Number,
      default: 1
    }
  }
});

const SectionSchema = new mongoose.Schema({
  content: String,
  status: {
    type: String,
    enum: ['not_started', 'in_progress', 'completed', 'reviewed'],
    default: 'not_started'
  },
  feedback: [{
    type: {
      type: String,
      enum: ['coach', 'system', 'manual'],
      required: true
    },
    content: String,
    timestamp: Date
  }],
  evaluation: {
    score: Number,
    strengths: [String],
    improvements: [String],
    timestamp: Date
  }
});

const WorkbookSchema = new mongoose.Schema({
  sessionId: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  problemId: {
    type: String,
    required: true,
    index: true
  },
  sections: {
    requirements: {
      functional: SectionSchema,
      nonFunctional: SectionSchema
    },
    api: {
      endpoints: SectionSchema,
      documentation: SectionSchema
    },
    database: {
      schema: SectionSchema,
      queries: SectionSchema
    },
    architecture: {
      highLevel: SectionSchema,
      detailed: SectionSchema
    }
  },
  diagrams: {
    system: DiagramSchema,
    sequence: DiagramSchema
  },
  progress: {
    overall: {
      type: Number,
      default: 0
    },
    sections: Map,
    lastUpdated: Date
  },
  metadata: {
    status: {
      type: String,
      enum: ['active', 'completed', 'archived'],
      default: 'active'
    },
    createdAt: {
      type: Date,
      default: Date.now
    },
    updatedAt: {
      type: Date,
      default: Date.now
    }
  }
});

WorkbookSchema.pre('save', function(next) {
  this.metadata.updatedAt = new Date();
  next();
});

module.exports = mongoose.model('Workbook', WorkbookSchema);



================================================================================
# FILE: server\prompts\coachingPrompt.js
# EXTENSION: .js
================================================================================
const getSystemPrompt = (problem) => `
You are an expert system design coach helping a developer design a ${problem} system.
Focus on:
1. Architecture decisions
2. Scalability considerations
3. Best practices
4. Trade-offs

Keep responses concise and technical. Ask probing questions to guide the developer's thinking.
`;

module.exports = {
  getSystemPrompt
};


================================================================================
# FILE: server\routes\ai.js
# EXTENSION: .js
================================================================================
const express = require('express');
const router = express.Router();
const { CoachingService } = require('../services/coaching/coachingService');
const logger = require('../utils/logger');

const coachingService = new CoachingService();

router.post('/message', async (req, res) => {
  try {
    const { sessionId, message, context } = req.body;
    
    logger.info('Processing AI message:', {
      sessionId,
      messagePreview: message.substring(0, 100),
      context
    });

    const response = await coachingService.processMessage(sessionId, message, context);
    
    res.json({ 
      success: true, 
      response 
    });
  } catch (error) {
    logger.error('AI Message Error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

router.post('/analyze-diagram', async (req, res) => {
  try {
    const { sessionId, diagram } = req.body;
    const analysis = await coachingService.analyzeDiagram(sessionId, diagram);
    res.json({ success: true, analysis });
  } catch (error) {
    logger.error('Diagram Analysis Error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

router.post('/review-code', async (req, res) => {
  try {
    const { code, context } = req.body;
    const review = await coachingService.reviewCode(code, context);
    res.json({ success: true, review });
  } catch (error) {
    logger.error('Code Review Error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

router.post('/suggest-requirements', async (req, res) => {
  try {
    const { functionalReqs, nonFunctionalReqs, constraints, assumptions } = req.body;
    
    const context = {
      currentRequirements: {
        functional: functionalReqs,
        nonFunctional: nonFunctionalReqs,
        constraints,
        assumptions
      }
    };

    const suggestions = await coachEngine.generateSuggestions('requirements', context);
    
    res.json(suggestions);
  } catch (error) {
    console.error('Error generating requirements suggestions:', error);
    res.status(500).json({ error: 'Failed to generate suggestions' });
  }
});

router.post('/analyze-requirements-diagram', async (req, res) => {
  try {
    const { diagramData, requirements } = req.body;
    
    // Analyze diagram components and their relationship to requirements
    const analysis = await diagramAnalyzer.analyzeDiagram(
      diagramData.nodes,
      diagramData.edges,
      'system'
    );

    // Get suggestions for improving the diagram based on requirements
    const suggestions = await diagramService.generateSuggestions(
      diagramData,
      requirements
    );

    res.json({
      analysis,
      suggestions
    });
  } catch (error) {
    console.error('Error analyzing requirements diagram:', error);
    res.status(500).json({ error: 'Failed to analyze diagram' });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\api\coaching.js
# EXTENSION: .js
================================================================================
const express = require('express');
const router = express.Router();
const auth = require('../../middleware/auth');
const Problem = require('../../models/Problem');
const logger = require('../../utils/logger');

// Get all available problems
router.get('/problems', auth, async (req, res) => {
  try {
    // Fallback data in case database is empty
    const defaultProblems = [
      {
        id: "url-shortener",
        title: "Design a URL Shortener",
        difficulty: "intermediate",
        description: "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly.",
        estimatedTime: 45
      },
      {
        id: "social-feed",
        title: "Design a Social Media Feed",
        difficulty: "advanced",
        description: "Design a news feed system that can handle millions of users posting and viewing content in real-time.",
        estimatedTime: 60
      }
    ];

    let problems;
    
    try {
      problems = await Problem.find().select('-evaluation');
      
      // If no problems in DB, use default ones
      if (!problems || problems.length === 0) {
        problems = defaultProblems;
      }
    } catch (dbError) {
      logger.warn('Database error, falling back to default problems:', dbError);
      problems = defaultProblems;
    }

    res.json({ success: true, problems });
  } catch (error) {
    logger.error('Error in /problems route:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Server error',
      message: error.message 
    });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\auth.js
# EXTENSION: .js
================================================================================
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const User = require('../models/User');
const logger = require('../utils/logger');

const router = express.Router();

router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });

    if (!user) {
      return res.status(401).json({ 
        success: false,  // Add success flag
        error: 'Invalid credentials' 
      });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(401).json({ 
        success: false,  // Add success flag
        error: 'Invalid credentials' 
      });
    }

    const token = jwt.sign(
      { userId: user._id },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      success: true,  // Add success flag
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        experience: user.experience
      }
    });
  } catch (error) {
    logger.error('Login error:', error);
    res.status(500).json({ 
      success: false,  // Add success flag
      error: 'Server error' 
    });
  }
});

router.post('/register', async (req, res) => {
  try {
    const { name, email, password, experience } = req.body;
    
    let user = await User.findOne({ email });
    if (user) {
      return res.status(400).json({ error: 'User already exists' });
    }

    user = new User({
      name,
      email,
      password: await bcrypt.hash(password, 10),
      experience
    });

    await user.save();

    const token = jwt.sign(
      { userId: user._id },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.status(201).json({
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        experience: user.experience
      }
    });
  } catch (error) {
    logger.error('Registration error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

router.get('/me', async (req, res) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '') || 
                  req.cookies?.auth_token;

    if (!token) {
      return res.status(401).json({
        success: false,
        error: 'No token provided'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.userId).select('-password');

    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    res.json({
      success: true,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        experience: user.experience
      }
    });
  } catch (error) {
    logger.error('Get me error:', error);
    res.status(401).json({
      success: false,
      error: 'Invalid token'
    });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\coaching.js
# EXTENSION: .js
================================================================================
const express = require('express');
const router = express.Router();
const auth = require('../middleware/auth');
const Session = require('../models/Session');
const Problem = require('../models/Problem');
const coachEngine = require('../services/engines/coachEngine'); 

// Get all coaching problems
router.get('/problems', auth, async (req, res) => {
  try {
    // Load problems directly from the data file
    const problems = require('../../data/problems');
    res.json({ success: true, problems });
  } catch (error) {
    console.error('Error fetching coaching problems:', error);
    res.status(500).json({ success: false, error: 'Server error' });
  }
});

// Start new coaching session
router.post('/sessions', auth, async (req, res) => {
  try {
    const { problemId } = req.body;
    const userId = req.user.id;

    const session = await coachEngine.startSession(userId, problemId);
    res.json({ success: true, session });
  } catch (error) {
    console.error('Error creating coaching session:', error);
    res.status(500).json({ success: false, error: 'Server error' });
  }
});

// Get session by ID with better error handling
router.get('/sessions/:id', auth, async (req, res) => {
  try {
    const session = await Session.findById(req.params.id);
    if (!session) {
      return res.status(404).json({ 
        success: false, 
        error: 'Session not found' 
      });
    }
    res.json({ success: true, session });
  } catch (error) {
    console.error('Error fetching session:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message || 'Internal server error' 
    });
  }
});

// Add message endpoint
router.post('/sessions/:id/message', auth, async (req, res) => {
  try {
    const { message, options } = req.body;
    const response = await coachEngine.processMessage(req.params.id, message, options);
    res.json({ success: true, response });
  } catch (error) {
    console.error('Error in coaching message:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\diagrams.js
# EXTENSION: .js
================================================================================
const express = require('express');
const router = express.Router();
const DiagramAnalyzer = require('../services/diagram/diagramAnalyzer');
const DiagramManager = require('../services/diagram/diagramManager');

const analyzer = new DiagramAnalyzer();
const manager = new DiagramManager();

router.post('/analyze', async (req, res) => {
  try {
    const { nodes, edges } = req.body;
    const analysis = await analyzer.analyzeDiagram(nodes, edges);
    res.json(analysis);
  } catch (error) {
    console.error('Error analyzing diagram:', error);
    res.status(500).json({ error: 'Failed to analyze diagram' });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\grader.js
# EXTENSION: .js
================================================================================
// server/routes/grader.js
const express = require('express');
const router = express.Router();
const graderEngine = require('../services/engines/graderEngine');
const Evaluation = require('../models/Evaluation');
const auth = require('../middleware/auth');

// Route to evaluate current workbook
router.post('/evaluate/:sessionId', auth, async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { workbookContent, userLevel, conciseMode = true } = req.body;
    
    const result = await graderEngine.evaluateWorkbook(
      sessionId,
      workbookContent,
      { userLevel, conciseMode }
    );
    
    res.json(result);
  } catch (error) {
    console.error('Grader evaluation error:', error);
    res.status(500).json({ 
      message: 'Error evaluating workbook', 
      error: error.message 
    });
  }
});

// Route to provide final assessment for an interview
router.post('/assessment/:interviewId', auth, async (req, res) => {
  try {
    const { interviewId } = req.params;
    const { userLevel, conciseMode = true } = req.body;
    
    const result = await graderEngine.provideFinalAssessment(
      interviewId,
      { userLevel, conciseMode }
    );
    
    res.json(result);
  } catch (error) {
    console.error('Final assessment error:', error);
    res.status(500).json({ 
      message: 'Error generating final assessment', 
      error: error.message 
    });
  }
});

// Route to get saved evaluations for a session
router.get('/:sessionId', auth, async (req, res) => {
  try {
    const { sessionId } = req.params;
    
    // Find all evaluations for this session, sorted by timestamp
    const evaluations = await Evaluation.find({ sessionId })
      .sort({ timestamp: -1 });
    
    res.json({ evaluations });
  } catch (error) {
    console.error('Error retrieving evaluations:', error);
    res.status(500).json({ 
      message: 'Error retrieving evaluations', 
      error: error.message 
    });
  }
});

// Route to get the latest evaluation for a session
router.get('/latest/:sessionId', auth, async (req, res) => {
  try {
    const { sessionId } = req.params;
    
    // Find the latest evaluation for this session
    const evaluation = await Evaluation.findOne({ sessionId })
      .sort({ timestamp: -1 });
    
    if (!evaluation) {
      return res.status(404).json({ message: 'No evaluations found' });
    }
    
    res.json({ evaluation });
  } catch (error) {
    console.error('Error retrieving latest evaluation:', error);
    res.status(500).json({ 
      message: 'Error retrieving evaluation', 
      error: error.message 
    });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\interviews.js
# EXTENSION: .js
================================================================================
// server/routes/interviews.js
const express = require('express');
const router = express.Router();
const Interview = require('../models/Interview');
const Problem = require('../models/Problem'); 
const InterviewEngine = require('../services/engines/interviewEngine');
const diagramService = require('../services/diagram/diagramService');

// Centralized error handling middleware
const handleError = (res, error, defaultMessage = 'An unexpected error occurred') => {
  console.error('Route Error:', error);
  res.status(error.status || 500).json({ 
    error: error.message || defaultMessage,
    details: error.details || error.toString()
  });
};

// Logging middleware
router.use((req, res, next) => {
  console.log(`[Interviews] ${req.method} ${req.path} - User: ${req.user?.id || 'Unauthenticated'}`);
  next();
});

// Get interview problems - THIS ROUTE MUST MATCH THE CLIENT'S EXPECTATIONS
router.get('/problems', async (req, res) => {
  try {
    console.log('Fetching interview problems');
    
    // Try to find interview problems first
    let problems = await Problem.find({ 
      $or: [
        { type: 'interview' }, 
        { type: 'both' }
      ]
    });
    
    // If no problems with type field, look for any problems
    if (!problems || problems.length === 0) {
      problems = await Problem.find();
      
      if (!problems || problems.length === 0) {
        console.log('No problems found, returning 404');
        return res.status(404).json({ 
          error: 'No Problems Found', 
          details: 'No interview problems are currently available' 
        });
      }
      
      console.log(`Found ${problems.length} general problems, using as fallback`);
    } else {
      console.log(`Found ${problems.length} interview problems`);
    }

    res.json({ problems });
  } catch (error) {
    console.error('Interview problems error:', error);
    handleError(res, error, 'Failed to retrieve interview problems');
  }
});

// Get all interviews for the current user
router.get('/', async (req, res) => {
  try {
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to access interviews' 
      });
    }

    const interviews = await Interview.find({ 
      userId, 
      type: 'interview'
    }).sort({ startedAt: -1 });

    res.json({ interviews });
  } catch (error) {
    handleError(res, error, 'Failed to retrieve interviews');
  }
});

// Start a new interview
router.post('/start', async (req, res) => {
  try {
    const { problemId } = req.body;
    const userId = req.user?.id;

    // Validate authentication
    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to start an interview' 
      });
    }

    // Validate problem ID
    if (!problemId) {
      return res.status(400).json({ 
        error: 'Invalid Problem', 
        details: 'A valid problem ID is required' 
      });
    }

    // Find problem - don't check type to ensure compatibility
    const problem = await Problem.findOne({ id: problemId });
    if (!problem) {
      return res.status(404).json({ 
        error: 'Problem Not Found', 
        details: `No problem exists with ID: ${problemId}` 
      });
    }

    // Start interview using interview engine
    const interview = await interviewEngine.startInterview(userId, problemId);
    
    console.log(`Interview started: ${interview._id}`);
    res.status(201).json({ interview });
  } catch (error) {
    console.error('Interview start error:', error);
    handleError(res, error, 'Failed to start interview');
  }
});

// Get recent interview
router.get('/recent', async (req, res) => {
  try {
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to access recent interviews' 
      });
    }

    const recentInterview = await Interview.findOne({ 
      userId, 
      status: 'in_progress',
      type: 'interview'
    }).sort({ startedAt: -1 });

    if (!recentInterview) {
      return res.status(404).json({ 
        error: 'No Recent Interview', 
        details: 'You have no ongoing interviews' 
      });
    }

    res.json({ interview: recentInterview });
  } catch (error) {
    handleError(res, error, 'Failed to retrieve recent interview');
  }
});

// Get interview by ID
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to access interviews' 
      });
    }

    // For demo scenarios, handle ID=1 specially
    if (id === '1') {
      // Find most recent interview or return a mock
      const interview = await Interview.findOne({
        userId,
        type: 'interview',
        status: 'in_progress'
      }).sort({ startedAt: -1 });

      if (interview) {
        return res.json({ interview });
      }

      // Create a mock interview response for demo purposes
      return res.json({
        interview: {
          _id: '1',
          status: 'in_progress',
          currentStage: 'intro',
          conversation: [
            {
              role: 'interviewer',
              content: "Let's design a URL shortening service like TinyURL. Could you start by explaining the requirements and constraints as you understand them?",
              timestamp: new Date()
            }
          ]
        }
      });
    }

    // Regular interview lookup by ID
    const interview = await Interview.findById(id);
    
    if (!interview) {
      return res.status(404).json({ 
        error: 'Interview Not Found', 
        details: 'No matching interview found' 
      });
    }

    // Ensure user owns this interview
    if (interview.userId.toString() !== userId) {
      return res.status(403).json({ 
        error: 'Access Denied', 
        details: 'You do not have permission to view this interview' 
      });
    }

    res.json({ interview });
  } catch (error) {
    handleError(res, error, 'Failed to retrieve interview');
  }
});

// Send message in interview
router.post('/:id/message', async (req, res) => {
  try {
    const { message } = req.body;
    const { id } = req.params;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to send messages' 
      });
    }

    if (!message) {
      return res.status(400).json({ 
        error: 'Invalid Message', 
        details: 'Message content is required' 
      });
    }

    // Find interview
    let interview;
    if (id === '1') {
      interview = await Interview.findOne({ 
        userId, 
        status: 'in_progress',
        type: 'interview'
      }).sort({ startedAt: -1 });
      
      // If no interview found, create a mock one for demo
      if (!interview) {
        const problem = await Problem.findOne({ id: 'url-shortener' });
        if (problem) {
          interview = await interviewEngine.startInterview(userId, problem.id);
        }
      }
    } else {
      // Validate MongoDB ID format
      if (!/^[0-9a-fA-F]{24}$/.test(id)) {
        return res.status(400).json({ 
          error: 'Invalid Interview ID', 
          details: 'The provided interview ID is not valid' 
        });
      }

      interview = await Interview.findById(id);
    }

    if (!interview) {
      return res.status(404).json({ 
        error: 'Interview Not Found', 
        details: 'No matching interview found' 
      });
    }

    // Ensure user owns this interview
    if (interview.userId.toString() !== userId) {
      return res.status(403).json({ 
        error: 'Access Denied', 
        details: 'You do not have permission to access this interview' 
      });
    }

    const processedInterview = await interviewEngine.processResponse(interview._id, message);
    res.json({ interview: processedInterview });
  } catch (error) {
    handleError(res, error, 'Failed to process interview message');
  }
});

// Complete interview
router.post('/:id/complete', async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to complete interviews' 
      });
    }

    let interview;
    if (id === '1') {
      interview = await Interview.findOne({ 
        userId, 
        status: 'in_progress',
        type: 'interview'
      }).sort({ startedAt: -1 });
    } else {
      interview = await Interview.findById(id);
    }

    if (!interview) {
      return res.status(404).json({ 
        error: 'Interview Not Found', 
        details: 'No matching interview found' 
      });
    }

    // Ensure user owns this interview
    if (interview.userId.toString() !== userId) {
      return res.status(403).json({ 
        error: 'Access Denied', 
        details: 'You do not have permission to access this interview' 
      });
    }

    // Skip if already completed
    if (interview.status === 'completed') {
      return res.json({ interview });
    }

    const completedInterview = await interviewEngine.finalizeInterview(interview);
    res.json({ interview: completedInterview });
  } catch (error) {
    handleError(res, error, 'Failed to complete interview');
  }
});

// Get interview results
router.get('/:id/results', async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to view results' 
      });
    }

    let interview;
    if (id === '1') {
      interview = await Interview.findOne({ 
        userId, 
        type: 'interview'
      }).sort({ startedAt: -1 });
    } else {
      interview = await Interview.findById(id);
    }

    if (!interview) {
      return res.status(404).json({ 
        error: 'Interview Not Found', 
        details: 'No matching interview found' 
      });
    }

    // Ensure user owns this interview
    if (interview.userId.toString() !== userId) {
      return res.status(403).json({ 
        error: 'Access Denied', 
        details: 'You do not have permission to access these results' 
      });
    }

    // If not completed, try to complete it first
    if (interview.status !== 'completed') {
      try {
        interview = await interviewEngine.finalizeInterview(interview);
      } catch (evalError) {
        console.error('Auto-evaluation error:', evalError);
      }
    }

    res.json({
      results: interview.evaluation || {
        score: 0,
        feedback: 'No evaluation available yet.',
        strengths: [],
        weaknesses: [],
        areas_to_improve: []
      },
      conversation: interview.conversation
    });
  } catch (error) {
    handleError(res, error, 'Failed to retrieve interview results');
  }
});

// Generate diagram for interview
router.post('/:id/diagram', async (req, res) => {
  try {
    const { id } = req.params;
    const { diagramType = 'architecture', customPrompt = null } = req.body;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to generate diagrams' 
      });
    }

    // Find interview
    let interview;
    if (id === '1') {
      interview = await Interview.findOne({ 
        userId, 
        status: 'in_progress',
        type: 'interview'
      }).sort({ startedAt: -1 });
    } else {
      interview = await Interview.findById(id);
    }

    if (!interview) {
      return res.status(404).json({ 
        error: 'Interview Not Found', 
        details: 'No matching interview found' 
      });
    }

    // Ensure user owns this interview
    if (interview.userId.toString() !== userId) {
      return res.status(403).json({ 
        error: 'Access Denied', 
        details: 'You do not have permission to access this interview' 
      });
    }

    // Generate diagram
    const diagram = await diagramService.generateDiagram(
      interview._id,
      diagramType,
      customPrompt
    );

    // Add the diagram to the interview
    if (!interview.diagrams) {
      interview.diagrams = [];
    }
    
    interview.diagrams.push({
      type: diagram.type,
      mermaidCode: diagram.mermaidCode,
      description: diagram.description,
      timestamp: new Date()
    });
    
    await interview.save();

    res.json({ diagram });
  } catch (error) {
    console.error('Diagram generation error:', error);
    handleError(res, error, 'Failed to generate diagram');
  }
});

// Get available diagram types
router.get('/diagram/types', async (req, res) => {
  try {
    res.json({ types: diagramService.TYPES });
  } catch (error) {
    handleError(res, error, 'Failed to get diagram types');
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\problems.js
# EXTENSION: .js
================================================================================
const express = require('express');
const router = express.Router();
const Problem = require('../models/Problem');
const logger = require('../utils/logger');

// Cache for problems to avoid frequent DB queries
let problemsCache = null;
let lastCacheUpdate = null;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

async function loadProblems() {
  try {
    if (problemsCache && lastCacheUpdate && (Date.now() - lastCacheUpdate) < CACHE_DURATION) {
      return problemsCache;
    }

    const problems = await Problem.find({ active: true })
      .select('id title difficulty category description tags')
      .sort({ difficulty: 1, category: 1 })
      .lean();

    problemsCache = problems;
    lastCacheUpdate = Date.now();
    return problems;
  } catch (error) {
    logger.error('Error loading problems:', error);
    throw error;
  }
}

router.get('/', async (req, res) => {
  try {
    const problems = await loadProblems();
    res.json(problems);
  } catch (error) {
    logger.error('Failed to fetch problems:', error);
    res.status(500).json({ error: 'Failed to fetch problems' });
  }
});

router.get('/:id', async (req, res) => {
  try {
    const problem = await Problem.findOne({ id: req.params.id });
    if (!problem) {
      return res.status(404).json({ error: 'Problem not found' });
    }
    res.json(problem);
  } catch (error) {
    logger.error(`Failed to fetch problem ${req.params.id}:`, error);
    res.status(500).json({ error: 'Failed to fetch problem' });
  }
});

module.exports = router;



================================================================================
# FILE: server\routes\sessions.js
# EXTENSION: .js
================================================================================
const express = require('express');
const Session = require('../models/Session');
const Problem = require('../models/Problem');
const User = require('../models/User');
const Workbook = require('../models/Workbook');
const { getAIService } = require('../services/ai');
const logger = require('../utils/logger');

const router = express.Router();

// Create or update session
router.post('/:problemId', async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { problemId } = req.params;
    const userId = req.user.id;
    const { messages, currentStage, diagram } = req.body;
    
    // Find or create session
    let sessionDoc = await Session.findOne({ 
      userId, 
      problemId,
      completed: false
    }).session(session);
    
    if (!sessionDoc) {
      sessionDoc = new Session({
        userId,
        problemId,
        messages: [],
        currentStage: 0
      });
    }
    
    // Update session data
    if (messages) sessionDoc.messages = messages;
    if (currentStage !== undefined) sessionDoc.currentStage = currentStage;
    
    // Create or update associated workbook
    let workbook = await Workbook.findOne({ sessionId: sessionDoc._id }).session(session);
    if (!workbook) {
      workbook = new Workbook({
        sessionId: sessionDoc._id,
        userId,
        diagram
      });
    } else if (diagram) {
      workbook.diagram = diagram;
    }
    
    await workbook.save({ session });
    sessionDoc.workbook = workbook._id;
    await sessionDoc.save({ session });
    
    // Update user progress
    const user = await User.findById(userId).session(session);
    await user.updateProgress(sessionDoc);
    
    if (!user.activeSessions.includes(sessionDoc._id)) {
      user.activeSessions.push(sessionDoc._id);
    }
    if (!user.workbooks.includes(workbook._id)) {
      user.workbooks.push(workbook._id);
    }
    
    await user.save({ session });
    await session.commitTransaction();
    
    res.json({ 
      session: sessionDoc,
      workbook,
      progress: user.progress
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Update session error:', error);
    res.status(500).json({ error: 'Failed to update session' });
  } finally {
    session.endSession();
  }
});

// Send message to AI
router.post('/:problemId/message', async (req, res) => {
  try {
    const { problemId } = req.params;
    const userId = req.user.id;
    const { message, previousMessages, currentStage, aiService } = req.body;
    
    // Get problem
    const problem = await Problem.findOne({ id: problemId });
    if (!problem) {
      return res.status(404).json({ error: 'Problem not found' });
    }
    
    // Get AI service
    const ai = getAIService(aiService || 'claude');
    
    // Generate response
    const aiResponse = await ai.generateResponse(
      [...previousMessages, { role: 'user', content: message }],
      problem,
      currentStage
    );
    
    res.json(aiResponse);
  } catch (error) {
    console.error('AI message error:', error);
    res.status(500).json({ error: 'Failed to generate AI response' });
  }
});

// Generate diagram
router.post('/:problemId/diagram', async (req, res) => {
  try {
    const { problemId } = req.params;
    const userId = req.user.id;
    const { messages, currentStage, aiService } = req.body;
    
    // Get problem
    const problem = await Problem.findOne({ id: problemId });
    if (!problem) {
      return res.status(404).json({ error: 'Problem not found' });
    }
    
    // Get AI service
    const ai = getAIService(aiService || 'claude');
    
    // Generate diagram
    const diagram = await ai.generateDiagram(
      messages,
      problem,
      currentStage
    );
    
    res.json({ diagram });
  } catch (error) {
    console.error('Generate diagram error:', error);
    res.status(500).json({ error: 'Failed to generate diagram' });
  }
});

// Complete session
router.post('/:problemId/complete', async (req, res) => {
  try {
    const { problemId } = req.params;
    const userId = req.user.id;
    
    // Find session
    const session = await Session.findOne({ 
      userId, 
      problemId,
      completed: false
    });
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }
    
    // Mark as completed
    session.completed = true;
    session.completedAt = Date.now();
    
    // Calculate score based on completeness
    const problem = await Problem.findOne({ id: problemId });
    const maxStage = problem.promptSequence.length - 1;
    const completionPercent = session.currentStage / maxStage;
    session.score = Math.round(completionPercent * 100);
    
    await session.save();
    
    // Update user progress
    const user = await User.findById(userId);
    user.progress.problemsCompleted += 1;
    await user.updateProgress(session);
    await user.save();
    
    res.json({ 
      success: true,
      score: session.score 
    });
  } catch (error) {
    console.error('Complete session error:', error);
    res.status(500).json({ error: 'Failed to complete session' });
  }
});

// Get user sessions/progress
router.get('/progress', async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Get user data
    const user = await User.findById(userId);
    
    // Get in-progress sessions
    const inProgressSession = await Session.findOne({
      userId,
      completed: false
    }).sort('-lastUpdatedAt');
    
    // Get problem info for in-progress session
    let inProgressProblem = null;
    if (inProgressSession) {
      const problem = await Problem.findOne({ id: inProgressSession.problemId });
      if (problem) {
        inProgressProblem = {
          id: problem.id,
          title: problem.title,
          description: problem.description.substring(0, 100) + '...',
          percentComplete: inProgressSession.percentComplete,
          stages: problem.promptSequence.map((stage, index) => ({
            id: stage.id,
            name: stage.name,
            completed: index < inProgressSession.currentStage
          }))
        };
      }
    }
    
    // Calculate total problems
    const totalProblems = await Problem.countDocuments();
    
    res.json({
      problemsCompleted: user.progress.problemsCompleted,
      totalProblems,
      timeInvested: user.progress.timeInvested,
      currentStreak: user.progress.streak.current,
      bestStreak: user.progress.streak.best,
      inProgressProblem
    });
  } catch (error) {
    console.error('Get progress error:', error);
    res.status(500).json({ error: 'Failed to get progress' });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\users.js
# EXTENSION: .js
================================================================================
const express = require('express');
const User = require('../models/User');

const router = express.Router();

// Update user profile
router.put('/profile', async (req, res) => {
  try {
    const userId = req.user.id;
    const { name, experience } = req.body;
    
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Update fields
    if (name) user.name = name;
    if (experience) user.experience = experience;
    
    user.profileCompleted = true;
    await user.save();
    
    res.json({
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        experience: user.experience,
        progress: user.progress
      }
    });
  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({ error: 'Failed to update profile' });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\workbook.js
# EXTENSION: .js
================================================================================
const workbookDiagramService = require('../services/workbook/workbookDiagramService');

router.post('/diagram/:sessionId/:type', async (req, res) => {
  try {
    const { sessionId, type } = req.params;
    const diagramData = req.body;
    
    const updatedWorkbook = await workbookDiagramService.saveDiagram(
      sessionId,
      type,
      diagramData
    );
    
    res.json({
      success: true,
      diagram: updatedWorkbook.diagrams[type]
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

router.get('/diagram/:sessionId/:type', async (req, res) => {
  try {
    const { sessionId, type } = req.params;
    const diagram = await workbookDiagramService.getDiagram(sessionId, type);
    
    res.json({
      success: true,
      diagram
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

module.exports = router;


================================================================================
# FILE: server\scripts\checkConnection.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');

async function checkConnection() {
  try {
    const mongoUri = process.env.MONGODB_URI;
    
    console.log('Attempting to connect to MongoDB...');
    await mongoose.connect(mongoUri);
    
    console.log('Connection successful!');
    console.log('Database name:', mongoose.connection.name);
    console.log('Connection state:', mongoose.connection.readyState);
    
    const collections = await mongoose.connection.db.listCollections().toArray();
    console.log('\nAvailable collections:', collections.map(c => c.name));
    
    await mongoose.connection.db.admin().serverStatus();
    console.log('Server status check passed');
    
    await mongoose.connection.close();
  } catch (error) {
    console.error('Connection error details:', {
      name: error.name,
      message: error.message,
      code: error.code,
      codeName: error.codeName
    });
    process.exit(1);
  }
}

module.exports = checkConnection;



================================================================================
# FILE: server\scripts\checkDatabase.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');
const Workbook = require('../models/Workbook');

async function checkDatabase() {
  try {
    const mongoUri = process.env.MONGODB_URI;
    
    await mongoose.connect(mongoUri);
    console.log('Connected to MongoDB');
    
    // Check workbooks
    const workbooks = await Workbook.find({}).limit(5);
    console.log('\nRecent Workbooks:');
    console.log(JSON.stringify(workbooks, null, 2));
    
    // Get collection count
    const count = await Workbook.countDocuments();
    console.log('\nCollection Stats:');
    console.log(`Total documents: ${count}`);

    // List all collections
    const collections = await mongoose.connection.db.listCollections().toArray();
    console.log('\nAvailable Collections:');
    console.log(collections.map(c => c.name));
    
    mongoose.connection.close();
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

checkDatabase();


================================================================================
# FILE: server\scripts\initializeDatabase.js
# EXTENSION: .js
================================================================================
require('dotenv').config();
const mongoose = require('mongoose');
const User = require('../models/User');
const Problem = require('../models/Problem');
const Workbook = require('../models/Workbook');
const logger = require('../utils/logger');
const problems = require('./seedData/problems');

async function recreateIndexes() {
  const models = [User, Problem, Workbook];
  
  for (const Model of models) {
    const collection = Model.collection;
    try {
      await Model.syncIndexes();
      logger.info(`Recreated indexes for ${collection.collectionName}`);
    } catch (error) {
      logger.error(`Error syncing indexes for ${collection.collectionName}:`, error);
    }
  }
}

async function seedInitialData() {
  // Create default admin if not exists
  const adminExists = await User.findOne({ email: process.env.ADMIN_EMAIL });
  if (!adminExists && process.env.ADMIN_EMAIL && process.env.ADMIN_PASSWORD) {
    await User.create({
      name: 'Admin',
      email: process.env.ADMIN_EMAIL,
      password: process.env.ADMIN_PASSWORD,
      experience: 'expert'
    });
    logger.info('Created admin user');
  }

  // Load and seed problems from seedData
  await Problem.deleteMany({});
  await Problem.insertMany(problems);
  logger.info(`Seeded ${problems.length} problems`);
}

async function verifySetup() {
  const collections = await mongoose.connection.db.listCollections().toArray();
  const requiredCollections = ['users', 'problems', 'workbooks'];
  
  for (const required of requiredCollections) {
    if (!collections.find(c => c.name === required)) {
      logger.error(`Missing required collection: ${required}`);
      throw new Error(`Missing required collection: ${required}`);
    }
  }
  
  logger.info('Database verification completed successfully');
}

async function initializeDatabase() {
  try {
    if (!process.env.MONGODB_URI) {
      throw new Error('MONGODB_URI is not defined');
    }

    await mongoose.connect(process.env.MONGODB_URI);
    logger.info('Connected to MongoDB');

    await recreateIndexes();
    await seedInitialData();
    await verifySetup();

    logger.info('Database initialization completed successfully');
  } catch (error) {
    logger.error('Database initialization failed:', error);
    throw error;
  } finally {
    await mongoose.connection.close();
  }
}

if (require.main === module) {
  initializeDatabase()
    .then(() => process.exit(0))
    .catch(() => process.exit(1));
}

module.exports = initializeDatabase;



================================================================================
# FILE: server\scripts\seedData\problems.js
# EXTENSION: .js
================================================================================
module.exports = [
  {
    id: "system_design_1",
    title: "Design a URL Shortener",
    description: "Design a URL shortening service like TinyURL or bit.ly",
    difficulty: "medium",
    category: "web",
    estimatedTime: 45
  },
  {
    id: "system_design_2",
    title: "Design Twitter",
    description: "Design a simplified version of Twitter focusing on core features",
    difficulty: "hard",
    category: "social",
    estimatedTime: 60
  },
  {
    id: "system_design_3",
    title: "Design a Parking Lot System",
    description: "Design a parking lot system that can efficiently manage parking spaces, vehicle entry/exit, and payment processing",
    difficulty: "medium",
    category: "physical",
    estimatedTime: 30
  }
];



================================================================================
# FILE: server\scripts\seedData\workbookTemplate.js
# EXTENSION: .js
================================================================================
const workbookTemplate = {
  sections: {
    requirements: {
      functional: {
        template: true,
        content: '',
        maxPages: 5
      },
      nonFunctional: {
        template: true,
        content: '',
        maxPages: 5
      }
    },
    api: {
      endpoints: {
        template: true,
        content: '',
        maxPages: 5
      }
    },
    database: {
      schema: {
        template: true,
        content: '',
        maxPages: 5
      }
    },
    architecture: {
      highLevel: {
        template: true,
        content: '',
        maxPages: 5
      },
      detailed: {
        template: true,
        content: '',
        maxPages: 5
      }
    },
    diagrams: {
      sequence: [],
      component: [],
      deployment: []
    }
  },
  metadata: {
    version: '1.0.0',
    lastUpdated: new Date(),
    created: new Date()
  }
};

module.exports = workbookTemplate;


================================================================================
# FILE: server\scripts\seedDatabase.js
# EXTENSION: .js
================================================================================
require('dotenv').config();
const mongoose = require('mongoose');
const Problem = require('../models/Problem');
const problems = require('./seedData/problems');
const logger = require('../utils/logger');

async function seedProblems() {
  try {
    // Clear existing problems
    await Problem.deleteMany({});
    logger.info('Cleared existing problems');

    // Insert new problems
    const result = await Problem.insertMany(problems);
    logger.info(`Seeded ${result.length} problems`);

    return result;
  } catch (error) {
    logger.error('Error seeding problems:', error);
    throw error;
  }
}

async function seedDatabase() {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    logger.info('Connected to MongoDB');

    await seedProblems();
    logger.info('Database seeding completed');

    await mongoose.disconnect();
    logger.info('Disconnected from MongoDB');
  } catch (error) {
    logger.error('Database seeding failed:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  seedDatabase();
}

module.exports = seedDatabase;


================================================================================
# FILE: server\scripts\seedProblems.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');
const Problem = require('../models/Problem');

const problems = [
  {
    id: "url-shortener",
    title: "Design a URL Shortener like TinyURL",
    type: "both",
    difficulty: "intermediate",
    description: "Design a URL shortening service like TinyURL. This service will provide shortened URLs that redirect to the original URL.",
    estimatedTime: 45,
    requirements: {
      functional: [
        "URL shortening",
        "URL redirection",
        "Custom short URLs",
        "Analytics"
      ],
      nonFunctional: [
        "High availability",
        "Low latency",
        "Scalability"
      ]
    }
  },
  {
    id: "parking-lot",
    title: "Design a Parking Lot System",
    type: "coaching",
    difficulty: "beginner",
    description: "Design a parking lot system that can efficiently manage parking spaces, vehicle entry/exit, and payment processing.",
    estimatedTime: 30
  }
];

async function seedDatabase() {
  try {
    const mongoUri = process.env.MONGODB_URI;
    
    await mongoose.connect(mongoUri);
    console.log('Connected to MongoDB');
    
    // Delete existing problems
    await Problem.deleteMany({});
    console.log('Cleared existing problems');
    
    // Insert new problems
    const result = await Problem.insertMany(problems);
    console.log(`Added ${result.length} problems to database`);
    
    // Verify the insertion
    const count = await Problem.countDocuments();
    console.log(`Total problems in database: ${count}`);
    
    await mongoose.disconnect();
    console.log('Database seeding completed');
  } catch (error) {
    console.error('Error seeding database:', error);
    process.exit(1);
  }
}

seedDatabase();


================================================================================
# FILE: server\scripts\setupDatabase.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');
const User = require('../models/User');

async function setupDatabase() {
  try {
    const mongoUri = process.env.MONGODB_URI;
    
    // Connect to MongoDB
    await mongoose.connect(mongoUri);
    console.log('Connected to MongoDB');
    
    // Check if the admin user exists
    const adminExists = await User.findOne({ email: 'admin@example.com' });
    
    if (!adminExists) {
      // Create an admin user
      const admin = new User({
        name: 'Admin User',
        email: 'admin@example.com',
        password: 'adminpassword', // Will be hashed by pre-save hook
        experience: 'expert'
      });
      
      await admin.save();
      console.log('Created admin user');
    } else {
      console.log('Admin user already exists');
    }

    await mongoose.connection.close();
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

module.exports = setupDatabase;



================================================================================
# FILE: server\scripts\testConnection.js
# EXTENSION: .js
================================================================================
require('dotenv').config();
const mongoose = require('mongoose');
const logger = require('../utils/logger');

async function testConnection() {
    try {
        console.log('Attempting to connect with URI:', process.env.MONGODB_URI);
        await mongoose.connect(process.env.MONGODB_URI);
        console.log('Successfully connected to MongoDB!');
        
        const collections = await mongoose.connection.db.listCollections().toArray();
        console.log('Available collections:', collections.map(c => c.name));
        
        await mongoose.connection.close();
    } catch (error) {
        console.error('Connection failed:', error);
    }
}

testConnection();


================================================================================
# FILE: server\scripts\testDiagramAnalysis.js
# EXTENSION: .js
================================================================================
const DiagramAnalyzer = require('../services/diagram/diagramAnalyzer');
const PatternRegistry = require('../services/diagram/patterns/PatternRegistry');
const logger = require('../utils/logger');

// Sample diagram for testing
const testDiagram = {
  nodes: [
    { id: 'lb1', type: 'loadbalancer', label: 'Load Balancer 1' },
    { id: 'lb2', type: 'loadbalancer', label: 'Load Balancer 2' },
    { id: 'svc1', type: 'service', label: 'API Service 1' },
    { id: 'svc2', type: 'service', label: 'API Service 2' },
    { id: 'svc3', type: 'service', label: 'API Service 3' },
    { id: 'cache1', type: 'cache', label: 'Redis Cache' },
    { id: 'db1', type: 'database', label: 'Primary DB' },
    { id: 'db2', type: 'database', label: 'Replica DB' },
    { id: 'queue1', type: 'queue', label: 'Message Queue' },
    { id: 'gateway1', type: 'gateway', label: 'API Gateway' }
  ],
  edges: [
    { id: 'e1', source: 'gateway1', target: 'lb1' },
    { id: 'e2', source: 'gateway1', target: 'lb2' },
    { id: 'e3', source: 'lb1', target: 'svc1' },
    { id: 'e4', source: 'lb1', target: 'svc2' },
    { id: 'e5', source: 'lb2', target: 'svc2' },
    { id: 'e6', source: 'lb2', target: 'svc3' },
    { id: 'e7', source: 'svc1', target: 'cache1' },
    { id: 'e8', source: 'svc2', target: 'cache1' },
    { id: 'e9', source: 'svc1', target: 'db1' },
    { id: 'e10', source: 'db1', target: 'db2' },
    { id: 'e11', source: 'svc2', target: 'queue1' },
    { id: 'e12', source: 'svc3', target: 'queue1' }
  ]
};

async function testDiagramAnalysis() {
  try {
    logger.info('Starting diagram analysis test...');

    // Initialize our analysis tools
    const analyzer = new DiagramAnalyzer();
    const patternRegistry = new PatternRegistry();

    // Test pattern detection
    logger.info('Testing pattern detection...');
    const detectedPatterns = patternRegistry.detectPatterns(testDiagram);
    logger.info('Detected patterns:', {
      patternCount: detectedPatterns.length,
      patterns: detectedPatterns.map(p => p.name)
    });

    // Test full diagram analysis
    logger.info('Testing full diagram analysis...');
    const analysis = analyzer.analyzeDiagram(
      testDiagram.nodes,
      testDiagram.edges,
      'system'
    );

    logger.info('Analysis results:', {
      patternCount: analysis.patterns.length,
      suggestionCount: analysis.suggestions.length,
      score: analysis.score,
      criticalIssues: analysis.criticalIssues.length
    });

    // Detailed results
    console.log('\n=== Detailed Analysis Results ===\n');
    console.log('Detected Patterns:');
    detectedPatterns.forEach(pattern => {
      console.log(`\n${pattern.name}:`);
      console.log(`- Quality Score: ${pattern.implementation.score}`);
      console.log(`- Optimal: ${pattern.implementation.optimal}`);
      if (pattern.implementation.missingOptimal.length > 0) {
        console.log('- Missing Optimal Features:');
        pattern.implementation.missingOptimal.forEach(missing => {
          console.log(`  * ${missing}`);
        });
      }
    });

    console.log('\nAnalysis Suggestions:');
    analysis.suggestions.forEach(suggestion => {
      console.log(`- Type: ${suggestion.type}`);
      console.log(`  Message: ${suggestion.message}`);
      console.log(`  Priority: ${suggestion.priority}`);
    });

    console.log('\nCritical Issues:');
    analysis.criticalIssues.forEach(issue => {
      console.log(`- Type: ${issue.type}`);
      console.log(`  Description: ${issue.description}`);
      console.log(`  Recommendation: ${issue.recommendation}`);
    });

    return {
      success: true,
      detectedPatterns,
      analysis
    };
  } catch (error) {
    logger.error('Error during diagram analysis test:', error);
    throw error;
  }
}

// Run the test if this script is executed directly
if (require.main === module) {
  testDiagramAnalysis()
    .then(() => {
      logger.info('Diagram analysis test completed successfully');
      process.exit(0);
    })
    .catch(error => {
      logger.error('Diagram analysis test failed:', error);
      process.exit(1);
    });
}

module.exports = testDiagramAnalysis;


================================================================================
# FILE: server\scripts\testWorkbook.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');
const Workbook = require('../models/Workbook');
require('dotenv').config();

async function createTestWorkbook() {
  try {
    const mongoUri = process.env.MONGODB_URI;
    console.log('Attempting to connect with URI:', mongoUri ? 'URI found' : 'URI missing');
    
    await mongoose.connect(mongoUri);
    console.log('Connected to MongoDB');
    
    // Create test data
    const testWorkbook = new Workbook({
      sessionId: 'test-session-' + Date.now(),
      userId: new mongoose.Types.ObjectId(),
      problemId: new mongoose.Types.ObjectId(),
      title: "Test Workbook",
      description: "This is a test workbook",
      apis: {
        endpoint: '/api/test',
        method: 'GET'
      },
      apiType: 'REST',
      requirements: {
        functional: ['Test requirement 1', 'Test requirement 2'],
        nonFunctional: ['Performance', 'Security']
      },
      architecture: {
        components: ['Frontend', 'Backend', 'Database']
      },
      diagram: {
        nodes: [],
        edges: []
      }
    });
    
    const savedWorkbook = await testWorkbook.save();
    console.log('Test workbook created with ID:', savedWorkbook._id);
    
    await mongoose.connection.close();
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

createTestWorkbook();


================================================================================
# FILE: server\scripts\verifyDatabase.js
# EXTENSION: .js
================================================================================
require('dotenv').config();
const mongoose = require('mongoose');
const Problem = require('../models/Problem');
const Workbook = require('../models/Workbook');
const logger = require('../utils/logger');

async function verifyCollections() {
  const collections = await mongoose.connection.db.collections();
  const collectionNames = collections.map(c => c.collectionName);
  
  const requiredCollections = ['problems', 'workbooks', 'users', 'sessions'];
  const missing = requiredCollections.filter(name => !collectionNames.includes(name));
  
  if (missing.length > 0) {
    throw new Error(`Missing collections: ${missing.join(', ')}`);
  }
  
  return collectionNames;
}

async function verifyIndexes() {
  const models = [Problem, Workbook];
  const results = {};
  
  for (const Model of models) {
    const indexes = await Model.collection.indexes();
    results[Model.modelName] = indexes;
  }
  
  return results;
}

async function verifyData() {
  const problemCount = await Problem.countDocuments();
  if (problemCount === 0) {
    throw new Error('No problems found in database');
  }
  
  return {
    problems: problemCount
  };
}

async function verifyDatabase() {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    logger.info('Connected to MongoDB');

    const collections = await verifyCollections();
    logger.info('Collections verified:', collections);

    const indexes = await verifyIndexes();
    logger.info('Indexes verified:', indexes);

    const counts = await verifyData();
    logger.info('Data verified:', counts);

    await mongoose.disconnect();
    logger.info('Database verification completed successfully');
    
    return {
      collections,
      indexes,
      counts
    };
  } catch (error) {
    logger.error('Database verification failed:', error);
    throw error;
  }
}

// Run if called directly
if (require.main === module) {
  verifyDatabase();
}

module.exports = verifyDatabase;


================================================================================
# FILE: server\services\ai\aiFactory.js
# EXTENSION: .js
================================================================================
const AIService = require('./aiService');
const aiConfig = require('../../config/aiConfig');

class AIFactory {
  static createService() {
    return new AIService(aiConfig.config);
  }
}

module.exports = AIFactory;



================================================================================
# FILE: server\services\ai\aiService.js
# EXTENSION: .js
================================================================================
const Anthropic = require('@anthropic-ai/sdk');
const logger = require('../../utils/logger');

class AIService {
  constructor(config) {
    this.config = config;
    this.client = new Anthropic({
      apiKey: config.apiKey,
    });
  }

  async sendMessage(messages, options = {}) {
    try {
      const systemPrompt = options.systemPrompt || this.config.defaultSystemPrompt;

      const response = await this.client.messages.create({
        model: this.config.model,
        max_tokens: options.maxTokens || this.config.maxTokens,
        messages: messages,
        system: systemPrompt,
        temperature: options.temperature || this.config.temperature,
      });

      return response.content[0].text;
    } catch (error) {
      logger.error('AI Service Error:', error);
      throw new Error('Failed to get AI response');
    }
  }

  async analyzeDiagram(diagramData, context = {}) {
    const analysis = {
      diagramType: diagramData.type,
      components: this._analyzeComponents(diagramData.nodes),
      patterns: this._detectPatterns(diagramData.nodes, diagramData.edges),
      metrics: {
        complexity: this._calculateComplexity(diagramData),
        coverage: this._calculateCoverage(diagramData),
        bestPractices: this._evaluateBestPractices(diagramData)
      }
    };

    const messages = [{
      role: 'user',
      content: `Analyze this system design diagram:\n${JSON.stringify(analysis, null, 2)}\nContext: ${JSON.stringify(context)}`
    }];

    return this.sendMessage(messages, {
      systemPrompt: "You are an expert system design reviewer. Analyze the diagram and provide specific, actionable feedback focusing on architecture, scalability, and best practices.",
      temperature: 0.5
    });
  }
}

module.exports = AIService;



================================================================================
# FILE: server\services\ai\base\AIService.js
# EXTENSION: .js
================================================================================
// server/services/ai/base/AIService.js
class AIService {
    async sendMessage(messages, options = {}) {
      throw new Error('sendMessage must be implemented by subclasses');
    }
    async generateResponse(messages, context, options = {}) {
      throw new Error('generateResponse must be implemented by subclasses');
    }
    async generateContent(prompt, options = {}) {
      throw new Error('generateContent must be implemented by subclasses');
    }
  }
  
  module.exports = AIService;
  


================================================================================
# FILE: server\services\ai\claudeService.js
# EXTENSION: .js
================================================================================
const { default: Anthropic } = require('@anthropic-ai/sdk');
const AIService = require('./base/AIService');
const logger = require('../../utils/logger');
const { CLAUDE_MODEL } = require('../../config/aiConfig');

class ClaudeService extends AIService {
  constructor(config = {}) {
    super();
    const apiKey = config.apiKey || process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      throw new Error("API key for Anthropic is required.");
    }
    this.anthropic = new Anthropic({ apiKey });
    this.defaultModel = config.model || CLAUDE_MODEL;
    this.maxRetries = config.maxRetries || 3;
    this.maxTokens = config.maxTokens || 4096;
    this.temperature = config.temperature || 0.7;
  }

  async sendMessage(messages, options = {}) {
    const maxRetries = options.maxRetries || this.maxRetries;
    let attempt = 0;
    
    while (attempt < maxRetries) {
      try {
        const response = await this.anthropic.messages.create({
          model: this.defaultModel,
          max_tokens: options.maxTokens || this.maxTokens,
          messages: messages,
          system: options.systemPrompt || "You are an expert system design coach helping developers improve their architecture and implementation decisions.",
          temperature: options.temperature || this.temperature,
        });

        return response.content[0].text;
      } catch (error) {
        attempt++;
        logger.error(`AI Service Error (attempt ${attempt}/${maxRetries}):`, error);
        if (attempt === maxRetries) {
          throw new Error('Failed to get AI response after multiple attempts');
        }
        // Wait before retrying
        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
      }
    }
  }
}

module.exports = ClaudeService;


================================================================================
# FILE: server\services\ai\coachingEngine.js
# EXTENSION: .js
================================================================================
const BaseEngine = require('./base/BaseEngine');
const Workbook = require('../../models/Workbook');
const logger = require('../../utils/logger');

class CoachingEngine extends BaseEngine {
  constructor(config = {}) {
    super(config);
  }

  async processMessage(sessionId, message, options = {}) {
    try {
      // Fetch current workbook state
      const workbook = await Workbook.findOne({ sessionId });
      
      const context = {
        ...options,
        workbookState: {
          apis: workbook?.apis,
          apiType: workbook?.apiType,
          requirements: workbook?.requirements,
          architecture: workbook?.architecture,
          diagram: workbook?.diagram
        }
      };

      const response = await super.processMessage(sessionId, message, context);
      
      // Track coaching interaction
      await this._updateWorkbookProgress(sessionId, message, response);
      
      return response;
    } catch (error) {
      logger.error(`Error in coaching engine: ${error.message}`);
      throw error;
    }
  }

  async _updateWorkbookProgress(sessionId, message, response) {
    try {
      const workbook = await Workbook.findOne({ sessionId });
      if (!workbook) return;

      // Update last interaction
      await Workbook.findOneAndUpdate(
        { sessionId },
        {
          $push: {
            coachingInteractions: {
              timestamp: new Date(),
              message,
              response,
            }
          }
        }
      );
    } catch (error) {
      logger.error(`Error updating workbook progress: ${error.message}`);
    }
  }
}

module.exports = CoachingEngine;


================================================================================
# FILE: server\services\ai\index.js
# EXTENSION: .js
================================================================================
const CoachEngine = require('../engines/coachEngine');

// Initialize the coach engine
const coachEngine = new CoachEngine();

module.exports = {
  coachEngine
};



================================================================================
# FILE: server\services\CoachEngine.js
# EXTENSION: .js
================================================================================
class CoachEngine {
  constructor() {
    this.aiService = global.aiService;
  }

  async handleMessage(sessionId, userId, message, contextInfo = null) {
    try {
      if (!this.aiService) {
        throw new Error('AI Service not initialized');
      }

      // Prepare the context for the AI
      const context = {
        sessionId,
        userId,
        ...(contextInfo || {})
      };

      // Get response from AI service
      const response = await this.aiService.getResponse(message, context);

      return {
        message: {
          role: 'assistant',
          content: response.content,
          timestamp: new Date().toISOString()
        },
        diagramSuggestions: contextInfo?.requestDiagramSuggestions ? {
          mermaidCode: response.diagramSuggestions || null
        } : null
      };
    } catch (error) {
      console.error('Error in CoachEngine.handleMessage:', error);
      throw new Error(`Failed to process message: ${error.message}`);
    }
  }
}

module.exports = CoachEngine;


================================================================================
# FILE: server\services\coaching.js
# EXTENSION: .js
================================================================================
const logMessageProcessing = (sessionId, message, systemPrompt, projectDetails) => {
  // Create a formatted system prompt display
  const formatSystemPrompt = (prompt) => {
    const sections = prompt.split('\n\n');
    return sections.map(section => {
      const lines = section.trim().split('\n');
      return lines.join('\n  ');
    }).join('\n\n  ');
  };

  console.log(`
 Message Processing [${sessionId}]

 User Message: "${message}"

 System Prompt:
  ${formatSystemPrompt(systemPrompt)}

 Project Context:
  ${JSON.stringify(projectDetails, null, 2)}
`);
};

module.exports = {
  logMessageProcessing
};



================================================================================
# FILE: server\services\coaching\coachingService.js
# EXTENSION: .js
================================================================================
const AIFactory = require('../ai/aiFactory');
const logger = require('../../utils/logger');
const { config } = require('../../config/aiConfig');

class CoachingService {
  constructor() {
    this.ai = AIFactory.createService();
  }

  async processMessage(sessionId, message, context = {}) {
    try {
      const messages = [{
        role: 'user',
        content: message
      }];

      // Add context to system prompt if available
      const systemPrompt = context.topic ? 
        `You are an expert system design coach focusing on ${context.topic}. ${config.defaultSystemPrompt}` :
        config.defaultSystemPrompt;

      logger.info('Sending message to AI:', {
        sessionId,
        messageCount: messages.length,
        hasContext: !!context
      });

      const response = await this.ai.sendMessage(messages, {
        systemPrompt,
        temperature: 0.7,
        maxTokens: 1000,
        context
      });

      await this._logInteraction(sessionId, message, response);
      return response;
    } catch (error) {
      logger.error('Coaching Service Error:', error);
      throw new Error('Failed to process coaching message');
    }
  }

  async analyzeDiagram(sessionId, diagram) {
    try {
      const analysis = await this.ai.analyzeDiagram(diagram, {
        sessionId,
        context: 'coaching'
      });

      await this._logInteraction(sessionId, 'Diagram Analysis Request', analysis);
      return analysis;
    } catch (error) {
      logger.error('Diagram Analysis Error:', error);
      throw new Error('Failed to analyze diagram');
    }
  }

  async _logInteraction(sessionId, message, response) {
    logger.info('AI Interaction completed:', {
      sessionId,
      messageLength: message.length,
      responseLength: response.length
    });
  }
}

module.exports = { CoachingService };



================================================================================
# FILE: server\services\coaching\WorkbookService.js
# EXTENSION: .js
================================================================================
const Workbook = require('../../models/Workbook');
const Problem = require('../../models/Problem');
const logger = require('../../utils/logger');

class WorkbookService {
  async createWorkbook(userId, problemId) {
    try {
      const problem = await Problem.findOne({ id: problemId });
      if (!problem) {
        throw new Error('Problem not found');
      }

      const workbook = new Workbook({
        sessionId: `wb-${Date.now()}-${userId}`,
        userId,
        problemId,
        sections: this._initializeSections(problem)
      });

      await workbook.save();
      return workbook;
    } catch (error) {
      logger.error('Error creating workbook:', error);
      throw error;
    }
  }

  async getWorkbook(sessionId) {
    return Workbook.findOne({ sessionId });
  }

  async updateSection(sessionId, sectionPath, content) {
    try {
      const workbook = await this.getWorkbook(sessionId);
      if (!workbook) {
        throw new Error('Workbook not found');
      }

      // Update the specific section
      const section = this._getNestedSection(workbook.sections, sectionPath);
      if (!section) {
        throw new Error('Section not found');
      }

      section.content = content;
      section.status = 'in_progress';
      
      await workbook.save();
      return workbook;
    } catch (error) {
      logger.error('Error updating workbook section:', error);
      throw error;
    }
  }

  _initializeSections(problem) {
    return {
      requirements: {
        functional: {
          content: '',
          status: 'not_started'
        },
        nonFunctional: {
          content: '',
          status: 'not_started'
        }
      },
      api: {
        endpoints: {
          content: '',
          status: 'not_started'
        },
        documentation: {
          content: '',
          status: 'not_started'
        }
      },
      database: {
        schema: {
          content: '',
          status: 'not_started'
        },
        queries: {
          content: '',
          status: 'not_started'
        }
      },
      architecture: {
        highLevel: {
          content: '',
          status: 'not_started'
        },
        detailed: {
          content: '',
          status: 'not_started'
        }
      }
    };
  }

  _getNestedSection(sections, path) {
    return path.split('.').reduce((obj, key) => obj?.[key], sections);
  }
}

module.exports = new WorkbookService();


================================================================================
# FILE: server\services\diagram\diagramAiSuggester.js
# EXTENSION: .js
================================================================================
const AIFactory = require('../ai/aiFactory');
const { diagramStructure } = require('../../../data/diagram_structure');
const DiagramAnalyzer = require('./diagramAnalyzer');

class DiagramAiSuggester {
  constructor() {
    this.analyzer = new DiagramAnalyzer();
    this.ai = AIFactory.create('diagram');
  }

  async generateSuggestions(diagram, context) {
    const analysis = this.analyzer.analyzeDiagram(diagram.nodes, diagram.edges, diagram.type);
    const patterns = this._identifyMissingPatterns(diagram);
    
    const prompt = this._buildPrompt(diagram, analysis, patterns, context);
    const suggestions = await this.ai.generateSuggestions(prompt);

    return {
      immediateActions: this._generateImmediateActions(analysis, patterns),
      aiSuggestions: suggestions,
      proposedChanges: this._generateProposedChanges(diagram, patterns)
    };
  }

  _identifyMissingPatterns(diagram) {
    const missingPatterns = {
      loadBalancing: !diagram.nodes.some(n => n.type === 'loadBalancer'),
      caching: !diagram.nodes.some(n => n.type === 'cache'),
      messageQueue: !diagram.nodes.some(n => n.type === 'queue'),
      apiGateway: !diagram.nodes.some(n => n.type === 'apiGateway'),
      serviceDiscovery: !diagram.nodes.some(n => n.type === 'serviceDiscovery'),
      cdn: !diagram.nodes.some(n => n.type === 'cdn')
    };

    return Object.entries(missingPatterns)
      .filter(([_, isMissing]) => isMissing)
      .map(([pattern]) => pattern);
  }

  _buildPrompt(diagram, analysis, patterns, context) {
    return {
      type: diagram.type,
      components: {
        current: diagram.nodes.map(n => ({
          type: n.type,
          connections: diagram.edges
            .filter(e => e.source === n.id || e.target === n.id)
            .map(e => ({
              type: e.type,
              with: e.source === n.id ? e.target : e.source
            }))
        })),
        missing: patterns
      },
      analysis: {
        criticalIssues: analysis.criticalIssues,
        suggestions: analysis.suggestions
      },
      context: {
        stage: context.stage,
        problemDomain: context.problemDomain,
        requirements: context.requirements
      }
    };
  }

  _generateImmediateActions(analysis, patterns) {
    const actions = [];

    // Add critical security fixes
    if (analysis.criticalIssues.some(issue => issue.category === 'security')) {
      actions.push({
        type: 'security',
        priority: 'high',
        action: 'Add API Gateway for authentication and authorization',
        nodeType: 'apiGateway'
      });
    }

    // Add scalability improvements
    if (patterns.includes('loadBalancing')) {
      actions.push({
        type: 'scalability',
        priority: 'high',
        action: 'Add load balancer to distribute traffic',
        nodeType: 'loadBalancer'
      });
    }

    // Add performance optimizations
    if (patterns.includes('caching')) {
      actions.push({
        type: 'performance',
        priority: 'medium',
        action: 'Add caching layer to improve response times',
        nodeType: 'cache'
      });
    }

    return actions;
  }

  _generateProposedChanges(diagram, patterns) {
    const changes = [];
    const centerX = this._calculateCenterX(diagram.nodes);
    const centerY = this._calculateCenterY(diagram.nodes);

    patterns.forEach(pattern => {
      switch (pattern) {
        case 'loadBalancing':
          changes.push({
            type: 'add_node',
            nodeType: 'loadBalancer',
            position: { x: centerX - 200, y: centerY - 100 },
            connections: this._findServiceNodes(diagram.nodes)
          });
          break;

        case 'caching':
          changes.push({
            type: 'add_node',
            nodeType: 'cache',
            position: { x: centerX + 200, y: centerY },
            connections: this._findDatabaseNodes(diagram.nodes)
          });
          break;

        case 'messageQueue':
          changes.push({
            type: 'add_node',
            nodeType: 'queue',
            position: { x: centerX, y: centerY + 150 },
            connections: this._findServiceNodes(diagram.nodes)
          });
          break;
      }
    });

    return changes;
  }

  _calculateCenterX(nodes) {
    const xs = nodes.map(n => n.position.x);
    return (Math.min(...xs) + Math.max(...xs)) / 2;
  }

  _calculateCenterY(nodes) {
    const ys = nodes.map(n => n.position.y);
    return (Math.min(...ys) + Math.max(...ys)) / 2;
  }

  _findServiceNodes(nodes) {
    return nodes
      .filter(n => n.type === 'service')
      .map(n => n.id);
  }

  _findDatabaseNodes(nodes) {
    return nodes
      .filter(n => n.type === 'database')
      .map(n => n.id);
  }
}

module.exports = DiagramAiSuggester;


================================================================================
# FILE: server\services\diagram\diagramAnalyzer.js
# EXTENSION: .js
================================================================================
class DiagramAnalyzer {
  constructor() {
    this.patterns = {
      microservices: {
        pattern: ['gateway', 'service', 'service'],
        score: 0.8,
        suggestions: ['Consider adding service discovery', 'Implement circuit breakers']
      },
      threeLayer: {
        pattern: ['frontend', 'backend', 'database'],
        score: 0.6,
        suggestions: ['Consider caching layer', 'Add load balancer']
      },
      eventDriven: {
        pattern: ['queue', 'service', 'service'],
        score: 0.7,
        suggestions: ['Implement dead letter queue', 'Add event versioning']
      }
    };
  }

  analyzeDiagram(nodes, edges, type) {
    const detectedPatterns = this._detectArchitecturalPatterns(nodes, edges);
    const securityIssues = this._analyzeSecurityConcerns(nodes);
    const scalabilityScore = this._evaluateScalability(nodes, edges);
    
    return {
      patterns: detectedPatterns,
      security: securityIssues,
      scalability: scalabilityScore,
      recommendations: this._generateRecommendations(detectedPatterns, securityIssues, scalabilityScore)
    };
  }
}

module.exports = DiagramAnalyzer;



================================================================================
# FILE: server\services\diagram\diagramEvaluationService.js
# EXTENSION: .js
================================================================================
const DiagramAnalyzer = require('./diagramAnalyzer');
const PatternLibrary = require('./patterns/PatternLibrary');
const { diagramStructure } = require('../../../data/diagram_structure');

class DiagramEvaluationService {
  constructor() {
    this.analyzer = new DiagramAnalyzer();
    this.patternLibrary = new PatternLibrary();
  }

  async evaluateDiagram(diagram, type, context) {
    const normalizedDiagram = this._normalizeDiagram(diagram, type);
    
    const evaluation = {
      diagramId: diagram.id,
      timestamp: Date.now(),
      scores: {},
      analysis: {},
      recommendations: []
    };

    // Evaluate different criteria
    const criteria = this._getCriteriaForType(type);
    for (const criterion of criteria) {
      evaluation.scores[criterion] = await this._evaluateCriterion(
        normalizedDiagram, 
        criterion, 
        this._getCriterionConfig(criterion),
        context
      );
    }

    // Analyze components and patterns
    evaluation.analysis = {
      components: this._analyzeComponents(normalizedDiagram),
      patterns: this._identifyPatterns(normalizedDiagram),
      issues: await this.analyzer.analyzeDiagram(
        normalizedDiagram.nodes, 
        normalizedDiagram.edges, 
        type
      )
    };

    // Calculate overall score
    evaluation.scores.overall = this._calculateOverallScore(evaluation.scores);

    // Generate recommendations
    evaluation.recommendations = this._generateRecommendations(
      evaluation.analysis,
      evaluation.scores,
      context
    );

    // Store evaluation results
    await this._storeEvaluation(evaluation, context);

    return evaluation;
  }

  _getCriteriaForType(type) {
    const commonCriteria = ['scalability', 'reliability', 'security'];
    
    switch (type) {
      case 'system':
        return [...commonCriteria, 'performance', 'maintainability'];
      case 'sequence':
        return [...commonCriteria, 'consistency', 'communication'];
      default:
        return commonCriteria;
    }
  }

  _getCriterionConfig(criterion) {
    const configs = {
      scalability: {
        weight: 0.25,
        checks: ['loadBalancing', 'horizontalScaling', 'caching']
      },
      reliability: {
        weight: 0.2,
        checks: ['redundancy', 'failover', 'errorHandling']
      },
      security: {
        weight: 0.25,
        checks: ['authentication', 'authorization', 'dataEncryption']
      },
      performance: {
        weight: 0.15,
        checks: ['responseTime', 'throughput', 'resourceUtilization']
      },
      maintainability: {
        weight: 0.15,
        checks: ['modularity', 'coupling', 'cohesion']
      }
    };

    return configs[criterion] || { weight: 0.1, checks: [] };
  }

  async _evaluateCriterion(diagram, criterion, config, context) {
    const score = {
      value: 0,
      details: [],
      improvements: []
    };

    for (const check of config.checks) {
      const checkResult = await this._performCheck(diagram, check, context);
      score.value += checkResult.score * config.weight;
      score.details.push(checkResult);
      
      if (checkResult.improvements) {
        score.improvements.push(...checkResult.improvements);
      }
    }

    return score;
  }

  _analyzeComponents(diagram) {
    return {
      count: {
        services: diagram.nodes.filter(n => n.type === 'service').length,
        databases: diagram.nodes.filter(n => n.type === 'database').length,
        queues: diagram.nodes.filter(n => n.type === 'queue').length,
        caches: diagram.nodes.filter(n => n.type === 'cache').length,
        gateways: diagram.nodes.filter(n => n.type === 'gateway').length,
        loadBalancers: diagram.nodes.filter(n => n.type === 'loadBalancer').length
      },
      relationships: this._analyzeRelationships(diagram.nodes, diagram.edges),
      complexity: this._calculateComplexity(diagram)
    };
  }

  _identifyPatterns(diagram) {
    return this.patternLibrary.detectPatterns({
      nodes: diagram.nodes,
      edges: diagram.edges
    });
  }

  _calculateOverallScore(scores) {
    const weights = {
      scalability: 0.25,
      reliability: 0.2,
      security: 0.25,
      performance: 0.15,
      maintainability: 0.15
    };

    let totalScore = 0;
    let totalWeight = 0;

    for (const [criterion, score] of Object.entries(scores)) {
      if (criterion !== 'overall') {
        const weight = weights[criterion] || 0.1;
        totalScore += score.value * weight;
        totalWeight += weight;
      }
    }

    return totalWeight > 0 ? totalScore / totalWeight : 0;
  }

  _normalizeDiagram(diagram, type) {
    const structure = diagramStructure[type];
    if (!structure) {
      throw new Error(`Unsupported diagram type: ${type}`);
    }

    return {
      ...diagram,
      nodes: diagram.nodes.map(node => ({
        ...node,
        type: node.type.toLowerCase()
      })),
      edges: diagram.edges.map(edge => ({
        ...edge,
        type: edge.type?.toLowerCase() || 'default'
      }))
    };
  }

  async _storeEvaluation(evaluation, context) {
    try {
      // Store evaluation in database
      const Diagram = require('../../models/Diagram');
      await Diagram.findOneAndUpdate(
        { diagramId: evaluation.diagramId },
        {
          $set: { currentScore: evaluation.scores.overall },
          $push: { 
            snapshots: {
              timestamp: evaluation.timestamp,
              scores: evaluation.scores,
              analysis: evaluation.analysis
            }
          }
        },
        { upsert: true }
      );
    } catch (error) {
      console.error('Failed to store evaluation:', error);
    }
  }

  _analyzeRelationships(nodes, edges) {
    return {
      connectivity: this._calculateConnectivity(nodes, edges),
      dependencies: this._analyzeDependencies(nodes, edges),
      bottlenecks: this._identifyBottlenecks(nodes, edges)
    };
  }

  _calculateComplexity(diagram) {
    const nodeComplexity = diagram.nodes.length;
    const edgeComplexity = diagram.edges.length;
    const patternComplexity = this._identifyPatterns(diagram).length;

    return {
      value: (nodeComplexity * 0.4) + (edgeComplexity * 0.4) + (patternComplexity * 0.2),
      details: {
        nodes: nodeComplexity,
        edges: edgeComplexity,
        patterns: patternComplexity
      }
    };
  }
}

module.exports = DiagramEvaluationService;



================================================================================
# FILE: server\services\diagram\diagramManager.js
# EXTENSION: .js
================================================================================
const { diagramStructure } = require('../../../data/diagram_structure');
const mermaid = require('mermaid');

class DiagramManager {
  constructor() {
    this.diagrams = new Map();
  }

  createDiagram(type, initialData) {
    const structure = diagramStructure[type];
    if (!structure) {
      throw new Error(`Unsupported diagram type: ${type}`);
    }

    const diagram = { 
      metadata: {
        type,
        title: initialData.title || 'Untitled Diagram',
        description: initialData.description || ''
      },
      components: this._initializeComponents(type, initialData),
      mermaid: {
        template: structure.mermaid.template,
        generated: this._generateMermaid(type, in,itialData)
      }
    };

    const diagramId = `${type}_${Date.now()}`;
    this.diagrams.set(diagramId, diagram);
    return { id: diagramId, ...diagram };
  }

  updateDiagram(diagramId, updates) {
    const diagram = this.diagrams.get(diagramId);
    if (!diagram) {
      throw new Error(`Diagram not found: ${diagramId}`);
    }

    const updatedComponents = this._mergeComponents(diagram.components, updates);
    const updatedDiagram = {
      ...diagram,
      components: updatedComponents,
      mermaid: {
        ...diagram.mermaid,
        generated: this._generateMermaid(diagram.metadata.type, updatedComponents)
      }
    };
    
    this.diagrams.set(diagramId, updatedDiagram);
    return updatedDiagram;
  }

  _initializeComponents(type, data) {
    switch (type) {
      case 'sequence':
        return {
          actors: data.actors || [],
          messages: data.messages || []
        };
      case 'system':
        return {
          nodes: data.nodes || [],
          connections: data.connections || []
        };
      default:
        return {};
    }
  }

  _generateMermaid(type, components) {
    const structure = diagramStructure[type];
    if (!structure?.mermaid?.template) {
      return '';
    }

    // Basic template replacement - in real implementation, 
    // would use a proper template engine like Handlebars
    let code = structure.mermaid.template;
    
    if (type === 'sequence') {
      const actorLines = components.actors
        .map(actor => `participant ${actor.id} as ${actor.name}`)
        .join('\n');
      const messageLines = components.messages
        .map(msg => `${msg.from}->>${msg.to}: ${msg.label}`)
        .join('\n');
      code = `sequenceDiagram\n${actorLines}\n${messageLines}`;
    } else if (type === 'system') {
      const nodeLines = components.nodes
        .map(node => `${node.id}[${node.label}]`)
        .join('\n');
      const connectionLines = components.connections
        .map(conn => `${conn.from} -->|${conn.label}| ${conn.to}`)
        .join('\n');
      code = `graph TD\n${nodeLines}\n${connectionLines}`;
    }

    return code;
  }

  _mergeComponents(existing, updates) {
    // Deep merge of components while preserving structure
    return {
      ...existing,
      ...Object.entries(updates).reduce((acc, [key, value]) => {
        if (Array.isArray(existing[key]) && Array.isArray(value)) {
          // Merge arrays by id if objects have ids, otherwise concat
          acc[key] = value.map(item => {
            if (item.id) {
              const existingItem = existing[key].find(e => e.id === item.id);
              return existingItem ? { ...existingItem, ...item } : item;
            }
            return item;
          });
        } else {
          acc[key] = value;
        }
        return acc;
      }, {})
    };
  }

  getDiagram(diagramId) {
    return this.diagrams.get(diagramId);
  }

  deleteDiagram(diagramId) {
    return this.diagrams.delete(diagramId);
  }
}

module.exports = new DiagramManager();


================================================================================
# FILE: server\services\diagram\diagramProgressTracker.js
# EXTENSION: .js
================================================================================
const DiagramScoringService = require('./diagramScoringService');
const { diagramStructure } = require('../../../data/diagram_structure');

class DiagramProgressTracker {
  constructor() {
    this.scoringService = new DiagramScoringService();
  }

  async trackProgress(sessionId, diagramId, currentDiagram) {
    const snapshot = await this._createSnapshot(currentDiagram);
    await this._saveSnapshot(sessionId, diagramId, snapshot);
    
    const analysis = await this._analyzeProgress(sessionId, diagramId);
    
    return {
      currentSnapshot: snapshot,
      progress: analysis.progress,
      trends: analysis.trends,
      nextSteps: analysis.recommendations
    };
  }

  async _createSnapshot(diagram) {
    const scores = await this.scoringService.evaluateAndScore(diagram);
    
    return {
      timestamp: Date.now(),
      scores: scores,
      componentCounts: this._countComponents(diagram),
      complexity: this._calculateComplexity(diagram),
      patterns: this._identifyPatterns(diagram)
    };
  }

  _countComponents(diagram) {
    const counts = {};
    diagram.nodes.forEach(node => {
      counts[node.type] = (counts[node.type] || 0) + 1;
    });
    return counts;
  }

  _calculateComplexity(diagram) {
    return {
      nodes: diagram.nodes.length,
      edges: diagram.edges.length,
      density: diagram.edges.length / (diagram.nodes.length || 1),
      avgConnections: diagram.nodes.reduce((acc, node) => {
        const connections = diagram.edges.filter(e => 
          e.source === node.id || e.target === node.id
        ).length;
        return acc + connections;
      }, 0) / (diagram.nodes.length || 1)
    };
  }

  _identifyPatterns(diagram) {
    const patterns = {
      loadBalancing: false,
      caching: false,
      messageQueue: false,
      apiGateway: false,
      serviceDiscovery: false,
      circuitBreaker: false
    };

    // Check for load balancing pattern
    patterns.loadBalancing = diagram.nodes.some(n => n.type === 'loadBalancer');

    // Check for caching pattern
    patterns.caching = diagram.nodes.some(n => n.type === 'cache');

    // Check for message queue pattern
    patterns.messageQueue = diagram.nodes.some(n => n.type === 'queue');

    // Check for API Gateway pattern
    patterns.apiGateway = diagram.nodes.some(n => 
      n.type === 'apiGateway' || 
      n.data?.label?.toLowerCase().includes('api gateway')
    );

    // Check for service discovery
    patterns.serviceDiscovery = diagram.nodes.some(n => 
      n.type === 'serviceDiscovery' || 
      n.data?.label?.toLowerCase().includes('service discovery')
    );

    // Check for circuit breaker pattern
    patterns.circuitBreaker = diagram.edges.some(e => 
      e.data?.type === 'circuitBreaker' || 
      e.data?.label?.toLowerCase().includes('circuit breaker')
    );

    return patterns;
  }

  async _saveSnapshot(sessionId, diagramId, snapshot) {
    // Assuming we have a DiagramModel in the database
    const DiagramModel = require('../../models/Diagram');
    
    await DiagramModel.updateOne(
      { sessionId, diagramId },
      { 
        $push: { 
          snapshots: snapshot 
        },
        $set: {
          lastUpdated: Date.now(),
          currentScore: snapshot.scores.overall
        }
      },
      { upsert: true }
    );
  }

  async _analyzeProgress(sessionId, diagramId) {
    const DiagramModel = require('../../models/Diagram');
    const diagram = await DiagramModel.findOne({ sessionId, diagramId });
    
    if (!diagram || !diagram.snapshots || diagram.snapshots.length < 2) {
      return {
        progress: {},
        trends: {},
        recommendations: []
      };
    }

    const snapshots = diagram.snapshots;
    const latest = snapshots[snapshots.length - 1];
    const previous = snapshots[snapshots.length - 2];

    const progress = {
      scoreImprovement: latest.scores.overall - previous.scores.overall,
      newPatterns: this._getNewPatterns(previous.patterns, latest.patterns),
      complexityChange: this._getComplexityChange(previous.complexity, latest.complexity)
    };

    const trends = this._calculateTrends(snapshots);

    const recommendations = this._generateRecommendations(latest, trends);

    return { progress, trends, recommendations };
  }

  _getNewPatterns(previous, current) {
    const newPatterns = [];
    for (const [pattern, implemented] of Object.entries(current)) {
      if (implemented && !previous[pattern]) {
        newPatterns.push(pattern);
      }
    }
    return newPatterns;
  }

  _getComplexityChange(previous, current) {
    return {
      nodes: current.nodes - previous.nodes,
      edges: current.edges - previous.edges,
      density: current.density - previous.density,
      avgConnections: current.avgConnections - previous.avgConnections
    };
  }

  _calculateTrends(snapshots) {
    const trends = {
      scores: {},
      patterns: {},
      complexity: {}
    };

    // Calculate score trends
    trends.scores = this._calculateScoreTrends(snapshots);

    // Calculate pattern adoption trends
    trends.patterns = this._calculatePatternTrends(snapshots);

    // Calculate complexity trends
    trends.complexity = this._calculateComplexityTrends(snapshots);

    return trends;
  }

  _calculateScoreTrends(snapshots) {
    const categories = ['overall', 'scalability', 'reliability', 'security', 'maintainability'];
    const trends = {};

    categories.forEach(category => {
      const scores = snapshots.map(s => s.scores[category]);
      trends[category] = this._calculateTrendMetrics(scores);
    });

    return trends;
  }

  _calculatePatternTrends(snapshots) {
    const patterns = {};
    const latestSnapshot = snapshots[snapshots.length - 1];

    Object.keys(latestSnapshot.patterns).forEach(pattern => {
      const adoption = snapshots.map(s => s.patterns[pattern]);
      patterns[pattern] = {
        adopted: adoption[adoption.length - 1],
        adoptionSnapshot: adoption.findIndex(a => a === true)
      };
    });

    return patterns;
  }

  _calculateComplexityTrends(snapshots) {
    const metrics = ['nodes', 'edges', 'density', 'avgConnections'];
    const trends = {};

    metrics.forEach(metric => {
      const values = snapshots.map(s => s.complexity[metric]);
      trends[metric] = this._calculateTrendMetrics(values);
    });

    return trends;
  }

  _calculateTrendMetrics(values) {
    const recent = values.slice(-3);
    return {
      current: values[values.length - 1],
      change: values[values.length - 1] - values[0],
      recentTrend: recent[2] - recent[0],
      volatility: this._calculateVolatility(values)
    };
  }

  _calculateVolatility(values) {
    if (values.length < 2) return 0;
    let sumSquaredDiff = 0;
    for (let i = 1; i < values.length; i++) {
      sumSquaredDiff += Math.pow(values[i] - values[i-1], 2);
    }
    return Math.sqrt(sumSquaredDiff / (values.length - 1));
  }

  _generateRecommendations(latest, trends) {
    const recommendations = [];

    // Check for negative trends
    Object.entries(trends.scores).forEach(([category, trend]) => {
      if (trend.recentTrend < 0) {
        recommendations.push({
          type: 'warning',
          category,
          message: `${category} score has been declining. Consider reviewing recent changes.`
        });
      }
    });

    // Check for missing important patterns
    Object.entries(latest.patterns).forEach(([pattern, implemented]) => {
      if (!implemented) {
        recommendations.push({
          type: 'suggestion',
          category: 'patterns',
          message: `Consider implementing ${pattern} pattern to improve system design.`
        });
      }
    });

    // Check complexity trends
    if (trends.complexity.density.recentTrend > 0.2) {
      recommendations.push({
        type: 'warning',
        category: 'complexity',
        message: 'System complexity is increasing rapidly. Consider refactoring for better maintainability.'
      });
    }

    return recommendations;
  }
}

module.exports = DiagramProgressTracker;


================================================================================
# FILE: server\services\diagram\diagramScoringService.js
# EXTENSION: .js
================================================================================
const PatternRegistry = require('./patterns/PatternRegistry');
const DiagramAnalyzer = require('./diagramAnalyzer');

class DiagramScoringService {
  constructor() {
    this.patternRegistry = new PatternRegistry();
    this.analyzer = new DiagramAnalyzer();
    
    this.scoringCriteria = {
      patterns: {
        weight: 0.3,
        criteria: {
          scalability: { weight: 0.4 },
          reliability: { weight: 0.3 },
          security: { weight: 0.2 },
          performance: { weight: 0.1 }
        }
      },
      complexity: {
        weight: 0.2,
        optimal: {
          nodes: { min: 3, max: 15 },
          edges: { min: 2, max: 20 },
          depth: { min: 2, max: 4 }
        }
      },
      bestPractices: {
        weight: 0.3,
        checks: [
          'hasLoadBalancer',
          'hasCaching',
          'hasErrorHandling',
          'hasAuthentication',
          'hasRedundancy'
        ]
      },
      analysis: {
        weight: 0.2,
        aspects: [
          'securityConcerns',
          'scalabilityIssues',
          'reliabilityRisks',
          'performanceBottlenecks'
        ]
      }
    };
  }

  async evaluateAndScore(diagram) {
    const analysis = await this.analyzer.analyzeDiagram(
      diagram.nodes, 
      diagram.edges, 
      diagram.type
    );

    const detectedPatterns = this.patternRegistry.detectPatterns(diagram);
    
    const scores = {
      patterns: this._scorePatterns(detectedPatterns),
      complexity: this._scoreComplexity(diagram),
      bestPractices: this._scoreBestPractices(diagram, detectedPatterns),
      analysis: this._scoreAnalysis(analysis),
      total: 0
    };

    scores.total = this._calculateTotalScore(scores);

    return {
      ...scores,
      details: {
        patterns: detectedPatterns,
        analysis: analysis,
        recommendations: this._generateRecommendations(scores, diagram)
      }
    };
  }

  _scorePatterns(detectedPatterns) {
    const categoryScores = {};
    let totalScore = 0;

    for (const pattern of detectedPatterns) {
      const category = pattern.category;
      const categoryWeight = this.scoringCriteria.patterns.criteria[category]?.weight || 0;
      
      categoryScores[category] = categoryScores[category] || 0;
      categoryScores[category] += pattern.score;
    }

    // Normalize category scores and apply weights
    for (const [category, score] of Object.entries(categoryScores)) {
      const weight = this.scoringCriteria.patterns.criteria[category].weight;
      totalScore += score * weight;
    }

    return totalScore * this.scoringCriteria.patterns.weight;
  }

  _scoreComplexity(diagram) {
    const { nodes, edges } = diagram;
    const optimal = this.scoringCriteria.complexity.optimal;
    
    const nodeScore = this._calculateRangeScore(
      nodes.length,
      optimal.nodes.min,
      optimal.nodes.max
    );

    const edgeScore = this._calculateRangeScore(
      edges.length,
      optimal.edges.min,
      optimal.edges.max
    );

    const depth = this._calculateGraphDepth(diagram);
    const depthScore = this._calculateRangeScore(
      depth,
      optimal.depth.min,
      optimal.depth.max
    );

    const complexityScore = (nodeScore + edgeScore + depthScore) / 3;
    return complexityScore * this.scoringCriteria.complexity.weight;
  }

  _scoreBestPractices(diagram, detectedPatterns) {
    const checks = this.scoringCriteria.bestPractices.checks;
    let score = 0;

    for (const check of checks) {
      switch (check) {
        case 'hasLoadBalancer':
          score += diagram.nodes.some(n => n.type === 'loadBalancer') ? 1 : 0;
          break;
        case 'hasCaching':
          score += diagram.nodes.some(n => n.type === 'cache') ? 1 : 0;
          break;
        case 'hasErrorHandling':
          score += detectedPatterns.some(p => p.id === 'circuitBreaker') ? 1 : 0;
          break;
        case 'hasAuthentication':
          score += detectedPatterns.some(p => p.id === 'authenticationLayer') ? 1 : 0;
          break;
        case 'hasRedundancy':
          score += detectedPatterns.some(p => p.id === 'failover') ? 1 : 0;
          break;
      }
    }

    return (score / checks.length) * this.scoringCriteria.bestPractices.weight;
  }

  _scoreAnalysis(analysis) {
    const aspects = this.scoringCriteria.analysis.aspects;
    let score = 0;

    for (const aspect of aspects) {
      const issues = analysis.criticalIssues.filter(issue => 
        issue.category === aspect
      );
      
      // More issues = lower score
      const aspectScore = Math.max(0, 1 - (issues.length * 0.2));
      score += aspectScore;
    }

    return (score / aspects.length) * this.scoringCriteria.analysis.weight;
  }

  _calculateRangeScore(value, min, max) {
    if (value < min) {
      return Math.max(0, 1 - ((min - value) / min));
    }
    if (value > max) {
      return Math.max(0, 1 - ((value - max) / max));
    }
    return 1;
  }

  _calculateGraphDepth(diagram) {
    const visited = new Set();
    const depths = new Map();

    const calculateNodeDepth = (nodeId, depth = 0) => {
      if (visited.has(nodeId)) {
        return depths.get(nodeId);
      }

      visited.add(nodeId);
      depths.set(nodeId, depth);

      const outgoingEdges = diagram.edges.filter(e => e.source === nodeId);
      for (const edge of outgoingEdges) {
        const childDepth = calculateNodeDepth(edge.target, depth + 1);
        depths.set(nodeId, Math.max(depths.get(nodeId), childDepth));
      }

      return depths.get(nodeId);
    };

    // Find root nodes (nodes with no incoming edges)
    const rootNodes = diagram.nodes.filter(node =>
      !diagram.edges.some(edge => edge.target === node.id)
    );

    // Calculate max depth from each root
    let maxDepth = 0;
    for (const root of rootNodes) {
      const depth = calculateNodeDepth(root.id);
      maxDepth = Math.max(maxDepth, depth);
    }

    return maxDepth;
  }

  _calculateTotalScore(scores) {
    return Object.values(scores).reduce((total, score) => 
      typeof score === 'number' ? total + score : total, 
      0
    );
  }

  _generateRecommendations(scores, diagram) {
    const recommendations = [];

    // Pattern-based recommendations
    if (scores.patterns < 0.6) {
      const missingPatterns = this._findMissingCriticalPatterns(diagram);
      recommendations.push(...missingPatterns.map(pattern => ({
        type: 'pattern',
        priority: 'high',
        message: `Consider implementing ${pattern.name} pattern`,
        details: pattern.description
      })));
    }

    // Complexity recommendations
    if (scores.complexity < 0.5) {
      recommendations.push({
        type: 'complexity',
        priority: 'medium',
        message: 'Diagram complexity needs optimization',
        details: 'Consider simplifying the architecture or breaking it into smaller components'
      });
    }

    // Best practices recommendations
    if (scores.bestPractices < 0.7) {
      const missingPractices = this._findMissingBestPractices(diagram);
      recommendations.push(...missingPractices.map(practice => ({
        type: 'bestPractice',
        priority: 'high',
        message: `Missing: ${practice}`,
        details: `Implement ${practice} to improve architecture robustness`
      })));
    }

    return recommendations;
  }

  _findMissingCriticalPatterns(diagram) {
    const criticalPatterns = ['loadBalancing', 'caching', 'circuitBreaker'];
    const detectedPatterns = this.patternRegistry.detectPatterns(diagram);
    
    return criticalPatterns.filter(patternId => 
      !detectedPatterns.some(p => p.id === patternId)
    ).map(patternId => this.patternRegistry.getPattern(patternId));
  }

  _findMissingBestPractices(diagram) {
    return this.scoringCriteria.bestPractices.checks.filter(check => {
      switch (check) {
        case 'hasLoadBalancer':
          return !diagram.nodes.some(n => n.type === 'loadBalancer');
        case 'hasCaching':
          return !diagram.nodes.some(n => n.type === 'cache');
        case 'hasErrorHandling':
          return !diagram.nodes.some(n => n.data?.metadata?.includes('errorHandling'));
        case 'hasAuthentication':
          return !diagram.nodes.some(n => n.data?.metadata?.includes('auth'));
        case 'hasRedundancy':
          return !this._hasRedundancy(diagram);
      }
    });
  }

  _hasRedundancy(diagram) {
    const serviceCounts = {};
    for (const node of diagram.nodes) {
      serviceCounts[node.type] = (serviceCounts[node.type] || 0) + 1;
    }
    return Object.values(serviceCounts).some(count => count > 1);
  }
}

module.exports = DiagramScoringService;


================================================================================
# FILE: server\services\diagram\diagramService.js
# EXTENSION: .js
================================================================================
const DiagramAnalyzer = require('./diagramAnalyzer');
const DiagramEvaluationService = require('./diagramEvaluationService');

class DiagramService {
  constructor() {
    this.analyzer = new DiagramAnalyzer();
    this.evaluator = new DiagramEvaluationService();
  }

  /**
   * Generates a diagram based on the given parameters
   * @param {string} sessionId 
   * @param {string} type 
   * @param {Object} context 
   * @returns {Promise<Object>}
   */
  async generateDiagram(sessionId, type, context = {}) {
    try {
      const prompt = this._buildGenerationPrompt(type, context);
      // TODO: Implement AI-based diagram generation
      return {
        nodes: [],
        edges: []
      };
    } catch (error) {
      throw new Error(`Failed to generate diagram: ${error.message}`);
    }
  }

  /**
   * Evaluates a diagram
   * @param {Object} diagram 
   * @param {string} sessionId 
   * @param {string} type 
   * @returns {Promise<Object>}
   */
  async evaluateDiagram(diagram, sessionId, type) {
    try {
      const analysis = await this.analyzer.analyzeDiagram(diagram);
      const evaluation = await this.evaluator.evaluateAndScore(diagram, analysis);
      
      return {
        analysis,
        evaluation,
        sessionId,
        type
      };
    } catch (error) {
      throw new Error(`Failed to evaluate diagram: ${error.message}`);
    }
  }

  /**
   * Extracts Mermaid code from text
   * @param {string} text 
   * @returns {string}
   */
  extractMermaidCode(text) {
    const mermaidPattern = /```mermaid\n([\s\S]*?)\n```/;
    const match = text.match(mermaidPattern);
    return match ? match[1].trim() : '';
  }

  /**
   * Builds generation prompt based on type and context
   * @param {string} type 
   * @param {Object} context 
   * @returns {string}
   */
  _buildGenerationPrompt(type, context) {
    // TODO: Implement prompt building logic
    return '';
  }
}

// Create a singleton instance
const diagramService = new DiagramService();

// Export the singleton
module.exports = diagramService;


================================================================================
# FILE: server\services\diagram\NodeTypes\nodePresets.js
# EXTENSION: .js
================================================================================
// Common node types and their default configurations
const nodePresets = {
  service: {
    type: 'service',
    category: 'compute',
    defaults: {
      scalable: true,
      stateless: true,
      hasHealthCheck: true
    },
    requirements: {
      connections: ['database', 'cache', 'queue'],
      security: ['authentication', 'authorization']
    }
  },
  
  loadBalancer: {
    type: 'loadBalancer',
    category: 'networking',
    defaults: {
      algorithm: 'round-robin',
      healthChecks: true
    },
    requirements: {
      connections: ['service'],
      minimum: {
        targets: 2
      }
    }
  },

  database: {
    type: 'database',
    category: 'storage',
    defaults: {
      persistent: true,
      backup: true
    },
    requirements: {
      connections: ['service'],
      security: ['encryption', 'access-control']
    }
  },

  cache: {
    type: 'cache',
    category: 'storage',
    defaults: {
      volatile: true,
      evictionPolicy: 'LRU'
    },
    requirements: {
      connections: ['service']
    }
  },

  queue: {
    type: 'queue',
    category: 'messaging',
    defaults: {
      persistent: true,
      ordered: true
    },
    requirements: {
      connections: ['service'],
      patterns: ['publisher-subscriber', 'point-to-point']
    }
  },

  gateway: {
    type: 'gateway',
    category: 'networking',
    defaults: {
      routing: true,
      authentication: true
    },
    requirements: {
      connections: ['service', 'loadBalancer'],
      security: ['rate-limiting', 'authentication']
    }
  }
};

// Helper functions for node type validation and properties
const nodeTypeHelpers = {
  isValidType: (type) => Object.keys(nodePresets).includes(type),
  
  getDefaultProperties: (type) => {
    if (!nodePresets[type]) return {};
    return { ...nodePresets[type].defaults };
  },
  
  getRequirements: (type) => {
    if (!nodePresets[type]) return {};
    return { ...nodePresets[type].requirements };
  },
  
  getCategory: (type) => {
    if (!nodePresets[type]) return 'unknown';
    return nodePresets[type].category;
  }
};

module.exports = {
  nodePresets,
  nodeTypeHelpers
};


================================================================================
# FILE: server\services\diagram\patternDetector.js
# EXTENSION: .js
================================================================================
const { diagramStructure } = require('../../../data/diagram_structure');

class PatternDetector {
  constructor() {
    this.patterns = {
      loadBalancing: {
        detect: this._detectLoadBalancing,
        requirements: {
          nodes: ['loadBalancer', 'service'],
          minServices: 2
        }
      },
      microservices: {
        detect: this._detectMicroservices,
        requirements: {
          nodes: ['service'],
          minServices: 3,
          connections: true
        }
      },
      caching: {
        detect: this._detectCaching,
        requirements: {
          nodes: ['cache', 'service']
        }
      },
      messageQueue: {
        detect: this._detectMessageQueue,
        requirements: {
          nodes: ['queue', 'service']
        }
      },
      apiGateway: {
        detect: this._detectApiGateway,
        requirements: {
          nodes: ['gateway', 'service']
        }
      }
    };
  }

  detectPatterns(nodes, edges) {
    const results = {
      detectedPatterns: {},
      suggestions: [],
      score: 0
    };

    for (const [patternName, pattern] of Object.entries(this.patterns)) {
      const detection = this._analyzePattern(patternName, pattern, nodes, edges);
      results.detectedPatterns[patternName] = detection.detected;
      results.suggestions.push(...detection.suggestions);
      results.score += detection.score;
    }

    return results;
  }

  _analyzePattern(patternName, pattern, nodes, edges) {
    const result = pattern.detect(nodes, edges, pattern.requirements);
    return {
      detected: result.detected,
      suggestions: result.suggestions,
      score: result.detected ? 1 : 0
    };
  }

  _detectLoadBalancing(nodes, edges, requirements) {
    const loadBalancers = nodes.filter(n => n.type === 'loadBalancer');
    const services = nodes.filter(n => n.type === 'service');
    
    const hasValidConfig = loadBalancers.length > 0 && services.length >= requirements.minServices;
    const hasProperConnections = loadBalancers.every(lb => {
      const connectedServices = edges.filter(e => 
        (e.source === lb.id && services.some(s => s.id === e.target)) ||
        (e.target === lb.id && services.some(s => s.id === e.source))
      );
      return connectedServices.length >= 2;
    });

    return {
      detected: hasValidConfig && hasProperConnections,
      suggestions: !hasValidConfig ? 
        ['Add a load balancer to distribute traffic across multiple service instances'] :
        !hasProperConnections ?
        ['Connect load balancer to multiple service instances for proper load distribution'] : []
    };
  }

  _detectMicroservices(nodes, edges, requirements) {
    const services = nodes.filter(n => n.type === 'service');
    const hasEnoughServices = services.length >= requirements.minServices;
    
    const serviceConnections = new Map();
    edges.forEach(edge => {
      if (!serviceConnections.has(edge.source)) serviceConnections.set(edge.source, new Set());
      if (!serviceConnections.has(edge.target)) serviceConnections.set(edge.target, new Set());
      serviceConnections.get(edge.source).add(edge.target);
      serviceConnections.get(edge.target).add(edge.source);
    });

    const isLooselyCoupled = Array.from(serviceConnections.values())
      .every(connections => connections.size < services.length - 1);

    return {
      detected: hasEnoughServices && isLooselyCoupled,
      suggestions: !hasEnoughServices ?
        ['Consider breaking down the application into more microservices'] :
        !isLooselyCoupled ?
        ['Services appear tightly coupled. Consider reducing direct dependencies between services'] : []
    };
  }

  _detectCaching(nodes, edges, requirements) {
    const caches = nodes.filter(n => n.type === 'cache');
    const services = nodes.filter(n => n.type === 'service');
    
    const hasComponents = caches.length > 0 && services.length > 0;
    const hasProperConnections = caches.every(cache => 
      edges.some(e => 
        (e.source === cache.id && services.some(s => s.id === e.target)) ||
        (e.target === cache.id && services.some(s => s.id === e.source))
      )
    );

    return {
      detected: hasComponents && hasProperConnections,
      suggestions: !hasComponents ?
        ['Add caching layer to improve performance'] :
        !hasProperConnections ?
        ['Connect cache nodes to relevant services'] : []
    };
  }

  _detectMessageQueue(nodes, edges, requirements) {
    const queues = nodes.filter(n => n.type === 'queue');
    const services = nodes.filter(n => n.type === 'service');
    
    const hasComponents = queues.length > 0 && services.length > 0;
    const hasProducerConsumer = queues.every(queue => {
      const connectedServices = edges.filter(e => 
        e.source === queue.id || e.target === queue.id
      );
      return connectedServices.length >= 2;
    });

    return {
      detected: hasComponents && hasProducerConsumer,
      suggestions: !hasComponents ?
        ['Consider adding message queues for asynchronous communication'] :
        !hasProducerConsumer ?
        ['Ensure message queues have both producer and consumer services'] : []
    };
  }

  _detectApiGateway(nodes, edges, requirements) {
    const gateways = nodes.filter(n => n.type === 'gateway');
    const services = nodes.filter(n => n.type === 'service');
    
    const hasComponents = gateways.length > 0 && services.length > 0;
    const isProperlyConnected = gateways.every(gateway =>
      edges.some(e => e.source === gateway.id && services.some(s => s.id === e.target))
    );

    return {
      detected: hasComponents && isProperlyConnected,
      suggestions: !hasComponents ?
        ['Add an API Gateway to manage external requests'] :
        !isProperlyConnected ?
        ['Connect API Gateway to backend services'] : []
    };
  }
}

module.exports = PatternDetector;


================================================================================
# FILE: server\services\diagram\patterns\PatternAnalyzer.js
# EXTENSION: .js
================================================================================
const PatternRegistry = require('./PatternRegistry');
const logger = require('../../../utils/logger');

class PatternAnalyzer {
  constructor() {
    this.registry = new PatternRegistry();
  }

  analyzePatterns(diagram) {
    try {
      // Get basic pattern detection results
      const patternResults = this.registry.detectPatterns(diagram);

      // Enhance with detailed analysis
      return {
        ...patternResults,
        analysis: this._performDetailedAnalysis(diagram, patternResults),
        recommendations: this._generateRecommendations(diagram, patternResults),
        qualityMetrics: this._calculateQualityMetrics(diagram, patternResults)
      };
    } catch (error) {
      logger.error('Error in pattern analysis:', error);
      throw new Error('Pattern analysis failed');
    }
  }

  _performDetailedAnalysis(diagram, patternResults) {
    const analysis = {
      strengths: [],
      weaknesses: [],
      risks: [],
      opportunities: []
    };

    // Analyze detected patterns
    for (const pattern of patternResults.detected) {
      const strengthsAndWeaknesses = this._analyzePatternImplementation(diagram, pattern);
      analysis.strengths.push(...strengthsAndWeaknesses.strengths);
      analysis.weaknesses.push(...strengthsAndWeaknesses.weaknesses);
    }

    // Analyze missing patterns
    for (const pattern of patternResults.missing) {
      const risks = this._analyzePatternGap(diagram, pattern);
      analysis.risks.push(...risks);
    }

    // Identify improvement opportunities
    analysis.opportunities = this._identifyOpportunities(diagram, patternResults);

    return analysis;
  }

  _analyzePatternImplementation(diagram, pattern) {
    const analysis = {
      strengths: [],
      weaknesses: []
    };

    switch (pattern.id) {
      case 'loadBalancing':
        this._analyzeLBImplementation(diagram, pattern, analysis);
        break;
      case 'caching':
        this._analyzeCachingImplementation(diagram, pattern, analysis);
        break;
      case 'messageQueue':
        this._analyzeQueueImplementation(diagram, pattern, analysis);
        break;
    }

    return analysis;
  }

  _analyzeLBImplementation(diagram, pattern, analysis) {
    const lbNodes = diagram.nodes.filter(n => n.type === 'loadBalancer');
    const serviceNodes = diagram.nodes.filter(n => n.type === 'service');

    if (lbNodes.length === 1 && serviceNodes.length > 3) {
      analysis.weaknesses.push('Single load balancer might become a bottleneck');
    }

    if (serviceNodes.length >= 2) {
      analysis.strengths.push('Multiple services enable horizontal scaling');
    }

    // Check for health check connections
    const hasHealthChecks = diagram.edges.some(e => 
      e.data?.properties?.includes('healthCheck')
    );
    
    if (!hasHealthChecks) {
      analysis.weaknesses.push('Missing health check mechanisms');
    }
  }

  _analyzeCachingImplementation(diagram, pattern, analysis) {
    const cacheNodes = diagram.nodes.filter(n => n.type === 'cache');
    const dbNodes = diagram.nodes.filter(n => n.type === 'database');

    if (cacheNodes.length === 1 && dbNodes.length > 0) {
      const hasDirectDbConnections = diagram.edges.some(e => {
        const source = diagram.nodes.find(n => n.id === e.source);
        const target = diagram.nodes.find(n => n.id === e.target);
        return source?.type === 'service' && target?.type === 'database';
      });

      if (hasDirectDbConnections) {
        analysis.weaknesses.push('Some services bypass cache layer');
      }
    }

    const distributedCache = cacheNodes.length > 1;
    if (distributedCache) {
      analysis.strengths.push('Distributed caching improves reliability');
    }
  }

  _analyzeQueueImplementation(diagram, pattern, analysis) {
    const queueNodes = diagram.nodes.filter(n => n.type === 'queue');
    const serviceNodes = diagram.nodes.filter(n => n.type === 'service');

    const hasDeadLetterQueue = queueNodes.some(n => 
      n.data?.properties?.includes('deadLetter')
    );

    if (!hasDeadLetterQueue) {
      analysis.weaknesses.push('Missing dead letter queue for error handling');
    }

    const hasMonitoring = queueNodes.some(n => 
      n.data?.properties?.includes('monitoring')
    );

    if (!hasMonitoring) {
      analysis.weaknesses.push('Queue monitoring not implemented');
    }
  }

  _analyzePatternGap(diagram, missingPattern) {
    const risks = [];

    switch (missingPattern.id) {
      case 'loadBalancing':
        if (diagram.nodes.filter(n => n.type === 'service').length > 1) {
          risks.push('Multiple services without load balancing may lead to uneven load distribution');
        }
        break;

      case 'caching':
        if (diagram.nodes.some(n => n.type === 'database')) {
          risks.push('Direct database access without caching may cause performance bottlenecks');
        }
        break;

      case 'messageQueue':
        const serviceCount = diagram.nodes.filter(n => n.type === 'service').length;
        if (serviceCount > 2) {
          risks.push('Multiple services communicating directly may lead to tight coupling');
        }
        break;
    }

    return risks;
  }

  _identifyOpportunities(diagram, patternResults) {
    const opportunities = [];
    const nodeTypes = new Set(diagram.nodes.map(n => n.type));

    // Identify potential improvements based on current architecture
    if (nodeTypes.has('database') && !nodeTypes.has('cache')) {
      opportunities.push({
        pattern: 'caching',
        description: 'Add caching layer to improve database performance',
        priority: 'HIGH'
      });
    }

    if (nodeTypes.has('service') && diagram.nodes.filter(n => n.type === 'service').length > 1) {
      if (!nodeTypes.has('loadBalancer')) {
        opportunities.push({
          pattern: 'loadBalancing',
          description: 'Implement load balancing for better scalability',
          priority: 'HIGH'
        });
      }
    }

    const serviceToServiceConnections = diagram.edges.filter(e => {
      const source = diagram.nodes.find(n => n.id === e.source);
      const target = diagram.nodes.find(n => n.id === e.target);
      return source?.type === 'service' && target?.type === 'service';
    });

    if (serviceToServiceConnections.length > 2 && !nodeTypes.has('queue')) {
      opportunities.push({
        pattern: 'messageQueue',
        description: 'Add message queue to decouple services',
        priority: 'MEDIUM'
      });
    }

    return opportunities;
  }

  _calculateQualityMetrics(diagram, patternResults) {
    return {
      patternCoverage: this._calculatePatternCoverage(patternResults),
      implementationQuality: this._calculateImplementationQuality(patternResults),
      architecturalFitness: this._calculateArchitecturalFitness(diagram, patternResults)
    };
  }

  _calculatePatternCoverage(patternResults) {
    const totalPatterns = patternResults.detected.length + patternResults.missing.length;
    return (patternResults.detected.length / totalPatterns) * 100;
  }

  _calculateImplementationQuality(patternResults) {
    if (patternResults.detected.length === 0) return 0;
    
    const totalScore = patternResults.detected.reduce((sum, p) => sum + p.score, 0);
    return totalScore / patternResults.detected.length;
  }

  _calculateArchitecturalFitness(diagram, patternResults) {
    // Base score starts at 100 and gets reduced for architectural issues
    let score = 100;

    // Analyze service distribution
    const serviceCount = diagram.nodes.filter(n => n.type === 'service').length;
    if (serviceCount > 3 && !patternResults.detected.some(p => p.id === 'loadBalancing')) {
      score -= 20;
    }

    // Analyze data access patterns
    const hasDatabase = diagram.nodes.some(n => n.type === 'database');
    if (hasDatabase && !patternResults.detected.some(p => p.id === 'caching')) {
      score -= 15;
    }

    // Analyze service coupling
    const serviceToServiceEdges = diagram.edges.filter(e => {
      const source = diagram.nodes.find(n => n.id === e.source);
      const target = diagram.nodes.find(n => n.id === e.target);
      return source?.type === 'service' && target?.type === 'service';
    });

    if (serviceToServiceEdges.length > 2 && !patternResults.detected.some(p => p.id === 'messageQueue')) {
      score -= 15;
    }

    return Math.max(0, score);
  }
}

module.exports = PatternAnalyzer;


================================================================================
# FILE: server\services\diagram\patterns\PatternLibrary.js
# EXTENSION: .js
================================================================================
const PatternRegistry = require('./PatternRegistry');

class PatternLibrary {
  constructor() {
    this.registry = new PatternRegistry();
  }

  getPatternSuggestions(nodes, edges) {
    const suggestions = [];
    const detectedPatterns = this.detectPatterns(nodes, edges);
    const missingPatterns = this._identifyMissingPatterns(nodes, edges);
    
    // Analyze existing pattern implementations
    for (const pattern of detectedPatterns) {
      const analysis = this.analyzePatternImplementation(pattern, nodes, edges);
      if (analysis.improvements.length > 0) {
        suggestions.push({
          type: 'improvement',
          pattern: pattern.id,
          suggestions: analysis.improvements,
          priority: analysis.priority
        });
      }
    }

    return this.prioritizeSuggestions(suggestions);
  }

  analyzePatternImplementation(pattern, nodes, edges) {
    const analysis = {
      improvements: [],
      priority: 'low'
    };

    switch (pattern.name.toLowerCase()) {
      case 'caching':
        this._analyzeCachingPattern(nodes, edges, analysis);
        break;
      case 'message queue':
        this._analyzeQueuePattern(nodes, edges, analysis);
        break;
      case 'microservices':
        this._analyzeMicroservicesPattern(nodes, edges, analysis);
        break;
    }

    return analysis;
  }

  _analyzeCachingPattern(nodes, edges, analysis) {
    const cacheNodes = nodes.filter(n => n.type === 'cache');
    const dbNodes = nodes.filter(n => n.type === 'database');

    if (cacheNodes.length === 1 && dbNodes.length > 1) {
      analysis.improvements.push({
        type: 'optimization',
        details: 'Consider distributed caching for multiple databases',
        priority: 'medium'
      });
    }

    // Check cache connections
    const cacheConnections = edges.filter(e => 
      nodes.find(n => n.id === e.source && n.type === 'cache') ||
      nodes.find(n => n.id === e.target && n.type === 'cache')
    );

    if (cacheConnections.length < dbNodes.length) {
      analysis.improvements.push({
        type: 'missing_components',
        details: 'Not all database operations are cached',
        priority: 'high'
      });
    }
  }

  _analyzeQueuePattern(nodes, edges, analysis) {
    const queueNodes = nodes.filter(n => n.type === 'queue');
    const serviceNodes = nodes.filter(n => n.type === 'service');

    // Check for dead letter queue
    const hasDeadLetterQueue = queueNodes.some(n => 
      n.data?.properties?.includes('deadLetter')
    );

    if (!hasDeadLetterQueue) {
      analysis.improvements.push({
        type: 'missing_components',
        details: 'Add dead letter queue for error handling',
        priority: 'high'
      });
    }

    // Check queue connections
    if (queueNodes.length === 1 && serviceNodes.length > 3) {
      analysis.improvements.push({
        type: 'optimization',
        details: 'Consider multiple queues for better load distribution',
        priority: 'medium'
      });
    }
  }

  _analyzeMicroservicesPattern(nodes, edges, analysis) {
    const serviceNodes = nodes.filter(n => n.type === 'service');
    const lbNodes = nodes.filter(n => n.type === 'loadBalancer');

    if (serviceNodes.length > 2 && lbNodes.length === 0) {
      analysis.improvements.push({
        type: 'missing_components',
        details: 'Add load balancer for better request distribution',
        priority: 'high'
      });
    }

    // Check service isolation
    const directServiceConnections = edges.filter(e =>
      serviceNodes.find(n => n.id === e.source) &&
      serviceNodes.find(n => n.id === e.target)
    );

    if (directServiceConnections.length > serviceNodes.length) {
      analysis.improvements.push({
        type: 'optimization',
        details: 'Consider using API Gateway or Message Queue for service communication',
        priority: 'medium'
      });
    }
  }

  prioritizeSuggestions(suggestions) {
    return suggestions.sort((a, b) => {
      const priorities = { high: 3, medium: 2, low: 1 };
      return priorities[b.priority] - priorities[a.priority];
    });
  }

  detectPatterns(nodes, edges) {
    return this.registry.detectPatterns({ nodes, edges });
  }

  _identifyMissingPatterns(nodes, edges) {
    // Implementation of missing pattern identification
    return [];
  }
}

module.exports = PatternLibrary;


================================================================================
# FILE: server\services\diagram\patterns\PatternRegistry.js
# EXTENSION: .js
================================================================================
const logger = require('../../../utils/logger');
const PatternTemplates = require('./PatternTemplates');

const patterns = {
  loadBalancing: {
    id: 'loadBalancing',
    name: 'Load Balancing Pattern',
    category: 'scalability',
    description: 'Distributes incoming traffic across multiple service instances',
    detection: {
      required: {
        nodes: [
          { type: 'service', minCount: 2 },
          { type: 'loadBalancer', count: 1 }
        ],
        connections: ['loadBalancer-service']
      }
    },
    bestPractices: [
      'Health checks should be implemented',
      'Multiple service instances should be in different availability zones',
      'Consider session persistence requirements'
    ]
  },

  caching: {
    id: 'caching',
    name: 'Caching Pattern',
    category: 'performance',
    description: 'Improves response times and reduces database load',
    detection: {
      required: {
        nodes: [
          { type: 'cache', count: 1 },
          { type: 'service', minCount: 1 }
        ],
        connections: ['service-cache']
      }
    },
    bestPractices: [
      'Implement cache eviction policies',
      'Consider cache coherency',
      'Define appropriate TTL values'
    ]
  },

  apiGateway: {
    id: 'apiGateway',
    name: 'API Gateway Pattern',
    category: 'architecture',
    description: 'Provides a unified entry point for API consumers',
    detection: {
      required: {
        nodes: [
          { type: 'gateway', count: 1 },
          { type: 'service', minCount: 2 }
        ],
        connections: ['gateway-service']
      }
    },
    bestPractices: [
      'Implement authentication/authorization',
      'Include rate limiting',
      'Consider request/response transformation'
    ]
  },

  messageQueue: {
    id: 'messageQueue',
    name: 'Message Queue Pattern',
    category: 'communication',
    description: 'Enables asynchronous communication between services',
    detection: {
      required: {
        nodes: [
          { type: 'queue', count: 1 },
          { type: 'service', minCount: 2 }
        ],
        connections: ['service-queue']
      }
    },
    bestPractices: [
      'Implement dead letter queues',
      'Consider message persistence',
      'Handle retry logic appropriately'
    ]
  },

  circuitBreaker: {
    id: 'circuitBreaker',
    name: 'Circuit Breaker',
    category: 'reliability',
    description: 'Prevents cascading failures in distributed systems',
    detection: {
      required: {
        nodes: [
          { type: 'service', min: 2 }
        ],
        connections: [
          { from: 'service', to: 'service', metadata: { type: 'circuit-breaker' } }
        ]
      }
    },
    bestPractices: [
      'Configure proper timeout thresholds',
      'Implement fallback mechanisms',
      'Monitor circuit breaker status'
    ]
  }
};

class PatternRegistry {
  constructor() {
    this.patterns = {
      loadBalancing: {
        id: 'loadBalancing',
        name: 'Load Balancing',
        category: 'scalability',
        detection: {
          required: {
            nodes: [
              { type: 'loadbalancer', count: 1 },
              { type: 'service', minCount: 2 }
            ],
            connections: ['loadbalancer-service']
          },
          optimal: {
            nodes: [
              { type: 'loadbalancer', count: 2 }, // For high availability
              { type: 'service', minCount: 3 }
            ]
          }
        }
      },
      caching: {
        id: 'caching',
        name: 'Caching',
        category: 'performance',
        detection: {
          required: {
            nodes: [
              { type: 'cache', count: 1 },
              { type: 'service', minCount: 1 }
            ],
            connections: ['service-cache']
          },
          optimal: {
            nodes: [
              { type: 'cache', count: 1 },
              { type: 'service', minCount: 1 }
            ],
            connections: ['client-cache', 'service-cache']
          }
        }
      },
      apiGateway: {
        id: 'apiGateway',
        name: 'API Gateway',
        category: 'architecture',
        detection: {
          required: {
            nodes: [
              { type: 'gateway', count: 1 },
              { type: 'service', minCount: 2 }
            ],
            connections: ['gateway-service']
          },
          optimal: {
            nodes: [
              { type: 'gateway', count: 1 },
              { type: 'service', minCount: 2 },
              { type: 'loadbalancer', count: 1 }
            ],
            connections: ['client-gateway', 'gateway-service', 'gateway-loadbalancer']
          }
        }
      },
      messageQueue: {
        id: 'messageQueue',
        name: 'Message Queue',
        category: 'messaging',
        detection: {
          required: {
            nodes: [
              { type: 'queue', count: 1 },
              { type: 'service', minCount: 2 }
            ],
            connections: ['service-queue']
          },
          optimal: {
            nodes: [
              { type: 'queue', count: 1 },
              { type: 'service', minCount: 2 }
            ],
            metadata: {
              connections: {
                type: 'async'
              }
            }
          }
        }
      },
      microservices: {
        id: 'microservices',
        name: 'Microservices',
        category: 'architecture',
        detection: {
          required: {
            nodes: [
              { type: 'service', minCount: 3 },
              { type: 'database', minCount: 2 }
            ]
          },
          optimal: {
            nodes: [
              { type: 'service', minCount: 3 },
              { type: 'database', minCount: 2 },
              { type: 'gateway', count: 1 },
              { type: 'loadbalancer', minCount: 1 }
            ]
          }
        }
      }
    };
  }

  getPattern(patternId) {
    return this.patterns[patternId];
  }

  getAllPatterns() {
    return Object.values(this.patterns);
  }

  getPatternsByCategory(category) {
    return Object.values(this.patterns)
      .filter(pattern => pattern.category === category);
  }

  detectPatterns(diagram) {
    const detectedPatterns = [];
    
    for (const pattern of Object.values(this.patterns)) {
      const matches = this._findPatternMatches(diagram, pattern.detection);
      if (matches.length > 0) {
        detectedPatterns.push({
          ...pattern,
          matches,
          implementation: this._analyzeImplementationQuality(diagram, pattern, matches)
        });
      }
    }

    return detectedPatterns;
  }

  _matchesPattern(diagram, detection) {
    const { nodes, edges } = diagram;

    // Check required nodes
    if (detection.required.nodes) {
      for (const req of detection.required.nodes) {
        const count = nodes.filter(n => n.type === req.type).length;
        if (req.count && count !== req.count) return false;
        if (req.minCount && count < req.minCount) return false;
      }
    }

    // Check required connections
    if (detection.required.connections) {
      for (const conn of detection.required.connections) {
        const [fromType, toType] = conn.split('-');
        const hasConnection = edges.some(edge => {
          const source = nodes.find(n => n.id === edge.source);
          const target = nodes.find(n => n.id === edge.target);
          return source?.type === fromType && target?.type === toType;
        });
        if (!hasConnection) return false;
      }
    }

    return true;
  }

  _findPatternMatches(diagram, detection) {
    const matches = [];
    const { nodes, edges } = diagram;

    // Find all possible combinations of nodes that match the pattern
    const nodeGroups = this._findMatchingNodeGroups(nodes, detection.required.nodes);

    for (const nodeGroup of nodeGroups) {
      // Check if the connections between these nodes match the pattern
      if (this._validateConnections(nodeGroup, edges, detection.required.connections)) {
        matches.push({
          nodes: nodeGroup,
          edges: this._getRelevantEdges(nodeGroup, edges)
        });
      }
    }

    return matches;
  }

  _findMatchingNodeGroups(nodes, requirements) {
    if (!requirements) return [nodes];

    const groups = [];
    const typeGroups = {};

    // Group nodes by type
    for (const node of nodes) {
      if (!typeGroups[node.type]) {
        typeGroups[node.type] = [];
      }
      typeGroups[node.type].push(node);
    }

    // Validate type requirements
    for (const req of requirements) {
      const typeNodes = typeGroups[req.type] || [];
      if (req.count && typeNodes.length !== req.count) return [];
      if (req.minCount && typeNodes.length < req.minCount) return [];
    }

    // For simple cases, return all matching nodes
    const matchingNodes = nodes.filter(node => 
      requirements.some(req => req.type === node.type)
    );

    return [matchingNodes];
  }

  _validateConnections(nodes, edges, requiredConnections) {
    if (!requiredConnections) return true;

    for (const conn of requiredConnections) {
      const [fromType, toType] = conn.split('-');
      const hasConnection = edges.some(edge => {
        const source = nodes.find(n => n.id === edge.source);
        const target = nodes.find(n => n.id === edge.target);
        return source?.type === fromType && target?.type === toType;
      });
      if (!hasConnection) return false;
    }

    return true;
  }

  _getRelevantEdges(nodes, edges) {
    const nodeIds = new Set(nodes.map(n => n.id));
    return edges.filter(edge => 
      nodeIds.has(edge.source) && nodeIds.has(edge.target)
    );
  }

  _analyzeImplementationQuality(diagram, pattern, matches) {
    const quality = {
      score: 0,
      optimal: false,
      missingOptimal: [],
      suggestions: []
    };

    if (!pattern.detection.optimal) {
      quality.score = 1;
      quality.optimal = true;
      return quality;
    }

    const { nodes, edges } = diagram;
    const optimal = pattern.detection.optimal;

    // Check optimal nodes
    if (optimal.nodes) {
      for (const req of optimal.nodes) {
        const count = nodes.filter(n => n.type === req.type).length;
        if (req.count && count !== req.count) {
          quality.missingOptimal.push(`Need ${req.count} ${req.type} nodes, found ${count}`);
        }
        if (req.minCount && count < req.minCount) {
          quality.missingOptimal.push(`Need at least ${req.minCount} ${req.type} nodes, found ${count}`);
        }
      }
    }

    // Check optimal connections
    if (optimal.connections) {
      for (const conn of optimal.connections) {
        const [fromType, toType] = conn.split('-');
        const hasConnection = edges.some(edge => {
          const source = nodes.find(n => n.id === edge.source);
          const target = nodes.find(n => n.id === edge.target);
          return source?.type === fromType && target?.type === toType;
        });
        if (!hasConnection) {
          quality.missingOptimal.push(`Missing optimal connection from ${fromType} to ${toType}`);
        }
      }
    }

    // Check metadata requirements
    if (optimal.metadata) {
      this._matchesMetadata(edges, optimal.metadata);
    }

    // Calculate quality score
    quality.score = 1 - (quality.missingOptimal.length / (optimal.nodes?.length || 1));
    quality.optimal = quality.missingOptimal.length === 0;

    return quality;
  }

  _matchesMetadata(edges, requiredMetadata) {
    if (!requiredMetadata.connections) return true;

    return edges.every(edge => {
      for (const [key, value] of Object.entries(requiredMetadata.connections)) {
        if (edge.data?.[key] !== value) return false;
      }
      return true;
    });
  }
}

module.exports = PatternRegistry;


================================================================================
# FILE: server\services\diagram\patterns\PatternTemplates.js
# EXTENSION: .js
================================================================================
const { nodePresets } = require('../NodeTypes/nodePresets');

const patternTemplates = {
  loadBalancing: {
    name: 'Load Balancing Pattern',
    required: {
      nodes: ['loadBalancer', 'service'],
      minServices: 2
    },
    optimal: {
      redundancy: true,
      healthChecks: true
    }
  },

  caching: {
    name: 'Caching Pattern',
    required: {
      nodes: ['cache', 'service']
    },
    optimal: {
      evictionPolicy: true,
      monitoring: true
    }
  },

  messageQueue: {
    name: 'Message Queue Pattern',
    required: {
      nodes: ['queue', 'service']
    },
    optimal: {
      deadLetterQueue: true,
      errorHandling: true
    }
  },

  apiGateway: {
    name: 'API Gateway Pattern',
    required: {
      nodes: ['gateway', 'service']
    },
    optimal: {
      authentication: true,
      rateLimiting: true,
      routing: true
    }
  }
};

module.exports = {
  patternTemplates
};



================================================================================
# FILE: server\services\diagram\templates.js
# EXTENSION: .js
================================================================================
const templates = {
  system: {
    basic: {
      name: 'Basic Web App',
      nodes: [
        {
          id: 'client',
          type: 'client',
          position: { x: 100, y: 100 },
          data: { label: 'Client' }
        },
        {
          id: 'server',
          type: 'service',
          position: { x: 400, y: 100 },
          data: { label: 'Server' }
        },
        {
          id: 'db',
          type: 'database',
          position: { x: 700, y: 100 },
          data: { label: 'Database' }
        }
      ],
      edges: [
        {
          id: 'client-server',
          source: 'client',
          target: 'server',
          type: 'default',
          animated: true
        },
        {
          id: 'server-db',
          source: 'server',
          target: 'db',
          type: 'default',
          animated: true
        }
      ]
    },
    microservices: {
      name: 'Microservices',
      nodes: [
        {
          id: 'lb',
          type: 'loadBalancer',
          position: { x: 250, y: 50 },
          data: { label: 'Load Balancer' }
        },
        {
          id: 'auth',
          type: 'service',
          position: { x: 100, y: 200 },
          data: { label: 'Auth Service' }
        },
        {
          id: 'api',
          type: 'service',
          position: { x: 400, y: 200 },
          data: { label: 'API Gateway' }
        },
        {
          id: 'cache',
          type: 'cache',
          position: { x: 250, y: 350 },
          data: { label: 'Cache' }
        }
      ],
      edges: [
        // Add appropriate edges
      ]
    },
    distributed: {
      name: 'Distributed System',
      nodes: [
        {
          id: 'cdn',
          type: 'client',
          position: { x: 100, y: 50 },
          data: { label: 'CDN' }
        },
        {
          id: 'queue',
          type: 'queue',
          position: { x: 400, y: 200 },
          data: { label: 'Message Queue' }
        }
        // Add more nodes
      ],
      edges: []
    }
  },
  sequence: {
    auth: {
      name: 'Authentication Flow',
      actors: ['Client', 'Auth Service', 'Database'],
      messages: [
        { from: 'Client', to: 'Auth Service', text: 'Login Request' },
        { from: 'Auth Service', to: 'Database', text: 'Verify Credentials' },
        { from: 'Database', to: 'Auth Service', text: 'User Data' },
        { from: 'Auth Service', to: 'Client', text: 'JWT Token' }
      ]
    },
    // Add more sequence diagram templates
  }
};

module.exports = templates;


================================================================================
# FILE: server\services\diagram\utils\complexityCalculator.js
# EXTENSION: .js
================================================================================
/**
 * Calculates complexity metrics for a diagram
 * @param {Array} nodes - Array of diagram nodes
 * @param {Array} edges - Array of diagram edges
 * @returns {Object} Complexity metrics
 */
function calculateComplexity(nodes, edges) {
  const metrics = {
    nodeCount: nodes.length,
    edgeCount: edges.length,
    density: 0,
    avgConnections: 0,
    maxDepth: 0,
    complexity: 0
  };

  // Calculate density (ratio of actual to possible connections)
  const possibleConnections = nodes.length * (nodes.length - 1) / 2;
  metrics.density = possibleConnections > 0 ? edges.length / possibleConnections : 0;

  // Calculate average connections per node
  metrics.avgConnections = nodes.length > 0 ? edges.length / nodes.length : 0;

  // Calculate max depth (longest path from any root node)
  metrics.maxDepth = calculateMaxDepth(nodes, edges);

  // Calculate overall complexity score
  metrics.complexity = calculateComplexityScore(metrics);

  return metrics;
}

/**
 * Calculates the maximum depth of the diagram
 * @param {Array} nodes 
 * @param {Array} edges 
 * @returns {number}
 */
function calculateMaxDepth(nodes, edges) {
  const adjacencyList = buildAdjacencyList(nodes, edges);
  let maxDepth = 0;

  nodes.forEach(node => {
    const depth = findLongestPath(node.id, adjacencyList, new Set());
    maxDepth = Math.max(maxDepth, depth);
  });

  return maxDepth;
}

/**
 * Builds an adjacency list representation of the diagram
 * @param {Array} nodes 
 * @param {Array} edges 
 * @returns {Object}
 */
function buildAdjacencyList(nodes, edges) {
  const adjacencyList = {};
  
  // Initialize adjacency list for all nodes
  nodes.forEach(node => {
    adjacencyList[node.id] = [];
  });

  // Add edges to adjacency list
  edges.forEach(edge => {
    if (adjacencyList[edge.source]) {
      adjacencyList[edge.source].push(edge.target);
    }
  });

  return adjacencyList;
}

/**
 * Finds the longest path from a starting node
 * @param {string} nodeId 
 * @param {Object} adjacencyList 
 * @param {Set} visited 
 * @returns {number}
 */
function findLongestPath(nodeId, adjacencyList, visited) {
  if (visited.has(nodeId)) return 0;
  visited.add(nodeId);

  let maxChildDepth = 0;
  const neighbors = adjacencyList[nodeId] || [];

  neighbors.forEach(neighbor => {
    const childDepth = findLongestPath(neighbor, adjacencyList, new Set(visited));
    maxChildDepth = Math.max(maxChildDepth, childDepth);
  });

  return maxChildDepth + 1;
}

/**
 * Calculates overall complexity score
 * @param {Object} metrics 
 * @returns {number}
 */
function calculateComplexityScore(metrics) {
  const weights = {
    nodeCount: 0.3,
    edgeCount: 0.3,
    density: 0.2,
    maxDepth: 0.2
  };

  return (
    (metrics.nodeCount * weights.nodeCount) +
    (metrics.edgeCount * weights.edgeCount) +
    (metrics.density * weights.density) +
    (metrics.maxDepth * weights.maxDepth)
  );
}

module.exports = {
  calculateComplexity
};


================================================================================
# FILE: server\services\engines\baseEngine.js
# EXTENSION: .js
================================================================================
// server/services/engines/baseEngine.js
const AIFactory = require('../ai/aiFactory');
const aiConfig = require('../../config/aiConfig');

class BaseEngine {
  constructor(engineConfig = {}) {
    this.provider = engineConfig.provider || aiConfig.defaultProvider;
    console.log(' Creating AI service for engine with provider:', this.provider);
    console.log(' Config available:', !!aiConfig[this.provider], aiConfig[this.provider]);
    try {
      this.aiService = AIFactory.createService(this.provider, aiConfig[this.provider]);
      console.log(' AI Service created:', !!this.aiService);
    } catch (error) {
      console.error('ERROR creating AI service:', error);
      throw new Error(`Failed to create AI service: ${error.message}`);
    }
    this.config = engineConfig;
  }
  
  async processMessage(sessionId, message, options = {}) {
    throw new Error('processMessage must be implemented by subclasses');
  }
  
  async startSession(userId, contentId, options = {}) {
    throw new Error('startSession must be implemented by subclasses');
  }
  
  async generateContent(sessionId, contentType, options = {}) {
    throw new Error('generateContent must be implemented by subclasses');
  }
}

module.exports = BaseEngine;



================================================================================
# FILE: server\services\engines\coachEngine.js
# EXTENSION: .js
================================================================================
// server/services/engines/coachEngine.js
const BaseEngine = require('./baseEngine');
const Interview = require('../../models/Interview');
const Problem = require('../../models/Problem');
const knowledgeService = require('../knowledge/knowledgeService');
const PersonaService = require('./PersonaService');
const path = require('path');

const coachPersona = require(path.join(__dirname, '../../../data/persona/coachPersona'));
const problems = require(path.join(__dirname, '../../../data/problems'));

const sessions = {};

class CoachEngine extends BaseEngine {
  constructor(config = {}) {
    super(config);
    // Stages can be passed dynamically or left empty
    this.stages = config.stages || [];
  }
  
  async processMessage(sessionId, message, options = {}) {
    try {
      console.log(' Processing message:', {
        sessionId,
        messageLength: message.length,
        options: JSON.stringify(options)
      });

      // Get problem context from persona
      const persona = require('../../data/persona/coachPersona');
      const problemConfig = persona.problems[sessionId];
      
      // Handle new user greeting
      if (message.toLowerCase().includes('new here')) {
        return {
          role: 'coach',
          content: `I understand you're new here! ${problemConfig?.description || 'This is a system design coaching session'}. I'll guide you through the process step by step. Let's start with understanding the basic requirements. What do you think should be the core features of our parking lot system?`,
          timestamp: new Date().toISOString()
        };
      }

      // Validate inputs
      if (!sessionId || !message) {
        console.error("Missing required parameters: sessionId or message");
        return {
          role: 'coach',
          content: "I need more information to help you. Could you try again?",
          timestamp: new Date().toISOString()
        };
      }
      
      // Retrieve or create session
      let session = await Interview.findOne({ id: sessionId });
      if (!session) {
        session = sessions[sessionId] || { id: sessionId, conversation: [] };
        sessions[sessionId] = session;
      }
      
      // Append user message to conversation history
      session.conversation.push({
        role: 'user',
        content: message,
        timestamp: new Date().toISOString()
      });
      
      // Retrieve dynamic data from options
      const workbookContent = options.workbookContent || {};
      const currentSection = options.currentSection || '';
      const userLevel = options.userLevel || '';
      const currentPage = options.currentPage || '';
      
      // Get problem context dynamically from the database
      let problemContext = '';
      try {
        const problem = await Problem.findOne({ id: session.problemId });
        problemContext = problem
          ? `Project: ${problem.title}\nDescription: ${problem.description || ''}\nAdditional Info: ${problem.additionalInfo || ''}`
          : '';
      } catch (problemError) {
        console.warn("Error fetching problem:", problemError);
      }
      
      // Merge dynamic parts from Persona, problem, workbook, etc.
      const dynamicParts = [];
      
      // Try to get PersonaService system prompt
      try {
        const personaPrompt = PersonaService.getSystemPrompt({
          currentPage: options.currentPage,
          designData: { workbookContent, currentSection }
        });
        dynamicParts.push(personaPrompt);
      } catch (personaError) {
        console.warn("Error getting persona prompt:", personaError);
        dynamicParts.push("You are a System Design Coach helping with system architecture design.");
      }
      
      // Add other context parts
      if (problemContext) dynamicParts.push(problemContext);
      if (currentSection) dynamicParts.push(`Current Section: ${currentSection}`);
      if (Object.keys(workbookContent).length) dynamicParts.push(`Workbook Data: ${JSON.stringify(workbookContent)}`);
      if (userLevel) dynamicParts.push(`User Level: ${userLevel}`);

      const systemPrompt = dynamicParts.filter(Boolean).join("\n\n");
      
      // Debug: Log the final system prompt
      console.log("Final system prompt for processMessage:", systemPrompt);
      
      // Prepare conversation history for AI call
      const messagesForAI = session.conversation.map(msg => ({
        role: msg.role === 'coach' ? 'assistant' : msg.role,
        content: msg.content
      }));
      
      // Log conversation state
      console.log(' Conversation state:', {
        historyLength: session.conversation.length,
        lastMessages: session.conversation.slice(-2)
      });

      // Log AI call
      console.log(' Calling AI with:', {
        messagesCount: messagesForAI.length,
        systemPromptLength: systemPrompt.length
      });

      // Call the AI service with dynamic prompt and full conversation history
      const aiResponse = await this.aiService.sendMessage(messagesForAI, {
        system: systemPrompt,
        systemPrompt: systemPrompt,
        temperature: options.temperature || 0.7,
        conciseMode: options.conciseMode
      });

      console.log(' AI Response received:', {
        length: aiResponse.length,
        preview: aiResponse.substring(0, 100)
      });

      const responseMsg = {
        role: 'coach',
        content: aiResponse,
        timestamp: new Date().toISOString()
      };
      session.conversation.push(responseMsg);
      
      if (session.save) {
        await session.save();
      }
      
      return responseMsg;
    } catch (error) {
      console.error('Error processing coaching message:', error);
      return {
        role: 'coach',
        content: "I'm experiencing some technical difficulties processing your request. Please try again in a moment.",
        timestamp: new Date().toISOString(),
        error: true
      };
    }
  }
  
  async startSession(userId, problemId, options = {}) {
    try {
      const problem = problems.find(p => p.id === problemId);
      if (!problem) {
        throw new Error('Problem not found');
      }

      const persona = coachPersona.problems[problemId];
      if (!persona) {
        throw new Error('Persona configuration not found for problem');
      }

      // Build dynamic problem context
      const problemContext = [
        `Project: ${problem.title}`,
        `Description: ${problem.description || ''}`,
        `Additional Info: ${problem.additionalInfo || ''}`
      ].filter(Boolean).join("\n");
      
      // Retrieve extra background info dynamically (if available)
      const contextInfo = await knowledgeService.queryKnowledge(
        `System design concepts for ${problem.title}`,
        options.knowledgeSource || ''
      );
      
      const dynamicParts = [
        PersonaService.getSystemPrompt({ currentPage: 'coach', designData: { project: problem.title } }),
        problemContext,
        contextInfo,
        options.userLevel ? `User Level: ${options.userLevel}` : ''
      ];
      let systemPrompt = dynamicParts.filter(Boolean).join("\n\n");
      
      // Append an instruction to begin the session
      systemPrompt += `\n\nBegin with an introduction to the project and initial guidance.`;
      
      console.log("Final system prompt for startSession:", systemPrompt);
      
      // Call the AI service for an initial response
      const initialResponse = await this.aiService.sendMessage(
        [{ role: 'user', content: `I need help designing a system for: ${problem.title}.` }],
        {
          system: systemPrompt,
          systemPrompt: systemPrompt,
          temperature: options.temperature || 0.7
        }
      );
      
      const session = new Interview({
        userId,
        problemId,
        status: 'in_progress',
        currentStage: 'introduction',
        type: 'coaching',
        conversation: [{
          role: 'coach',
          content: initialResponse,
          timestamp: new Date().toISOString()
        }]
      });
      
      await session.save();
      return session;
    } catch (error) {
      console.error('Coaching session start error:', error);
      throw error;
    }
  }
  
  async generateContent(sessionId, topic, options = {}) {
    try {
      const session = await Interview.findOne({ id: sessionId });
      if (!session) throw new Error('Coaching session not found');
      const problem = await Problem.findOne({ id: session.problemId });
      
      const topicKnowledge = await knowledgeService.queryKnowledge(
        `${topic} ${session.problemId}`,
        options.knowledgeSource || ''
      );
      
      const dynamicParts = [
        `You are an educational content creator specializing in system design.`,
        `Generate detailed learning materials about "${topic}" related to project ${problem ? problem.title : ''}.`,
        `Reference: ${topicKnowledge}`
      ];
      
      let systemPrompt = dynamicParts.filter(Boolean).join("\n\n");
      
      if (options.conciseMode !== false) {
        systemPrompt += `\n\nProvide a concise narrative that includes project context.`;
      }
      
      const prompt = `I'd like to learn more about ${topic} for my system design project.`;
      const content = await this.aiService.generateContent(prompt, { 
        system: systemPrompt,
        systemPrompt: systemPrompt,
        temperature: options.temperature || 0.5
      });
      
      return { topic, content, title: `Learning Materials: ${topic}` };
    } catch (error) {
      console.error('Generate learning materials error:', error);
      return {
        topic,
        title: `Learning Materials: ${topic}`,
        content: "Sorry, I'm having trouble generating learning materials at the moment. Please try again later."
      };
    }
  }
  
  async generateDiagram(sessionId, diagramType, options = {}) {
    try {
      const session = await Interview.findOne({ id: sessionId });
      if (!session) throw new Error('Coaching session not found');
      
      const problem = await Problem.findOne({ id: session.problemId });
      
      // Create a diagram prompt based on context
      const dynamicParts = [
        `You are a diagram generator for system design.`,
        `Create a ${diagramType} diagram for project: ${problem ? problem.title : 'system design'}.`,
        `Use mermaid syntax. Follow these guidelines:`,
        `- Keep the diagram simple and clear`,
        `- Focus on main components and relationships`,
        `- Use proper node types for each component`,
        `- Include all important connections`
      ];
      
      let systemPrompt = dynamicParts.filter(Boolean).join("\n\n");
      
      // Get diagram context
      const diagramPrompt = `Based on our conversation so far, create a ${diagramType} diagram for my system design.`;
      
      const diagramCode = await this.aiService.generateContent(diagramPrompt, {
        system: systemPrompt,
        systemPrompt: systemPrompt,
        temperature: 0.2  // Lower temperature for more consistent diagrams
      });
      
      // Extract mermaid code
      const mermaidPattern = /```mermaid\s*([\s\S]*?)\s*```/;
      const matches = diagramCode.match(mermaidPattern);
      const mermaidCode = matches ? matches[1].trim() : '';
      
      return {
        type: diagramType,
        mermaidCode: mermaidCode || this._getFallbackDiagram(diagramType),
        description: `${diagramType} diagram for ${problem ? problem.title : 'system design'}`
      };
    } catch (error) {
      console.error('Generate diagram error:', error);
      return {
        type: diagramType,
        mermaidCode: this._getFallbackDiagram(diagramType),
        description: 'Fallback diagram (error during generation)'
      };
    }
  }
  
  _getFallbackDiagram(type) {
    if (type === 'sequence') {
      return 'sequenceDiagram\n  Client->>API: Request\n  API->>Service: Process\n  Service->>Database: Query\n  Database-->>Service: Result\n  Service-->>API: Response\n  API-->>Client: Result';
    } else if (type === 'er') {
      return 'erDiagram\n  USER ||--o{ ORDER : places\n  ORDER ||--|{ LINE_ITEM : contains';
    } else {
      return 'graph TD\n  Client[Client] --> API[API Gateway]\n  API --> Service[Service]\n  Service --> DB[(Database)]';
    }
  }
  
  async evaluateDesign(sessionId, options = {}) {
    try {
      const session = await Interview.findOne({ id: sessionId });
      if (!session) throw new Error('Coaching session not found');
      
      const problem = await Problem.findOne({ id: session.problemId });
      
      // Create evaluation prompt
      const dynamicParts = [
        `You are a system design evaluator.`,
        `Evaluate the design for project: ${problem ? problem.title : 'system design'}.`,
        `Focus on these aspects:`,
        `- Requirements fulfillment`,
        `- Architecture quality`,
        `- Scalability approach`,
        `- Data model design`,
        `- Security considerations`
      ];
      
      let systemPrompt = dynamicParts.filter(Boolean).join("\n\n");
      
      // Get conversation context
      const conversationText = session.conversation
        .map(msg => `${msg.role.toUpperCase()}: ${msg.content}`)
        .join('\n\n');
      
      const evaluationPrompt = `Please evaluate this system design discussion and provide feedback:
      
      ${conversationText}`;
      
      const evaluation = await this.aiService.generateContent(evaluationPrompt, {
        system: systemPrompt,
        systemPrompt: systemPrompt,
        temperature: 0.3  // Lower temperature for consistent evaluation
      });
      
      return {
        evaluation,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('Evaluation error:', error);
      return {
        evaluation: "Unable to generate evaluation at this time.",
        timestamp: new Date().toISOString()
      };
    }
  }
}

module.exports = new CoachEngine({
  provider: 'claude', // Default provider
  stages: [
    'introduction',
    'requirements',
    'architecture',
    'data-modeling',
    'scaling',
    'evaluation'
  ]
});


================================================================================
# FILE: server\services\engines\coachingEngine.js
# EXTENSION: .js
================================================================================
const PersonaManager = require('../persona/PersonaManager');
const WorkbookService = require('../workbook/WorkbookService');
const AIService = require('../ai/AIService');
const logger = require('../../utils/logger');

class CoachingEngine {
  constructor() {
    this.personaManager = PersonaManager;
    this.workbookService = WorkbookService;
    this.ai = new AIService();
    this.sessions = new Map();
  }

  async initialize() {
    await this.personaManager.initialize();
    await this.ai.initialize();
    logger.info('CoachingEngine initialized');
  }

  async startSession(userId, problemId) {
    try {
      const workbook = await this.workbookService.createWorkbook(userId, problemId);
      const sessionContext = {
        workbookId: workbook._id,
        currentStage: 'requirements',
        persona: 'coach',
        history: []
      };
      
      this.sessions.set(workbook.sessionId, sessionContext);
      return workbook.sessionId;
    } catch (error) {
      logger.error('Failed to start coaching session:', error);
      throw error;
    }
  }

  async processMessage(sessionId, message) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }

    try {
      const workbook = await this.workbookService.getWorkbook(session.workbookId);
      const persona = this.personaManager.setActivePersona(session.persona);
      
      const context = {
        stage: session.currentStage,
        workbookState: workbook.sections[session.currentStage],
        history: session.history
      };

      const response = await this.ai.generateResponse(message, {
        persona: persona.getPrompt(context),
        context: this.personaManager.getPersonaContext(session.persona, context)
      });

      // Update session history
      session.history.push({ role: 'user', content: message });
      session.history.push({ role: 'assistant', content: response });

      // Update workbook if needed
      if (response.workbookUpdates) {
        await this.workbookService.updateSection(
          workbook._id,
          session.currentStage,
          response.workbookUpdates
        );
      }

      return response;
    } catch (error) {
      logger.error('Error processing message:', error);
      throw error;
    }
  }

  async switchPersona(sessionId, newPersona) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }

    session.persona = newPersona;
    session.history = []; // Clear history when switching personas
    return true;
  }
}

module.exports = new CoachingEngine();



================================================================================
# FILE: server\services\engines\graderEngine.js
# EXTENSION: .js
================================================================================
// server/services/engines/graderEngine.js
const BaseEngine = require('./baseEngine');
const Interview = require('../../models/Interview');
const Problem = require('../../models/Problem');
const Evaluation = require('../../models/Evaluation');
const fs = require('fs');
const path = require('path');

class GraderEngine extends BaseEngine {
  constructor(config = {}) {
    super(config);
    this.name = 'grader';
    
    // Try to load grader prompt from file
    try {
      const graderPromptPath = path.join(__dirname, '../../data/persona/grader.js');
      if (fs.existsSync(graderPromptPath)) {
        this.graderPrompt = require(graderPromptPath);
      } else {
        console.log('Grader prompt file not found, using default prompt');
        this.graderPrompt = this._getDefaultGraderPrompt;
      }
    } catch (error) {
      console.error('Error loading grader prompt:', error);
      this.graderPrompt = this._getDefaultGraderPrompt;
    }
  }
  
  /**
   * Evaluate a workbook submission
   * @param {string} sessionId - The session ID
   * @param {object} workbookContent - The content of the workbook
   * @param {object} options - Additional options
   * @returns {object} Evaluation results
   */
  async evaluateWorkbook(sessionId, workbookContent, options = {}) {
    try {
      // Find the session
      const session = await Interview.findById(sessionId).populate('problemId');
      
      if (!session) {
        throw new Error(`Session not found: ${sessionId}`);
      }
      
      // Extract problem and user information
      const problem = session.problemId;
      const userLevel = options.userLevel || 'mid-level';
      
      // Get system prompt for grader
      const systemPrompt = this._buildGraderPrompt({
        userLevel,
        problemId: problem?.id,
        evaluationType: session.type || 'coaching',
        conciseMode: options.conciseMode !== false // Default to concise mode
      });

      // Create prompt for evaluation
      const prompt = `Evaluate this system design for ${problem?.title || 'the given problem'}:

${JSON.stringify(workbookContent, null, 2)}

Provide a concise, focused evaluation following the framework in your instructions.`;

      // Generate evaluation using AI service
      const evaluationContent = await this.aiService.sendMessage([
        { role: 'system', content: systemPrompt },
        { role: 'user', content: prompt }
      ], { 
        temperature: 0.3 // Lower temperature for more consistent evaluations
      });

      // Parse scores and create evaluation record
      const scores = this._extractScores(evaluationContent);
      
      // Create or update evaluation record
      let evaluation = await Evaluation.findOne({ sessionId });
      
      if (!evaluation) {
        evaluation = new Evaluation({
          sessionId,
          evaluationType: session.type === 'interview' ? 'interview' : 'coaching',
          userLevel,
          problemId: problem?.id,
          content: evaluationContent,
          scores,
          timestamp: new Date()
        });
      } else {
        evaluation.content = evaluationContent;
        evaluation.scores = scores;
        evaluation.userLevel = userLevel;
        evaluation.timestamp = new Date();
      }
      
      await evaluation.save();
      
      return {
        evaluation: evaluationContent,
        scores
      };
    } catch (error) {
      console.error('Error in evaluateWorkbook:', error);
      throw error;
    }
  }

  /**
   * Extract numerical scores from evaluation text
   * @private
   * @param {string} evaluationText - The evaluation text to parse
   * @returns {object} Extracted scores
   */
  _extractScores(evaluationText) {
    const scores = {};
    const scorePattern = /([A-Za-z\s&]+)\s*\((\d+)\/(\d+)\)/g;
    let match;
    
    while ((match = scorePattern.exec(evaluationText)) !== null) {
      const category = match[1].trim();
      const score = parseInt(match[2], 10);
      const maxScore = parseInt(match[3], 10);
      scores[category] = { score, maxScore };
    }
    
    // Extract overall score if present
    const overallMatch = /Overall Score:\s*(\d+)\/(\d+)/i.exec(evaluationText);
    if (overallMatch) {
      scores.overall = { 
        score: parseInt(overallMatch[1], 10), 
        maxScore: parseInt(overallMatch[2], 10) 
      };
    }
    
    return scores;
  }
  
  /**
   * Provide final assessment for an interview
   * @param {string} interviewId - The interview ID
   * @param {object} options - Additional options
   * @returns {object} Assessment results
   */
  async provideFinalAssessment(interviewId, options = {}) {
    try {
      const interview = await Interview.findById(interviewId).populate('problemId');
      
      if (!interview) {
        throw new Error(`Interview not found: ${interviewId}`);
      }
      
      // Extract necessary information
      const userLevel = options.userLevel || 'mid-level';
      const conversationText = interview.conversation
        .map(msg => `${msg.role.toUpperCase()}: ${msg.content}`)
        .join('\n\n');
      
      // Build grader system prompt
      const systemPrompt = this._buildGraderPrompt({
        userLevel,
        problemId: interview.problemId?.id,
        evaluationType: 'interview',
        isFinal: true,
        conciseMode: options.conciseMode !== false // Default to concise mode
      });
      
      const prompt = `Provide a comprehensive assessment of this completed system design interview for ${interview.problemId?.title || 'a system design problem'}.

Interview conversation:
${conversationText}

Focus on evaluating their system design skills based on this interview.`;
      
      const assessment = await this.aiService.sendMessage([
        { role: 'system', content: systemPrompt },
        { role: 'user', content: prompt }
      ], { temperature: 0.3 });
      
      // Parse and store evaluation
      const scores = this._extractScores(assessment);
      
      // Create evaluation record
      const evaluation = new Evaluation({
        sessionId: interviewId,
        evaluationType: 'interview',
        userLevel,
        problemId: interview.problemId?.id,
        content: assessment,
        scores,
        timestamp: new Date(),
        isFinal: true
      });
      
      await evaluation.save();
      
      return {
        assessment,
        scores
      };
    } catch (error) {
      console.error('Error in provideFinalAssessment:', error);
      throw error;
    }
  }
  
  /**
   * Build the grader prompt with the appropriate context
   * @private
   * @param {object} context - Context for the prompt
   * @returns {string} The formatted grader prompt
   */
  _buildGraderPrompt(context) {
    // If we have a grader prompt function, use it
    if (typeof this.graderPrompt === 'function') {
      return this.graderPrompt(context);
    }
    
    // Otherwise use the default
    return this._getDefaultGraderPrompt(context);
  }
  
  /**
   * Get the default grader prompt
   * @private
   * @param {object} context - Context for the prompt
   * @returns {string} Default grader prompt
   */
  _getDefaultGraderPrompt(context = {}) {
    const { userLevel = 'mid-level', evaluationType = 'coaching', isFinal = false, conciseMode = true } = context;
    
    let prompt = `# SYSTEM DESIGN GRADER PERSONA

## ROLE DEFINITION
You are a System Design Grader responsible for objectively evaluating system design solutions. You provide structured, comprehensive feedback based on established criteria while maintaining a neutral, analytical tone.

## USER EXPERIENCE LEVEL ASSESSMENT
The user has identified themselves as: ${userLevel}
Tailor your expectations and feedback depth according to this level.

## EVALUATION FRAMEWORK
Assess designs across these key dimensions (100 points total):
1. Requirements Analysis (0-15 points)
2. System Interface Design (0-10 points)
3. Capacity Estimation (0-10 points)
4. Data Modeling (0-15 points)
5. High-Level Architecture (0-15 points)
6. Detailed Component Design (0-15 points)
7. Scalability & Performance (0-10 points)
8. Reliability & Fault Tolerance (0-10 points)

## FEEDBACK FORMAT
1. Summary Assessment
   - User's experience level
   - Overall score
   - 1-2 sentence summary of strongest and weakest areas

2. Dimensional Breakdown
   - Score for each dimension
   - 1-2 bullet points for strengths
   - 1-2 bullet points for improvements

3. Prioritized Improvement Plan
   - 3 highest priority improvements ranked by importance
   - One-sentence explanation for each

## SCORING GUIDELINES BY LEVEL`;

    // Add level-specific guidelines
    if (userLevel === 'junior') {
      prompt += `
- Junior Level: 60-70 points meets expectations
- Key focus: Functional correctness, basic component understanding`;
    } else if (userLevel === 'mid-level') {
      prompt += `
- Mid-Level: 70-80 points meets expectations
- Key focus: Scalability, component interactions, basic trade-offs`;
    } else if (userLevel === 'senior') {
      prompt += `
- Senior Level: 80-90 points meets expectations
- Key focus: Comprehensive design, performance optimization, fault tolerance`;
    } else {
      prompt += `
- Staff+: 90-100 points meets expectations
- Key focus: System-wide optimization, elegant design patterns, forward-thinking architecture`;
    }

    // Add concise mode instructions
    if (conciseMode) {
      prompt += `

## COMMUNICATION STYLE
Be direct and focused in your evaluation:
- Use short paragraphs (2-3 sentences maximum)
- Prefer bullet points for feedback items
- Avoid explaining basic concepts
- Focus on actionable insights rather than theory
- Eliminate filler words and redundant phrases
- Format scores consistently and clearly
- Make improvement suggestions specific and concrete`;
    }

    // Add any evaluation-type specific instructions
    if (evaluationType === 'interview' && isFinal) {
      prompt += `

## INTERVIEW ASSESSMENT FOCUS
When evaluating an interview:
- Consider the candidate's thought process
- Assess how they handled probing questions
- Evaluate their communication clarity
- Consider their ability to defend design choices
- Note how they handled feedback during the interview`;
    }
    
    return prompt;
  }
}

module.exports = new GraderEngine();


================================================================================
# FILE: server\services\engines\interviewEngine.js
# EXTENSION: .js
================================================================================
// server/services/engines/interviewEngine.js
const BaseEngine = require('./baseEngine');
const Interview = require('../../models/Interview');
const Problem = require('../../models/Problem');
const diagramUtils = require('../utils/diagramUtils');
const knowledgeService = require('../knowledge/knowledgeService');

const sessions = {};

class InterviewEngine extends BaseEngine {
  constructor(config = {}) {
    super(config);
    this.evaluationThreshold = config.evaluationThreshold || 0.8;
    this.diagramStageThreshold = config.diagramStageThreshold || 2;
  }
  
  async startInterview(userId, problemId, options = {}) {
    try {
      const problem = await Problem.findOne({ id: problemId });
      if (!problem) throw new Error('Problem not found');
      
      console.log(`Starting interview for user ${userId} with problem ${problemId}`);
      
      const context = await knowledgeService.queryKnowledge(`System design interview for ${problem.title}`, options.knowledgeSource || 'facebook');
      
      let systemPrompt = options.systemPrompt || `You are an expert system design interviewer.
Use the following context:
${context}
Guide the candidate through designing ${problem.title}. Ask probing questions and challenge assumptions.`;

      // Add concise mode instructions if enabled
      if (options.conciseMode !== false) { // Default to concise mode
        systemPrompt += `\n\nUse a CONCISE communication style:
- Ask focused questions with clear intent
- Keep follow-ups brief and targeted
- Use short paragraphs (2-3 sentences maximum)
- Prioritize probing questions over explanations
- Eliminate unnecessary preambles`;
      }

      systemPrompt += `\n\nBegin with a brief introduction.`;

      const initialResponse = await this.aiService.sendMessage([], {
        system: systemPrompt,
        temperature: options.temperature || 0.7
      });
      
      const interview = new Interview({
        userId,
        problemId,
        status: 'in_progress',
        currentStage: 'introduction',
        type: 'interview',
        startedAt: new Date(),
        timeLimit: problem.timeLimit || 45,
        conversation: [{
          role: 'interviewer',
          content: initialResponse || `Welcome to your system design interview. Today I'd like you to design ${problem.title}. We have about 45 minutes for this discussion. Could you start by telling me how you understand this problem and what key requirements we should consider?`,
          stage: 'introduction',
          timestamp: new Date().toISOString()
        }]
      });
      
      await interview.save();
      console.log(`Interview created with ID: ${interview._id}`);
      return interview;
    } catch (error) {
      console.error('Interview session start error:', error);
      throw error;
    }
  }
  
  async generateContent(sessionId, contentType, options = {}) {
    try {
      const interview = await Interview.findById(sessionId);
      if (!interview) throw new Error('Interview session not found');
      
      const problem = await Problem.findOne({ id: interview.problemId });
      const prompt = `Provide detailed feedback for the interview on ${problem.title}.`;
      
      let systemPrompt = "You are an experienced interviewer providing detailed feedback.";
      
      // Add concise mode if enabled
      if (options.conciseMode !== false) {
        systemPrompt += `\n\nUse a CONCISE communication style:
- Focus on key observations
- Use bullet points for strengths and weaknesses
- Keep paragraphs short (2-3 sentences)
- Prioritize actionable feedback over general advice`;
      }
      
      const content = await this.aiService.generateContent(prompt, {
        system: systemPrompt,
        temperature: options.temperature || 0.6
      });
      
      return { type: 'feedback', content };
    } catch (error) {
      console.error('Generate content error in InterviewEngine:', error);
      throw error;
    }
  }
  
  async generateDiagram(sessionId, options = {}) {
    try {
      const interview = await Interview.findById(sessionId);
      if (!interview) throw new Error('Session not found');
      
      const problem = await Problem.findOne({ id: interview.problemId });
      const currentStage = options.stage || interview.currentStage || 'introduction';
      const entities = this._extractEntities(interview.conversation, currentStage);
      const diagramType = options.diagramType || diagramUtils.getDiagramTypeForStage(currentStage);
      const svgDiagram = diagramUtils.generateSvgDiagram(entities, diagramType, problem.title);
      
      return { diagram: svgDiagram, type: diagramType };
    } catch (error) {
      console.error('Error generating diagram in InterviewEngine:', error);
      return null;
    }
  }
  
  async processResponse(interviewId, message, options = {}) {
    console.log(`Processing interview message for interview ${interviewId}`);
    
    try {
      // Find the interview by ID - using findById instead of findOne with id
      const interview = await Interview.findById(interviewId);
      
      if (!interview) {
        console.error(`Interview not found with ID: ${interviewId}`);
        throw new Error('Interview not found');
      }
      
      console.log(`Found interview, current stage: ${interview.currentStage}`);
      
      // Add user message to conversation
      interview.conversation.push({
        role: 'candidate',
        content: message,
        stage: interview.currentStage,
        timestamp: new Date().toISOString()
      });
      
      // Prepare messages for AI
      const messagesForAI = interview.conversation.map(msg => ({
        role: msg.role === 'interviewer' ? 'assistant' : 
              msg.role === 'candidate' ? 'user' : msg.role,
        content: msg.content
      }));
      
      // Get problem context
      const problem = await Problem.findOne({ id: interview.problemId });
      if (!problem) {
        console.warn(`Problem not found for interview ${interviewId}`);
      }
      
      // User experience level
      const userLevel = options.userLevel || 'mid-level';
      
      // Add system message with interview context
      let systemMessage = {
        role: 'system',
        content: `You are conducting a system design interview for ${problem?.title || 'a system design problem'}. 
The current stage is: ${interview.currentStage}.
Respond to the candidate's last message with thoughtful questions that probe their understanding.
Be conversational and react to what they've said, don't give generic responses.
If they ask about requirements, explore them thoroughly before moving to architecture.`
      };
      
      // Add concise mode instructions if enabled
      if (options.conciseMode !== false) { // Default to concise mode
        systemMessage.content += `\n\nUse a CONCISE communication style:
- Ask focused questions with clear intent
- Keep follow-ups brief and targeted
- Use short paragraphs (2-3 sentences maximum)
- Prioritize probing questions over explanations
- Eliminate unnecessary preambles`;
      }
      
      // Add user level information
      systemMessage.content += `\n\nThe candidate has identified as a ${userLevel} engineer. Adjust your expectations accordingly.`;
      
      // Generate AI response
      console.log('Generating interviewer response...');
      const response = await this.aiService.sendMessage(
        [systemMessage, ...messagesForAI], 
        { 
          temperature: options.temperature || 0.7,
          max_tokens: options.maxTokens || 800
        }
      );
      
      // Determine if we should advance to next stage
      const shouldAdvanceStage = this._shouldAdvanceStage(
        interview.conversation, 
        interview.currentStage, 
        messagesForAI.length
      );
      
      // Add interviewer response to conversation
      const responseMsg = {
        role: 'interviewer',
        content: response || "I'm interested in your approach. Could you elaborate on that further?",
        stage: interview.currentStage,
        timestamp: new Date().toISOString()
      };
      
      interview.conversation.push(responseMsg);
      
      // Update stage if needed
      if (shouldAdvanceStage) {
        interview.currentStage = this._getNextStage(interview.currentStage);
        console.log(`Advanced to stage: ${interview.currentStage}`);
      }
      
      // Save the updated interview
      await interview.save();
      console.log('Interview updated successfully');
      
      return interview;
    } catch (error) {
      console.error('Error processing interview message:', error);
      
      // Return fallback response
      return {
        conversation: [
          {
            role: 'interviewer',
            content: "I apologize, but I'm having trouble processing your response. Could you please explain your design approach again?",
            timestamp: new Date().toISOString(),
            error: true
          }
        ]
      };
    }
  }
  
  async finalizeInterview(interview) {
    try {
      if (!interview) throw new Error('Interview not found');
      
      if (interview.status === 'completed') {
        console.log('Interview already completed');
        return interview;
      }
      
      // Add final message if the interview was in progress
      if (interview.status === 'in_progress') {
        interview.conversation.push({
          role: 'interviewer',
          content: "Thank you for participating in this system design interview. I'll now provide you with feedback on your performance.",
          stage: interview.currentStage,
          timestamp: new Date().toISOString()
        });
        
        interview.status = 'completed';
        interview.completedAt = new Date();
      }
      
      // Prepare evaluation if not already done
      if (!interview.evaluation) {
        // Get grader assessment if available
        let graderAssessment = null;
        try {
          const graderEngine = require('./graderEngine');
          const userLevel = interview.userLevel || 'mid-level';
          
          // Get assessment from grader
          const assessment = await graderEngine.provideFinalAssessment(interview._id, { userLevel });
          if (assessment) {
            graderAssessment = assessment;
          }
        } catch (graderError) {
          console.error('Error getting grader assessment:', graderError);
          // Continue with regular evaluation if grader fails
        }
        
        // If we got grader assessment, use it
        if (graderAssessment) {
          interview.evaluation = {
            score: graderAssessment.scores.overall?.score || 70,
            feedback: graderAssessment.assessment,
            strengths: [],
            weaknesses: [],
            areas_to_improve: []
          };
        } else {
          // Fall back to original evaluation logic
          const problem = await Problem.findOne({ id: interview.problemId });
          
          // Extract the conversation for evaluation
          const conversationText = interview.conversation
            .map(msg => `${msg.role.toUpperCase()}: ${msg.content}`)
            .join('\n\n');
          
          let systemPrompt = `You are an expert system design interviewer evaluating a candidate.
The problem was: ${problem?.title || 'a system design problem'}.
Provide a detailed evaluation with:
1. Overall score (0-100)
2. General feedback (2-3 paragraphs)
3. Key strengths (3-5 bullet points)
4. Areas for improvement (3-5 bullet points)
5. Specific advice for next steps`;
          
          // Add concise mode if enabled
          if (interview.conciseMode !== false) {
            systemPrompt += `\n\nUse a CONCISE communication style:
- Keep paragraphs short (2-3 sentences)
- Use bullet points for lists
- Be direct and focused
- Eliminate filler phrases and redundancy`;
          }
          
          // Generate evaluation
          const evaluationPrompt = `Based on this interview conversation, provide a detailed evaluation:\n\n${conversationText}`;
          
          const evaluationResponse = await this.aiService.sendMessage(
            [{role: 'system', content: systemPrompt}, {role: 'user', content: evaluationPrompt}],
            { temperature: 0.4, max_tokens: 1500 }
          );
          
          // Parse the evaluation
          try {
            // Extract score with regex (looking for a number from 0-100)
            const scoreMatch = evaluationResponse.match(/score:?\s*(\d{1,3})/i);
            const score = scoreMatch ? parseInt(scoreMatch[1], 10) : 70;
            
            // Basic structure for evaluation
            interview.evaluation = {
              score: Math.min(100, Math.max(0, score)), // Ensure score is between 0-100
              feedback: evaluationResponse,
              strengths: [],
              weaknesses: [],
              areas_to_improve: []
            };
          } catch (parseError) {
            console.error('Error parsing evaluation:', parseError);
            interview.evaluation = {
              score: 70,
              feedback: evaluationResponse || "Evaluation could not be generated.",
              strengths: [],
              weaknesses: [], 
              areas_to_improve: []
            };
          }
        }
      }
      
      await interview.save();
      return interview;
    } catch (error) {
      console.error('Error finalizing interview:', error);
      throw error;
    }
  }
  
  _extractEntities(messages, currentStage) {
    const userMessages = messages
      .filter(msg => msg.role === 'candidate' || msg.role === 'user')
      .map(msg => msg.content)
      .join('\n');
    
    const componentKeywords = [
      'server', 'database', 'cache', 'load balancer', 'api', 'client', 
      'service', 'queue', 'storage', 'frontend', 'backend', 'microservice'
    ];
    
    const entities = { 
      components: [], 
      relationships: [], 
      databases: [], 
      clients: [], 
      services: [] 
    };
    
    componentKeywords.forEach(keyword => {
      if (userMessages.toLowerCase().includes(keyword)) {
        const type = keyword.includes('database') ? 'databases'
          : (keyword.includes('client') || keyword.includes('frontend')) ? 'clients'
          : (keyword.includes('service') || keyword.includes('api') || keyword.includes('backend')) ? 'services'
          : 'components';
        
        entities[type].push({
          name: keyword.charAt(0).toUpperCase() + keyword.slice(1),
          type: keyword
        });
      }
    });
    
    // Add default components based on stage
    if (entities.components.length === 0 && 
        entities.databases.length === 0 && 
        entities.services.length === 0) {
      
      // If we're past the introduction/requirements stage
      if (currentStage !== 'introduction' && currentStage !== 'requirements') {
        entities.clients.push({ name: 'Client', type: 'client' });
        entities.services.push({ name: 'API Service', type: 'service' });
      }
      
      // If we're in data modeling or later stages
      if (currentStage === 'data_modeling' || 
          currentStage === 'scalability' || 
          currentStage === 'conclusion') {
        entities.databases.push({ name: 'Database', type: 'database' });
      }
    }
    
    return entities;
  }
  
  _shouldAdvanceStage(conversation, currentStage, messageCount) {
    // Only advance stage after enough messages have been exchanged
    if (messageCount < 6) return false;
    
    // Map of stages to number of message pairs required before advancing
    const stageThresholds = {
      'introduction': 3,
      'requirements': 5,
      'architecture': 7,
      'data_modeling': 5,
      'scalability': 5,
      'conclusion': 999 // Never automatically advance past conclusion
    };
    
    const threshold = stageThresholds[currentStage] || 5;
    
    // Count pairs of messages (candidate -> interviewer)
    const relevantMessages = conversation.filter(
      msg => msg.stage === currentStage
    );
    
    const pairs = Math.floor(relevantMessages.length / 2);
    return pairs >= threshold;
  }
  
  _getNextStage(currentStage) {
    const stages = [
      'introduction',
      'requirements',
      'architecture',
      'data_modeling',
      'scalability',
      'conclusion'
    ];
    
    const currentIndex = stages.indexOf(currentStage);
    if (currentIndex === -1 || currentIndex === stages.length - 1) {
      return 'conclusion';
    }
    
    return stages[currentIndex + 1];
  }
}

module.exports = InterviewEngine;


================================================================================
# FILE: server\services\engines\PersonaService.js
# EXTENSION: .js
================================================================================
const PersonaManager = require('../persona/PersonaManager');

class PersonaService {
  constructor() {
    this.personaManager = PersonaManager;
    this.activePersonaId = 'coach';
    this.conciseMode = true;
  }
  
  async initialize(config) {
    await this.personaManager.initialize();
    return this;
  }
  
  setActivePersona(personaId) {
    return this.personaManager.setActivePersona(personaId);
  }
  
  getActivePersona() {
    return this.personaManager.getPersonaContext(this.activePersonaId);
  }
  
  getSystemPrompt(context = {}) {
    const persona = this.getActivePersona();
    return persona.systemPrompt;
  }
}

module.exports = new PersonaService();



================================================================================
# FILE: server\services\evaluation\evaluationParser.js
# EXTENSION: .js
================================================================================



================================================================================
# FILE: server\services\evaluation\evaluationService.js
# EXTENSION: .js
================================================================================
const { skillsFramework } = require('../../../data/enhanced_skills');
const Interview = require('../../models/Interview');

class EvaluationService {
  constructor() {
    this.metrics = new Map();
  }

  async evaluateSection(sessionId, section, content) {
    const metrics = await this._calculateMetrics(section, content);
    this.metrics.set(`${sessionId}:${section}`, metrics);
    
    return {
      completion: this._calculateCompletion(section, metrics),
      feedback: this._generateFeedback(section, metrics),
      improvements: this._identifyImprovements(section, metrics)
    };
  }

  async evaluateWorkbook(sessionId) {
    const sections = ['requirements', 'api_design', 'data_modeling', 'system_architecture', 'scalability'];
    const evaluations = await Promise.all(
      sections.map(section => this.evaluateSection(sessionId, section))
    );

    return {
      overall: this._calculateOverall(evaluations),
      sectionEvaluations: evaluations,
      recommendations: this._generateRecommendations(evaluations)
    };
  }

  _calculateMetrics(section, content) {
    // Implementation would analyze content based on section criteria
    // This would likely use NLP or pattern matching
    return {
      completion: 0.85,
      quality: 0.75,
      coverage: 0.80
    };
  }

  _calculateCompletion(section, metrics) {
    const criteria = skillsFramework.technical[section].completion_criteria;
    return Object.entries(criteria).reduce((total, [key, weight]) => {
      return total + (metrics[key] || 0) * weight;
    }, 0);
  }

  _generateFeedback(section, metrics) {
    return {
      strengths: [],
      improvements: [],
      nextSteps: []
    };
  }

  _identifyImprovements(section, metrics) {
    return {
      priority: [],
      optional: []
    };
  }
}

module.exports = new EvaluationService();


================================================================================
# FILE: server\services\evaluation\workbookEvaluationService.js
# EXTENSION: .js
================================================================================
const { skillsFramework } = require('../../../data/enhanced_skills');
const DiagramEvaluationService = require('../diagram/diagramEvaluationService');
const EvaluationService = require('./evaluationService');

class WorkbookEvaluationService {
  constructor() {
    this.evaluationService = new EvaluationService();
  }

  async evaluateSection(sessionId, section, content) {
    switch(section) {
      case 'diagram':
        return await DiagramEvaluationService.evaluateDiagram(content, 'system', { sessionId });
      
      case 'api_design':
        return await this.evaluationService.evaluateSection(sessionId, 'api_design', content);
      
      case 'requirements':
        return await this.evaluationService.evaluateSection(sessionId, 'requirements', content);
      
      case 'architecture':
        return await this.evaluationService.evaluateSection(sessionId, 'system_architecture', content);
      
      default:
        throw new Error(`Unknown section: ${section}`);
    }
  }

  async evaluateProgress(sessionId) {
    const workbook = await Workbook.findOne({ sessionId });
    if (!workbook) throw new Error('Workbook not found');

    const evaluations = {};
    const sections = ['requirements', 'api_design', 'architecture', 'diagram'];

    for (const section of sections) {
      if (workbook[section]) {
        evaluations[section] = await this.evaluateSection(sessionId, section, workbook[section]);
      }
    }

    return {
      evaluations,
      overallProgress: this._calculateOverallProgress(evaluations),
      recommendations: this._generateRecommendations(evaluations)
    };
  }

  _calculateOverallProgress(evaluations) {
    const weights = {
      requirements: 0.2,
      api_design: 0.25,
      architecture: 0.3,
      diagram: 0.25
    };

    return Object.entries(evaluations).reduce((total, [section, eval]) => {
      return total + (eval.completion || 0) * weights[section];
    }, 0);
  }

  _generateRecommendations(evaluations) {
    const recommendations = [];
    Object.entries(evaluations).forEach(([section, eval]) => {
      if (eval.completion < 0.7) {
        recommendations.push({
          section,
          priority: 'high',
          suggestions: eval.improvements || []
        });
      }
    });
    return recommendations;
  }
}

module.exports = new WorkbookEvaluationService();


================================================================================
# FILE: server\services\knowledge\knowledgeService.js
# EXTENSION: .js
================================================================================
const AIFactory = require('../ai/aiFactory');
const aiConfig = require('../../config/aiConfig');
const path = require('path');
const fs = require('fs');

const KNOWLEDGE_BASE_DIR = path.join(__dirname, '../../../data/knowledge_base');
const VECTOR_DB_DIR = path.join(__dirname, '../../../data/chroma_db');

class KnowledgeService {
  constructor() {
    this.aiService = AIFactory.createService(
      aiConfig.defaultProvider, 
      aiConfig[aiConfig.defaultProvider]
    );
    this.vectorStores = {};
  }

  async initializeVectorStore() {
    const companies = fs.readdirSync(KNOWLEDGE_BASE_DIR)
      .filter(d => fs.statSync(path.join(KNOWLEDGE_BASE_DIR, d)).isDirectory());
    
    for (const company of companies) {
      const companyDir = path.join(KNOWLEDGE_BASE_DIR, company);
      
      // Check if documents exist
      if (!fs.readdirSync(companyDir).some(f => f.endsWith('.md'))) {
        console.log(`No markdown files found for ${company}`);
        continue;
      }
      
      // Create vector store directory
      const companyVectorDir = path.join(VECTOR_DB_DIR, company);
      // ... rest of vector store initialization
    }
  }

  async queryKnowledge(query, company = 'facebook') {
    if (!this.initialized) await this.initialize();
    
    try {
      const result = await this._executeCommand('query', { query, company });
      return result;
    } catch (error) {
      console.error('Error querying knowledge base:', error);
      return '';
    }
  }
  
  async _executeCommand(command, params = {}) {
    const requestId = Date.now().toString();
    const requestFile = path.join(__dirname, `request_${requestId}.json`);
    const responseFile = path.join(__dirname, `response_${requestId}.json`);
    
    // Write request to file
    fs.writeFileSync(requestFile, JSON.stringify({
      command,
      params
    }));
    
    // Execute Python command
    await exec(`python ${path.join(__dirname, 'vector_store.py')} ${requestId}`);
    
    // Read response
    const response = JSON.parse(fs.readFileSync(responseFile, 'utf8'));
    
    // Clean up
    fs.unlinkSync(requestFile);
    fs.unlinkSync(responseFile);
    
    return response.result;
  }
  
  _getPythonScript() {
    return `
import sys
import os
import json
from langchain.document_loaders import TextLoader, DirectoryLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
import openai

# Set up OpenAI API key
openai.api_key = os.environ.get("OPENAI_API_KEY", "your-openai-key")

# Paths
KNOWLEDGE_BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../../data/knowledge_base')
VECTOR_DB_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../../data/chroma_db')

# Global variables
vector_stores = {}

def initialize_vector_store():
    """Initialize or load vector stores for each company"""
    companies = [d for d in os.listdir(KNOWLEDGE_BASE_DIR) if os.path.isdir(os.path.join(KNOWLEDGE_BASE_DIR, d))]
    
    for company in companies:
        company_dir = os.path.join(KNOWLEDGE_BASE_DIR, company)
        
        # Check if documents exist
        if not any(f.endswith('.md') for f in os.listdir(company_dir)):
            print(f"No markdown files found for {company}")
            continue
        
        # Create vector store directory
        company_vector_dir = os.path.join(VECTOR_DB_DIR, company)
        os.makedirs(company_vector_dir, exist_ok=True)
        
        # Load documents
        loader = DirectoryLoader(company_dir, glob="**/*.md", loader_cls=TextLoader)
        documents = loader.load()
        
        if not documents:
            print(f"No documents loaded for {company}")
            continue
        
        # Split documents
        text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)
        chunks = text_splitter.split_documents(documents)
        
        # Create embeddings and vector store
        embeddings = OpenAIEmbeddings()
        vector_store = Chroma.from_documents(
            chunks, 
            embeddings, 
            persist_directory=company_vector_dir
        )
        
        vector_stores[company] = vector_store
        print(f"Initialized vector store for {company} with {len(chunks)} chunks")

def query_knowledge(query, company="facebook"):
    """Query the vector store for relevant knowledge"""
    if company not in vector_stores:
        return "No knowledge available for this company"
    
    # Get relevant documents
    docs = vector_stores[company].similarity_search(query, k=3)
    
    # Combine document contents
    return "\\n\\n".join([doc.page_content for doc in docs])

if __name__ == "__main__":
    if len(sys.argv) > 1:
        request_id = sys.argv[1]
        request_file = f"request_{request_id}.json"
        response_file = f"response_{request_id}.json"
        
        # Read request
        with open(request_file, 'r') as f:
            request = json.load(f)
        
        command = request['command']
        params = request.get('params', {})
        
        result = ""
        
        # Execute command
        if command == "initialize":
            initialize_vector_store()
            result = "Vector store initialized"
        elif command == "query":
            result = query_knowledge(params.get('query', ''), params.get('company', 'facebook'))
        
        # Write response
        with open(response_file, 'w') as f:
            json.dump({"result": result}, f)
    else:
        # Initialize on startup
        initialize_vector_store()
        
        # Wait for commands
        while True:
            line = sys.stdin.readline().strip()
            if line == "exit":
                break
    `;
  }
}

module.exports = new KnowledgeService();


================================================================================
# FILE: server\services\knowledge\vector_store.py
# EXTENSION: .py
================================================================================
import sys
import os
import json
from langchain_community.document_loaders import TextLoader, DirectoryLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.embeddings import OpenAIEmbeddings
from langchain_community.vectorstores import Chroma
import openai

# Set up OpenAI API key
openai.api_key = os.environ.get("OPENAI_API_KEY", "your-openai-key")

# Paths
KNOWLEDGE_BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../../data/knowledge_base')
VECTOR_DB_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../../data/chroma_db')

# Global variables
vector_stores = {}

def initialize_vector_store():
    """Initialize or load vector stores for each company"""
    try:
        companies = [d for d in os.listdir(KNOWLEDGE_BASE_DIR) if os.path.isdir(os.path.join(KNOWLEDGE_BASE_DIR, d))]
        
        for company in companies:
            company_dir = os.path.join(KNOWLEDGE_BASE_DIR, company)
            
            # Check if documents exist
            if not any(f.endswith('.md') for f in os.listdir(company_dir)):
                print(f"No markdown files found for {company}")
                continue
            
            # Create vector store directory
            company_vector_dir = os.path.join(VECTOR_DB_DIR, company)
            os.makedirs(company_vector_dir, exist_ok=True)
            
            # Load documents
            loader = DirectoryLoader(company_dir, glob="**/*.md", loader_cls=TextLoader)
            documents = loader.load()
            
            if not documents:
                print(f"No documents loaded for {company}")
                continue
            
            # Split documents
            text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)
            chunks = text_splitter.split_documents(documents)
            
            # Create embeddings and vector store
            embeddings = OpenAIEmbeddings()
            vector_store = Chroma.from_documents(
                chunks, 
                embeddings, 
                persist_directory=company_vector_dir
            )
            
            vector_stores[company] = vector_store
            print(f"Initialized vector store for {company} with {len(chunks)} chunks")
    except Exception as e:
        print(f"Error initializing vector store: {str(e)}")
        return f"Error: {str(e)}"
    
    return "Vector store initialized successfully"

def query_knowledge(query, company="facebook"):
    """Query the vector store for relevant knowledge"""
    try:
        if company not in vector_stores:
            return "No knowledge available for this company"
        
        # Get relevant documents
        docs = vector_stores[company].similarity_search(query, k=3)
        
        # Combine document contents
        return "\n\n".join([doc.page_content for doc in docs])
    except Exception as e:
        print(f"Error querying knowledge: {str(e)}")
        return f"Error: {str(e)}"

if __name__ == "__main__":
    if len(sys.argv) > 1:
        request_id = sys.argv[1]
        request_file = f"request_{request_id}.json"
        response_file = f"response_{request_id}.json"
        
        try:
            # Check if request file exists
            if not os.path.exists(request_file):
                result = f"Error: Request file {request_file} not found"
                with open(response_file, 'w') as f:
                    json.dump({"result": result}, f)
                sys.exit(1)
            
            # Read request
            with open(request_file, 'r') as f:
                request = json.load(f)
            
            command = request.get('command', '')
            params = request.get('params', {})
            
            result = ""
            
            # Execute command
            if command == "initialize":
                result = initialize_vector_store()
            elif command == "query":
                result = query_knowledge(params.get('query', ''), params.get('company', 'facebook'))
            else:
                result = f"Unknown command: {command}"
            
            # Write response
            with open(response_file, 'w') as f:
                json.dump({"result": result}, f)
                
        except Exception as e:
            # Ensure we write a response file even if an error occurs
            error_message = f"Error processing request: {str(e)}"
            print(error_message)
            try:
                with open(response_file, 'w') as f:
                    json.dump({"result": error_message}, f)
            except:
                print(f"Could not write to response file {response_file}")
    else:
        # Initialize on startup
        print("Initializing vector store...")
        initialize_vector_store()
        
        # Wait for commands
        print("Ready for commands (type 'exit' to quit)")
        while True:
            try:
                line = sys.stdin.readline().strip()
                if line == "exit":
                    break
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"Error reading input: {str(e)}")


================================================================================
# FILE: server\services\persona\PersonaManager.js
# EXTENSION: .js
================================================================================
const path = require('path');
const logger = require('../../utils/logger');

class PersonaManager {
  constructor() {
    this.personas = new Map();
    this.knowledgeBase = new Map();
    this.activePersona = null;
  }

  async initialize() {
    try {
      // Load persona definitions
      const personaTypes = ['coach', 'interviewer', 'grader'];
      for (const type of personaTypes) {
        const persona = require(`../../../data/persona/${type}Persona.js`);
        this.personas.set(type, persona);
      }

      // Load knowledge base
      await this.loadKnowledgeBase();

      logger.info('PersonaManager initialized successfully');
      return true;
    } catch (error) {
      logger.error('Failed to initialize PersonaManager:', error);
      throw error;
    }
  }

  async loadKnowledgeBase() {
    const baseDir = path.join(__dirname, '../../../data/knowledge_base');
    const companies = ['facebook', 'google', 'amazon'];
    
    for (const company of companies) {
      const companyData = {
        architecture: require(`${baseDir}/${company}/architecture/core_tech.md`),
        design: require(`${baseDir}/${company}/design_questions`),
        evaluation: require(`${baseDir}/${company}/evaluation_criteria/scoring_rubric.md`)
      };
      this.knowledgeBase.set(company, companyData);
    }
  }

  setActivePersona(type) {
    if (!this.personas.has(type)) {
      throw new Error(`Invalid persona type: ${type}`);
    }
    this.activePersona = this.personas.get(type);
    return this.activePersona;
  }

  getPersonaContext(type, additionalContext = {}) {
    const persona = this.personas.get(type);
    if (!persona) {
      throw new Error(`Persona not found: ${type}`);
    }

    return {
      ...persona.baseContext,
      ...additionalContext,
      knowledge: this.getRelevantKnowledge(additionalContext.topic)
    };
  }

  getRelevantKnowledge(topic) {
    // Implementation to fetch relevant knowledge based on topic
    return Array.from(this.knowledgeBase.values())
      .flatMap(company => Object.values(company))
      .filter(knowledge => knowledge.topics.includes(topic));
  }
}

module.exports = new PersonaManager();


================================================================================
# FILE: server\services\progress\progressTrackingService.js
# EXTENSION: .js
================================================================================
const Workbook = require('../../models/Workbook');
const workbookEvaluationService = require('../evaluation/workbookEvaluationService');

class ProgressTrackingService {
  async trackProgress(sessionId, userId) {
    const workbook = await Workbook.findOne({ sessionId });
    if (!workbook) throw new Error('Workbook not found');

    const evaluation = await workbookEvaluationService.evaluateProgress(sessionId);
    
    // Update progress in workbook
    workbook.progress = {
      completion: evaluation.overallProgress,
      sections: new Map(Object.entries(evaluation.evaluations)),
      lastUpdated: new Date()
    };

    await workbook.save();

    return {
      currentProgress: evaluation.overallProgress,
      sectionProgress: evaluation.evaluations,
      recommendations: evaluation.recommendations,
      timeline: await this.getProgressTimeline(sessionId)
    };
  }

  async getProgressTimeline(sessionId) {
    const workbook = await Workbook.findOne({ sessionId });
    if (!workbook) throw new Error('Workbook not found');

    return workbook.coachingInteractions.map(interaction => ({
      timestamp: interaction.timestamp,
      type: 'coaching',
      content: interaction.message
    }));
  }
}

module.exports = new ProgressTrackingService();


================================================================================
# FILE: server\services\skills\skillEvaluationService.js
# EXTENSION: .js
================================================================================
const { skillsFramework, calculateSkillLevel, getSkillFeedback } = require('../../../data/enhanced_skills');
const AIFactory = require('../ai/aiFactory');
const aiConfig = require('../../config/aiConfig');

class SkillEvaluationService {
  constructor() {
    this.aiService = AIFactory.createService(aiConfig.defaultProvider, aiConfig[aiConfig.defaultProvider]);
  }

  async evaluateResponse(category, skillName, response, context) {
    const skill = skillsFramework[category][skillName];
    if (!skill) {
      throw new Error(`Invalid skill: ${category}.${skillName}`);
    }

    const prompt = this._buildEvaluationPrompt(skill, response, context);
    const evaluation = await this._getAIEvaluation(prompt);
    
    return {
      ...evaluation,
      feedback: getSkillFeedback({ category, name: skillName }, evaluation.metrics)
    };
  }

  async evaluateDesignSession(sessionData) {
    const evaluations = {};
    
    // Evaluate technical skills
    if (sessionData.diagrams) {
      evaluations.system_architecture = await this.evaluateResponse(
        'technical',
        'system_architecture',
        sessionData.diagrams.architecture,
        { type: 'diagram' }
      );
    }

    if (sessionData.apis) {
      evaluations.api_design = await this.evaluateResponse(
        'technical',
        'api_design',
        sessionData.apis,
        { type: 'api_specification' }
      );
    }

    // Evaluate communication skills from conversation
    if (sessionData.conversation) {
      evaluations.communication = await this.evaluateResponse(
        'soft',
        'communication',
        sessionData.conversation,
        { type: 'dialogue' }
      );
    }

    return {
      evaluations,
      summary: this._generateSessionSummary(evaluations)
    };
  }

  _buildEvaluationPrompt(skill, response, context) {
    return {
      role: 'system',
      content: `You are evaluating a candidate's ${skill.name} skills. 
                Consider the following evaluation points: ${JSON.stringify(skill.evaluation_points)}.
                Provide numerical scores (0-1) for each completion criteria: ${JSON.stringify(skill.completion_criteria)}.
                Context type: ${context.type}`,
    };
  }

  async _getAIEvaluation(prompt) {
    const response = await this.aiService.sendMessage([
      prompt,
      {
        role: 'user',
        content: 'Evaluate the response and provide metrics as JSON'
      }
    ]);

    try {
      // Extract metrics from AI response
      const metrics = JSON.parse(response.content);
      return {
        metrics,
        rawScore: Object.values(metrics).reduce((sum, val) => sum + val, 0) / Object.keys(metrics).length
      };
    } catch (error) {
      console.error('Failed to parse AI evaluation:', error);
      throw new Error('Failed to generate skill evaluation');
    }
  }

  _generateSessionSummary(evaluations) {
    const summary = {
      overallScore: 0,
      strengths: [],
      improvements: []
    };

    Object.entries(evaluations).forEach(([skill, evaluation]) => {
      summary.overallScore += evaluation.rawScore * skillsFramework[skill].weight;
      
      if (evaluation.feedback.strengths.length > 0) {
        summary.strengths.push({
          skill,
          points: evaluation.feedback.strengths
        });
      }

      if (evaluation.feedback.improvements.length > 0) {
        summary.improvements.push({
          skill,
          points: evaluation.feedback.improvements
        });
      }
    });

    return summary;
  }
}

module.exports = new SkillEvaluationService();


================================================================================
# FILE: server\services\skills\skillProgressService.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');
const { evaluateSkillProgress, getSkillRequirements } = require('../../../data/enhanced_skills');

class SkillProgressService {
  constructor() {
    this.SkillProgress = mongoose.model('SkillProgress', new mongoose.Schema({
      userId: { type: mongoose.Schema.Types.ObjectId, required: true },
      skills: {
        type: Map,
        of: {
          level: Number,
          history: [{
            timestamp: Date,
            metrics: Object,
            sessionId: String
          }],
          recentEvaluations: [{
            sessionId: String,
            score: Number,
            feedback: Object,
            timestamp: Date
          }]
        }
      }
    }));
  }

  async updateProgress(userId, sessionId, evaluations) {
    let progress = await this.SkillProgress.findOne({ userId });
    
    if (!progress) {
      progress = new this.SkillProgress({
        userId,
        skills: new Map()
      });
    }

    for (const [skillName, evaluation] of Object.entries(evaluations)) {
      const skillData = progress.skills.get(skillName) || {
        level: 1,
        history: [],
        recentEvaluations: []
      };

      // Add new evaluation
      skillData.recentEvaluations.unshift({
        sessionId,
        score: evaluation.rawScore,
        feedback: evaluation.feedback,
        timestamp: new Date()
      });

      // Keep only last 5 evaluations
      skillData.recentEvaluations = skillData.recentEvaluations.slice(0, 5);

      // Update history
      skillData.history.push({
        timestamp: new Date(),
        metrics: evaluation.metrics,
        sessionId
      });

      // Calculate new level
      const progressEvaluation = evaluateSkillProgress(
        { name: skillName },
        skillData.history[skillData.history.length - 2]?.metrics || {},
        evaluation.metrics
      );

      if (progressEvaluation.levelChange > 0) {
        skillData.level += progressEvaluation.levelChange;
      }

      progress.skills.set(skillName, skillData);
    }

    await progress.save();
    return progress;
  }

  async getSkillRoadmap(userId) {
    const progress = await this.SkillProgress.findOne({ userId });
    if (!progress) {
      return null;
    }

    const roadmap = {};
    for (const [skillName, skillData] of progress.skills) {
      const currentLevel = skillData.level;
      const nextLevel = currentLevel + 1;

      roadmap[skillName] = {
        currentLevel,
        requirements: getSkillRequirements({ name: skillName }, nextLevel),
        recentProgress: skillData.recentEvaluations.map(eval => ({
          score: eval.score,
          timestamp: eval.timestamp,
          key_feedback: eval.feedback.improvements.slice(0, 3)
        }))
      };
    }

    return roadmap;
  }
}

module.exports = new SkillProgressService();


================================================================================
# FILE: server\services\utils\diagramUtils.js
# EXTENSION: .js
================================================================================
// server/services/utils/diagramUtils.js

/**
 * Determine which type of diagram to generate based on the current stage
 * @param {Number} currentStage - Current design stage
 * @returns {String} - Diagram type (architecture, er, sequence)
 */
function getDiagramTypeForStage(currentStage) {
    const stageToType = {
      0: null, // Requirements - no diagram
      1: null, // Scale estimation - no diagram
      2: 'api', // API design - API diagram
      3: 'er', // Data model - ER diagram
      4: 'architecture', // System architecture
      5: 'architecture' // Optimization - enhanced architecture
    };
    
    return stageToType[currentStage] || 'architecture';
  }
  
  /**
   * Generate an SVG diagram based on extracted entities
   * @param {Object} entities - Extracted components and relationships
   * @param {String} diagramType - Type of diagram to generate
   * @param {String} title - Diagram title
   * @returns {String} - SVG markup
   */
  function generateSvgDiagram(entities, diagramType, title) {
    if (diagramType === 'er') {
      return generateErDiagram(entities, title);
    } else if (diagramType === 'api') {
      return generateApiDiagram(entities, title);
    } else {
      return generateArchitectureDiagram(entities, title);
    }
  }
  
  /**
   * Generate an architecture diagram as SVG
   * @param {Object} entities - Extracted components and relationships
   * @param {String} title - Diagram title
   * @returns {String} - SVG markup
   */
  function generateArchitectureDiagram(entities, title) {
    const svgWidth = 800;
    const svgHeight = 600;
    
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}" width="100%" height="100%">
      <!-- Background -->
      <rect width="${svgWidth}" height="${svgHeight}" fill="#f8f9fa" rx="10" ry="10"/>
      
      <!-- Title -->
      <text x="${svgWidth/2}" y="40" font-family="Arial" font-size="24" font-weight="bold" text-anchor="middle" fill="#333">${title}</text>
      <text x="${svgWidth/2}" y="65" font-family="Arial" font-size="14" text-anchor="middle" fill="#666">System Architecture</text>
      
      <!-- Layers -->
      <rect x="50" y="100" width="${svgWidth-100}" height="80" fill="#e3f2fd" stroke="#2196f3" stroke-width="2" rx="5" ry="5" opacity="0.5"/>
      <text x="${svgWidth/2}" y="125" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#0d47a1">Client Layer</text>
      
      <rect x="50" y="200" width="${svgWidth-100}" height="80" fill="#e8f5e9" stroke="#4caf50" stroke-width="2" rx="5" ry="5" opacity="0.5"/>
      <text x="${svgWidth/2}" y="225" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#1b5e20">API Layer</text>
      
      <rect x="50" y="300" width="${svgWidth-100}" height="80" fill="#fff3e0" stroke="#ff9800" stroke-width="2" rx="5" ry="5" opacity="0.5"/>
      <text x="${svgWidth/2}" y="325" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#e65100">Service Layer</text>
      
      <rect x="50" y="400" width="${svgWidth-100}" height="80" fill="#e0f7fa" stroke="#00bcd4" stroke-width="2" rx="5" ry="5" opacity="0.5"/>
      <text x="${svgWidth/2}" y="425" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#006064">Data Layer</text>
    `;
    
    // Add clients to client layer
    const clients = entities.clients.length > 0 ? entities.clients : [{ name: 'Client Application', type: 'client' }];
    const clientWidth = Math.min(120, (svgWidth - 150) / clients.length);
    clients.forEach((client, index) => {
      const x = 100 + index * (clientWidth + 30);
      svg += `
        <rect x="${x}" y="115" width="${clientWidth}" height="50" fill="#bbdefb" stroke="#1976d2" stroke-width="2" rx="5" ry="5"/>
        <text x="${x + clientWidth/2}" y="145" font-family="Arial" font-size="14" text-anchor="middle" fill="#0d47a1">${client.name}</text>
      `;
    });
    
    // Add load balancer if present
    if (entities.components.some(c => c.type.includes('load balancer'))) {
      svg += `
        <path d="M370,215 L440,215 L470,245 L440,275 L370,275 L340,245 Z" fill="#c8e6c9" stroke="#388e3c" stroke-width="2"/>
        <text x="405" y="250" font-family="Arial" font-size="14" text-anchor="middle" fill="#1b5e20">Load Balancer</text>
      `;
    }
    
    // Add services to service layer
    const services = entities.services.length > 0 ? entities.services : [{ name: 'API Service', type: 'service' }];
    const serviceWidth = Math.min(120, (svgWidth - 150) / services.length);
    services.forEach((service, index) => {
      const x = 100 + index * (serviceWidth + 30);
      svg += `
        <rect x="${x}" y="315" width="${serviceWidth}" height="50" fill="#ffe0b2" stroke="#f57c00" stroke-width="2" rx="5" ry="5"/>
        <text x="${x + serviceWidth/2}" y="345" font-family="Arial" font-size="14" text-anchor="middle" fill="#e65100">${service.name}</text>
      `;
    });
    
    // Add databases to data layer
    const databases = entities.databases.length > 0 ? entities.databases : [{ name: 'Database', type: 'database' }];
    databases.forEach((db, index) => {
      const x = 150 + index * 200;
      svg += `
        <path d="M${x-60},430 L${x+60},430 L${x+60},450 C${x+60},470 ${x},485 ${x-60},485 L${x-60},430 Z" fill="#b2ebf2" stroke="#0097a7" stroke-width="2"/>
        <ellipse cx="${x}" cy="430" rx="60" ry="15" fill="#b2ebf2" stroke="#0097a7" stroke-width="2"/>
        <text x="${x}" y="460" font-family="Arial" font-size="14" font-weight="bold" text-anchor="middle" fill="#006064">${db.name}</text>
      `;
    });
    
    // Add cache if present
    if (entities.components.some(c => c.type.includes('cache'))) {
      svg += `
        <rect x="600" y="430" width="120" height="50" fill="#b2ebf2" stroke="#0097a7" stroke-width="2" rx="5" ry="5"/>
        <text x="660" y="460" font-family="Arial" font-size="14" font-weight="bold" text-anchor="middle" fill="#006064">Cache</text>
      `;
    }
    
    // Add connections between layers
    svg += `
      <!-- Client to API connections -->
      <line x1="160" y1="165" x2="160" y2="215" stroke="#757575" stroke-width="2" stroke-dasharray="5,5"/>
      <line x1="400" y1="165" x2="400" y2="215" stroke="#757575" stroke-width="2" stroke-dasharray="5,5"/>
      
      <!-- API to Service connections -->
      <line x1="160" y1="275" x2="160" y2="315" stroke="#757575" stroke-width="2"/>
      <line x1="400" y1="275" x2="400" y2="315" stroke="#757575" stroke-width="2"/>
      
      <!-- Service to Database connections -->
      <line x1="160" y1="365" x2="160" y2="430" stroke="#757575" stroke-width="2"/>
      <line x1="400" y1="365" x2="400" y2="430" stroke="#757575" stroke-width="2"/>
    `;
    
    svg += `</svg>`;
    return svg;
  }
  
  /**
   * Generate an ER diagram as SVG for data model
   * @param {Object} entities - Extracted entities and attributes
   * @param {String} title - Diagram title
   * @returns {String} - SVG markup
   */
  function generateErDiagram(entities, title) {
    const svgWidth = 800;
    const svgHeight = 600;
    
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}" width="100%" height="100%">
      <!-- Background -->
      <rect width="${svgWidth}" height="${svgHeight}" fill="#f8f9fa" rx="10" ry="10"/>
      
      <!-- Title -->
      <text x="${svgWidth/2}" y="40" font-family="Arial" font-size="24" font-weight="bold" text-anchor="middle" fill="#333">${title}</text>
      <text x="${svgWidth/2}" y="65" font-family="Arial" font-size="14" text-anchor="middle" fill="#666">Entity Relationship Diagram</text>
    `;
    
    // Use databases or create default entities if none exist
    const dbEntities = entities.databases.length > 0 ? 
      entities.databases : 
      [
        { name: 'User', type: 'entity', attributes: ['id', 'name', 'email'] },
        { name: 'Profile', type: 'entity', attributes: ['id', 'user_id', 'bio'] }
      ];
    
    // Add entities to the diagram
    dbEntities.forEach((entity, index) => {
      const x = 150 + (index % 3) * 250;
      const y = 150 + Math.floor(index / 3) * 200;
      
      // Add attributes if they exist or create defaults
      const attributes = entity.attributes || ['id', 'created_at', 'updated_at'];
      
      // Entity header
      svg += `
        <rect x="${x-100}" y="${y}" width="200" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" ry="5"/>
        <text x="${x}" y="${y+25}" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#0d47a1">${entity.name}</text>
        
        <!-- Entity attributes -->
        <rect x="${x-100}" y="${y+40}" width="200" height="${attributes.length * 25}" fill="#f5f5f5" stroke="#1976d2" stroke-width="2" rx="0" ry="0"/>
      `;
      
      // Add each attribute
      attributes.forEach((attr, attrIndex) => {
        svg += `
          <text x="${x-90}" y="${y+65+attrIndex*25}" font-family="Arial" font-size="14" text-anchor="start" fill="#333">${attr}</text>
        `;
      });
      
      // Add relationships if there are multiple entities
      if (index > 0 && index < dbEntities.length) {
        const prevX = 150 + ((index-1) % 3) * 250;
        const prevY = 150 + Math.floor((index-1) / 3) * 200;
        
        // Only connect horizontally adjacent entities
        if (Math.floor(index / 3) === Math.floor((index-1) / 3)) {
          svg += `
            <line x1="${prevX+100}" y1="${prevY+60}" x2="${x-100}" y2="${y+60}" stroke="#757575" stroke-width="2" marker-end="url(#arrowhead)"/>
          `;
        }
      }
    });
    
    // Add arrow marker
    svg += `
      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#757575" />
        </marker>
      </defs>
    `;
    
    svg += `</svg>`;
    return svg;
  }
  
  /**
   * Generate an API diagram as SVG
   * @param {Object} entities - Extracted entities
   * @param {String} title - Diagram title
   * @returns {String} - SVG markup
   */
  function generateApiDiagram(entities, title) {
    const svgWidth = 800;
    const svgHeight = 600;
    
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}" width="100%" height="100%">
      <!-- Background -->
      <rect width="${svgWidth}" height="${svgHeight}" fill="#f8f9fa" rx="10" ry="10"/>
      
      <!-- Title -->
      <text x="${svgWidth/2}" y="40" font-family="Arial" font-size="24" font-weight="bold" text-anchor="middle" fill="#333">${title}</text>
      <text x="${svgWidth/2}" y="65" font-family="Arial" font-size="14" text-anchor="middle" fill="#666">API Design</text>
      
      <!-- API Endpoints Box -->
      <rect x="50" y="100" width="${svgWidth-100}" height="${svgHeight-150}" fill="#ffffff" stroke="#2196f3" stroke-width="2" rx="5" ry="5"/>
      <text x="${svgWidth/2}" y="130" font-family="Arial" font-size="18" font-weight="bold" text-anchor="middle" fill="#0d47a1">API Endpoints</text>
    `;
    
    // Create default API endpoints based on the problem domain
    const endpoints = [
      { method: 'GET', path: '/api/resource', description: 'Get all resources' },
      { method: 'GET', path: '/api/resource/{id}', description: 'Get resource by ID' },
      { method: 'POST', path: '/api/resource', description: 'Create new resource' },
      { method: 'PUT', path: '/api/resource/{id}', description: 'Update resource' },
      { method: 'DELETE', path: '/api/resource/{id}', description: 'Delete resource' }
    ];
    
    // Draw each endpoint
    endpoints.forEach((endpoint, index) => {
      const y = 180 + index * 70;
      
      // Method box color based on HTTP method
      const methodColor = endpoint.method === 'GET' ? '#4caf50' :
                          endpoint.method === 'POST' ? '#2196f3' :
                          endpoint.method === 'PUT' ? '#ff9800' :
                          endpoint.method === 'DELETE' ? '#f44336' : '#9c27b0';
      
      svg += `
        <rect x="100" y="${y}" width="100" height="40" fill="${methodColor}" stroke="none" rx="5" ry="5"/>
        <text x="150" y="${y+25}" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="white">${endpoint.method}</text>
        
        <!-- Path -->
        <rect x="200" y="${y}" width="300" height="40" fill="#f5f5f5" stroke="none" rx="0" ry="0"/>
        <text x="210" y="${y+25}" font-family="monospace" font-size="14" text-anchor="start" fill="#333">${endpoint.path}</text>
        
        <!-- Description -->
        <text x="520" y="${y+25}" font-family="Arial" font-size="14" text-anchor="start" fill="#555">${endpoint.description}</text>
      `;
    });
    
    svg += `</svg>`;
    return svg;
  }
  
  module.exports = {
    getDiagramTypeForStage,
    generateSvgDiagram,
    generateArchitectureDiagram,
    generateErDiagram,
    generateApiDiagram
  };


================================================================================
# FILE: server\services\workbook\workbookDiagramService.js
# EXTENSION: .js
================================================================================
const Workbook = require('../../models/Workbook');

class WorkbookDiagramService {
  async getDiagram(sessionId, diagramType) {
    const workbook = await Workbook.findOne({ sessionId });
    if (!workbook || !workbook.diagrams || !workbook.diagrams[diagramType]) {
      return null;
    }
    return workbook.diagrams[diagramType];
  }

  async saveDiagram(sessionId, diagramType, diagramData) {
    const update = {
      [`diagrams.${diagramType}`]: {
        type: diagramType,
        nodes: diagramData.nodes,
        edges: diagramData.edges,
        mermaidCode: diagramData.mermaidCode,
        'metadata.lastUpdated': new Date(),
        'metadata.version': 1
      }
    };

    return await Workbook.findOneAndUpdate(
      { sessionId },
      { $set: update },
      { new: true }
    );
  }
}

module.exports = new WorkbookDiagramService();


================================================================================
# FILE: server\testAnthropic.js
# EXTENSION: .js
================================================================================
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '.env') });
const { default: Anthropic } = require('@anthropic-ai/sdk');
const { config } = require('./config/aiConfig');

async function testAnthropic() {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  if (!apiKey) {
    console.error("API key not set. Please set ANTHROPIC_API_KEY in your environment.");
    return;
  }
  
  const client = new Anthropic({ apiKey });
  
  try {
    model_name = 'claude-3-7-sonnet-latest'
    console.log('Making API call with model:', model_name);
    const response = await client.messages.create({
      model: model_name,
      system: "You are a test assistant.",
      messages: [{ role: "user", content: "Hello, how are you?" }],
      max_tokens: config.maxTokens,
      temperature: config.temperature,
    });
    console.log("Anthropic API response:", response.content[0].text);
  } catch (error) {
    console.error("Test API call failed:", error.response ? error.response.data : error.message);
  }
}

testAnthropic();



================================================================================
# FILE: server\tests\ai.test.js
# EXTENSION: .js
================================================================================
const request = require('supertest');
const app = require('../app');
const { config } = require('../config/aiConfig');

describe('AI API Endpoints', () => {
  test('POST /api/ai/message', async () => {
    const response = await request(app)
      .post('/api/ai/message')
      .send({
        sessionId: 'test-session',
        message: 'How do I design a scalable system?',
        context: { topic: 'system design' }
      });

    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
    expect(response.body.response).toBeDefined();
  });

  test('POST /api/ai/analyze-diagram', async () => {
    const response = await request(app)
      .post('/api/ai/analyze-diagram')
      .send({
        sessionId: 'test-session',
        diagram: {
          nodes: [
            { id: '1', type: 'service', data: { label: 'API Gateway' } },
            { id: '2', type: 'database', data: { label: 'PostgreSQL' } }
          ],
          edges: [
            { id: 'e1-2', source: '1', target: '2' }
          ]
        }
      });

    expect(response.status).toBe(200);
    expect(response.body.success).toBe(true);
    expect(response.body.analysis).toBeDefined();
  });
});


================================================================================
# FILE: server\utils\dbHealth.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');
const logger = require('./logger');

class DatabaseHealthCheck {
  static async checkConnection() {
    try {
      const state = mongoose.connection.readyState;
      switch (state) {
        case 0:
          throw new Error('MongoDB disconnected');
        case 1:
          return true;
        case 2:
          logger.warn('MongoDB connecting');
          return true;
        case 3:
          throw new Error('MongoDB disconnecting');
        default:
          throw new Error('Unknown MongoDB state');
      }
    } catch (error) {
      logger.error('Database health check failed:', error);
      return false;
    }
  }

  static async ping() {
    try {
      await mongoose.connection.db.admin().ping();
      return true;
    } catch (error) {
      logger.error('Database ping failed:', error);
      return false;
    }
  }
}

module.exports = DatabaseHealthCheck;


================================================================================
# FILE: server\utils\logger.js
# EXTENSION: .js
================================================================================
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

module.exports = logger;



================================================================================
# FILE: tests\diagram.test.js
# EXTENSION: .js
================================================================================
describe('Diagram System', () => {
  test('DiagramManager creates valid diagrams', () => {
    // Test diagram creation
  });
  
  test('Mermaid conversion works correctly', () => {
    // Test mermaid conversion
  });
  
  test('ReactFlow integration functions properly', () => {
    // Test ReactFlow
  });
});


================================================================================
# SUMMARY
# Total files processed: 182
# Extraction completed: 2025-03-15 03:44:24
================================================================================
