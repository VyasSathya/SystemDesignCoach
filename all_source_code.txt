# CODE EXTRACTION - 2025-03-12 00:13:50

# PROJECT STRUCTURE
|-- client
|   |-- components
|   |   |-- coaching
|   |   |   +-- TopicGuidedCoaching.js
|   |   |       |-- module:TopicGuidedCoaching.js
|   |   |       |-- fn: TopicGuidedCoaching({ currentTopic, onSendMessage, onGetMaterials }) [internal]
|   |   |       |-- component:SYSTEM_DESIGN_TOPICS [internal]
|   |   |       |-- component:TopicGuidedCoaching [internal]
|   |   |-- diagram
|   |   |   |-- NodeTypes
|   |   |   |   |-- CacheNode.js
|   |   |   |   |   |-- module:CacheNode.js
|   |   |   |   |   |-- fn: CacheNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:CacheNode [internal]
|   |   |   |   |-- ClientNode.js
|   |   |   |   |   |-- module:ClientNode.js
|   |   |   |   |   |-- fn: ClientNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:ClientNode [internal]
|   |   |   |   |-- CustomNode.js
|   |   |   |   |   |-- module:CustomNode.js
|   |   |   |   |   |-- fn: CustomNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:CustomNode [internal]
|   |   |   |   |-- DatabaseNode.js
|   |   |   |   |   |-- module:DatabaseNode.js
|   |   |   |   |   |-- fn: DatabaseNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:DatabaseNode [internal]
|   |   |   |   |-- LoadBalancerNode.js
|   |   |   |   |   |-- module:LoadBalancerNode.js
|   |   |   |   |   |-- fn: LoadBalancerNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:LoadBalancerNode [internal]
|   |   |   |   |-- QueueNode.js
|   |   |   |   |   |-- module:QueueNode.js
|   |   |   |   |   |-- fn: QueueNode({ data, isConnectable }) [internal]
|   |   |   |   |   |-- component:QueueNode [internal]
|   |   |   |   +-- ServiceNode.js
|   |   |   |       |-- module:ServiceNode.js
|   |   |   |       |-- fn: ServiceNode({ data, isConnectable }) [internal]
|   |   |   |       |-- component:ServiceNode [internal]
|   |   |   |-- utils
|   |   |   |   |-- conversion.js
|   |   |   |   |   |-- module:conversion.js
|   |   |   |   |   |-- fn: getNodeType(mermaidNodeDef) [internal]
|   |   |   |   |   |-- fn: getNodeLabel(nodeText) [internal]
|   |   |   |   |   |-- fn: mermaidToReactFlow(mermaidCode) [exported]
|   |   |   |   |   |-- fn: reactFlowToMermaid({ nodes, edges }) [exported]
|   |   |   |   |   |-- method: forEach(edge => {
      const arrow = '-->'; // Use directed arrows
      
      if (edge.label)
|   |   |   |   |   |-- component:MERMAID_NODE_TYPES [internal]
|   |   |   |   +-- nodePresets.js
|   |   |   |       |-- module:nodePresets.js
|   |   |   |       |-- fn: createNode(type, position, label = '', notes = '') [exported]
|   |   |   |       |-- fn: createEdge(sourceId, targetId, label = '') [exported]
|   |   |   |       |-- fn: getNodeTypePalette() [exported]
|   |   |   |       |-- component:NODE_TYPES [exported]
|   |   |   |-- DiagramPanel.js
|   |   |   |   |-- module:DiagramPanel.js
|   |   |   |   |-- fn: DiagramPanel({
  hideModes = false,
  sessionId,
  sessionType = 'coaching',
  initialDiagram = null,
  onClose,
  onSave,
  onRefresh,
  onAiSuggest
}) [internal]
|   |   |   |   |-- fn: handleCustomRequest(e) [internal]
|   |   |   |   |-- fn: onDragStart(event, nodeType) [internal]
|   |   |   |   |-- fn: handleInsertNode(type) [internal]
|   |   |   |   |-- component:MermaidRenderer [internal]
|   |   |   |   |-- component:ReactFlowDiagramWithProvider [internal]
|   |   |   |   |-- component:DiagramPanel [internal]
|   |   |   |-- DiagramToolbar.js
|   |   |   |   |-- module:DiagramToolbar.js
|   |   |   |   |-- fn: DiagramToolbar() [internal]
|   |   |   |   |-- fn: onDragStart(event, nodeType) [internal]
|   |   |   |   |-- component:DiagramToolbar [internal]
|   |   |   |-- ElementTypeIndicator.js
|   |   |   |   |-- module:ElementTypeIndicator.js
|   |   |   |   |-- fn: ElementTypeIndicator({ type, size = 'md', showLabel = false, className = '' }) [internal]
|   |   |   |   |-- component:ElementTypeIndicator [internal]
|   |   |   |-- MermaidRenderer.js
|   |   |   |   |-- module:MermaidRenderer.js
|   |   |   |   |-- fn: MermaidRenderer({ code, onError }) [internal]
|   |   |   |   |-- fn: cleanup() [internal]
|   |   |   |   |-- component:MermaidRenderer [internal]
|   |   |   |-- ReactFlowDiagram.js
|   |   |   |   |-- module:ReactFlowDiagram.js
|   |   |   |   |-- fn: Flow({ 
  initialNodes, 
  initialEdges, 
  onNodesChange, 
  onEdgesChange, 
  onConnect,
  onDiagramUpdate 
}) [internal]
|   |   |   |   |-- fn: ReactFlowDiagramWithProvider(props) [internal]
|   |   |   |   |-- method: map(n => {
      if (n.id === selectedNode.id)
|   |   |   |   |-- component:Flow [internal]
|   |   |   |   |-- component:ReactFlowDiagramWithProvider [internal]
|   |   |   +-- SequenceDiagram.js
|   |   |       |-- module:SequenceDiagram.js
|   |   |       |-- fn: generateMermaidCode(nodes, edges) [internal]
|   |   |       |-- fn: return() [internal]
|   |   |       |-- fn: MessageEdge({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  data,
  style = {},
}) [internal]
|   |   |       |-- fn: SequenceDiagram({ initialDiagram, onDiagramUpdate }) [internal]
|   |   |       |-- fn: SequenceDiagramWrapped(props) [internal]
|   |   |       |-- method: generateMermaidCode(nodes, edges)
|   |   |       |-- method: forEach(participant => {
    if (participant.type === 'actor')
|   |   |       |-- component:ActorNode [internal]
|   |   |       |-- component:ParticipantNode [internal]
|   |   |       |-- component:LifelineNode [internal]
|   |   |       |-- component:MessageEdge [internal]
|   |   |       |-- component:SequenceDiagram [internal]
|   |   |       |-- component:SequenceDiagramWrapped [internal]
|   |   |-- evaluation
|   |   |   +-- EvaluationSummary.js
|   |   |       |-- module:EvaluationSummary.js
|   |   |       |-- fn: EvaluationSummary({ evaluation, scores }) [internal]
|   |   |       |-- fn: getScoreColor(score) [internal]
|   |   |       |-- component:EvaluationSummary [internal]
|   |   |-- CoachAgentInterface.js
|   |   |   |-- module:CoachAgentInterface.js
|   |   |   |-- fn: CoachAgentInterface({ isOpen, onClose, currentPage, currentData }) [internal]
|   |   |   |-- component:CoachAgentInterface [internal]
|   |   |-- ConciseModeToggle.js
|   |   |   |-- module:ConciseModeToggle.js
|   |   |   |-- fn: ConciseModeToggle({ isEnabled, onToggle }) [internal]
|   |   |   |-- fn: handleToggle(enabled) [internal]
|   |   |   |-- component:ConciseModeToggle [internal]
|   |   |-- ExperienceLevelSelector.js
|   |   |   |-- module:ExperienceLevelSelector.js
|   |   |   |-- fn: ExperienceLevelSelector({ currentLevel, onLevelChange }) [internal]
|   |   |   |-- component:ExperienceLevelSelector [internal]
|   |   |-- MermaidToolbar.js
|   |   |   |-- module:MermaidToolbar.js
|   |   |   |-- fn: ComponentButton({ icon, label, snippet, onInsert }) [internal]
|   |   |   |-- fn: MermaidToolbar({ onInsert }) [internal]
|   |   |   |-- component:ComponentButton [internal]
|   |   |   |-- component:MermaidToolbar [internal]
|   |   |-- MetricCard.js
|   |   |   |-- module:MetricCard.js
|   |   |   |-- fn: MetricCard({ title, value, icon, iconBgColor, progress, subtext }) [internal]
|   |   |   |-- component:MetricCard [internal]
|   |   |-- Sidebar.js
|   |   |   |-- module:Sidebar.js
|   |   |   |-- fn: Sidebar({ activeTab }) [internal]
|   |   |   |-- component:Sidebar [internal]
|   |   |-- SimpleFlow.js
|   |   |   |-- module:SimpleFlow.js
|   |   |   |-- fn: Flow() [internal]
|   |   |   |-- fn: SimpleFlowWithProvider() [internal]
|   |   |   |-- method: Flow()
|   |   |   |-- method: SimpleFlowWithProvider()
|   |   |   |-- component:Flow [internal]
|   |   |   |-- component:SimpleFlowWithProvider [exported]
|   |   +-- SystemDesignDiagram.tsx
|   |       |-- module:SystemDesignDiagram.tsx
|   |-- contexts
|   |   +-- AuthContext.js
|   |       |-- module:AuthContext.js
|   |       |-- fn: AuthProvider({ children }) [exported]
|   |       |-- fn: logout() [internal]
|   |       |-- fn: useAuth() [exported]
|   |       |-- component:AuthContext [internal]
|   |       |-- component:AuthProvider [exported]
|   |-- pages
|   |   |-- auth
|   |   |   |-- login.js
|   |   |   |   |-- module:login.js
|   |   |   |   |-- fn: Login() [internal]
|   |   |   |   |-- method: Login()
|   |   |   |   |-- component:Login [exported]
|   |   |   +-- register.js
|   |   |       |-- module:register.js
|   |   |       |-- fn: Register() [internal]
|   |   |       |-- method: Register()
|   |   |       |-- component:Register [exported]
|   |   |-- coaching
|   |   |   |-- [id].js
|   |   |   |   |-- module:[id].js
|   |   |   |   |-- fn: handleClickOutside(event) [internal]
|   |   |   |   |-- fn: CoachingSessionPage() [internal]
|   |   |   |   |-- fn: setActiveDiagramTab(tabId) [internal]
|   |   |   |   |-- fn: updateFormData(section, data) [internal]
|   |   |   |   |-- fn: detectCurrentTopic(conversation) [internal]
|   |   |   |   |-- fn: handleDiagramSuggestions(suggestions) [internal]
|   |   |   |   |-- fn: handleAcceptSuggestions() [internal]
|   |   |   |   |-- fn: handleDiscardSuggestions() [internal]
|   |   |   |   |-- fn: handleDiagramUpdate(diagramData) [internal]
|   |   |   |   |-- fn: renderDiagramEditor() [internal]
|   |   |   |   |-- fn: getActiveWorkbookComponent() [internal]
|   |   |   |   |-- method: handleClickOutside(event)
|   |   |   |   |-- method: code({ node, inline, className, children, ...props })
|   |   |   |   |-- component:MermaidRenderer [internal]
|   |   |   |   |-- component:ReactFlowDiagramWithProvider [internal]
|   |   |   |   |-- component:SequenceDiagram [internal]
|   |   |   |   |-- component:CoachingSessionPage [internal]
|   |   |   +-- index.js
|   |   |       |-- module:index.js
|   |   |       |-- fn: CoachingIndexPage() [internal]
|   |   |       |-- method: CoachingIndexPage()
|   |   |       |-- component:CoachingIndexPage [exported]
|   |   |-- interviews
|   |   |   |-- results
|   |   |   |   +-- [id].js
|   |   |   |       |-- module:[id].js
|   |   |   |       |-- fn: InterviewResultsPage() [internal]
|   |   |   |       |-- fn: getScoreColor(score) [internal]
|   |   |   |       |-- fn: getScoreIcon(score) [internal]
|   |   |   |       |-- method: InterviewResultsPage()
|   |   |   |       |-- component:InterviewResultsPage [exported]
|   |   |   |-- [id].js
|   |   |   |   |-- module:[id].js
|   |   |   |   |-- fn: InterviewPage() [internal]
|   |   |   |   |-- fn: updateTimeRemaining() [internal]
|   |   |   |   |-- fn: formatTime(ms) [internal]
|   |   |   |   |-- method: InterviewPage()
|   |   |   |   |-- component:InterviewPage [exported]
|   |   |   +-- index.js
|   |   |       |-- module:index.js
|   |   |       |-- fn: InterviewsPage() [internal]
|   |   |       |-- fn: openProblemDetails(problem) [internal]
|   |   |       |-- fn: closeProblemDetails() [internal]
|   |   |       |-- method: InterviewsPage()
|   |   |       |-- component:InterviewsPage [exported]
|   |   |-- _app.js
|   |   |   |-- module:_app.js
|   |   |   |-- fn: MyApp({ Component, pageProps }) [exported]
|   |   |   |-- method: MyApp({ Component, pageProps })
|   |   |-- APIDesignPage.js
|   |   |   |-- module:APIDesignPage.js
|   |   |   |-- fn: APIDesignPage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: handleChange(e) [internal]
|   |   |   |-- component:APIDesignPage [internal]
|   |   |-- dashboard.js
|   |   |   |-- module:dashboard.js
|   |   |   |-- fn: Dashboard({ onSelectWorkbook }) [internal]
|   |   |   |-- method: Dashboard({ onSelectWorkbook })
|   |   |   |-- component:Dashboard [exported]
|   |   |-- DataModelPage.js
|   |   |   |-- module:DataModelPage.js
|   |   |   |-- fn: DataModelPage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: handleChange(e) [internal]
|   |   |   |-- component:DataModelPage [internal]
|   |   |-- index.js
|   |   |   |-- module:index.js
|   |   |   |-- fn: Home() [internal]
|   |   |   |-- method: Home()
|   |   |   |-- component:Home [exported]
|   |   |-- ReliabilitySecurityPage.js
|   |   |   |-- module:ReliabilitySecurityPage.js
|   |   |   |-- fn: ReliabilitySecurityPage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: handleChange(e) [internal]
|   |   |   |-- component:ReliabilitySecurityPage [internal]
|   |   |-- RequirementsPage.js
|   |   |   |-- module:RequirementsPage.js
|   |   |   |-- fn: RequirementsPage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: handleChange(e) [internal]
|   |   |   |-- component:RequirementsPage [internal]
|   |   |-- ScalingStrategyPage.js
|   |   |   |-- module:ScalingStrategyPage.js
|   |   |   |-- fn: ScalingStrategyPage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: handleChange(e) [internal]
|   |   |   |-- component:ScalingStrategyPage [internal]
|   |   |-- SystemArchitecturePage.js
|   |   |   |-- module:SystemArchitecturePage.js
|   |   |   |-- fn: SystemArchitecturePage({ data = {}, updateData }) [internal]
|   |   |   |-- fn: handleChange(e) [internal]
|   |   |   |-- component:SystemArchitecturePage [internal]
|   |   |-- test-flow.js
|   |   |   |-- module:test-flow.js
|   |   |   |-- fn: TestPage() [internal]
|   |   |   |-- method: TestPage()
|   |   |   |-- component:SimpleFlow [internal]
|   |   |   |-- component:TestPage [exported]
|   |   +-- WorkbookLayout.js
|   |       |-- module:WorkbookLayout.js
|   |       |-- fn: RequirementsPage() [internal]
|   |       |-- fn: APIDesignPage() [internal]
|   |       |-- fn: DataModelPage() [internal]
|   |       |-- fn: SystemArchitecturePage() [internal]
|   |       |-- fn: ScalingStrategyPage() [internal]
|   |       |-- fn: ReliabilitySecurityPage() [internal]
|   |       |-- fn: CoachAgentInterface({ isOpen, onClose, currentPage, currentData }) [internal]
|   |       |-- fn: WorkbookLayout({ onBack, sessionId }) [internal]
|   |       |-- fn: updateFormData(section, data) [internal]
|   |       |-- fn: getActivePageComponent() [internal]
|   |       |-- component:RequirementsPage [internal]
|   |       |-- component:APIDesignPage [internal]
|   |       |-- component:DataModelPage [internal]
|   |       |-- component:SystemArchitecturePage [internal]
|   |       |-- component:ScalingStrategyPage [internal]
|   |       |-- component:ReliabilitySecurityPage [internal]
|   |       |-- component:CoachAgentInterface [internal]
|   |       |-- component:WorkbookLayout [internal]
|   |-- public
|   |-- styles
|   |-- utils
|   |   +-- api.js
|   |       |-- module:api.js
|   |-- next.config.js
|   |   |-- module:next.config.js
|   |   |-- method: rewrites()
|   |-- postcss.config.js
|   |   |-- module:postcss.config.js
|   +-- tailwind.config.js
|       |-- module:tailwind.config.js
|-- data
|   |-- knowledge_base
|   |   +-- facebook
|   |       |-- architecture
|   |       |   +-- core_tech.md
|   |       |-- design_questions
|   |       |   |-- messenger.md
|   |       |   |-- news_feed.md
|   |       |   +-- photo_storage.md
|   |       |-- evaluation_criteria
|   |       |   +-- scoring_rubric.md
|   |       +-- interview_format
|   |           +-- standard_progression.md
|   |-- persona
|   |   |-- coachPersona.js
|   |   |   |-- module:coachPersona.js
|   |   |-- graderPersona.js
|   |   |   |-- module:graderPersona.js
|   |   +-- interviewerPersona.js
|   |       |-- module:interviewerPersona.js
|   |-- tempresults
|   |   +-- 1
|   +-- problems.js
|       |-- module:problems.js
|-- server
|   |-- __pycache__
|   |-- config
|   |   +-- aiConfig.js
|   |       |-- module:aiConfig.js
|   |-- models
|   |   |-- Evaluation.js
|   |   |   |-- module:Evaluation.js
|   |   |-- Interview.js
|   |   |   |-- module:Interview.js
|   |   |-- Problem.js
|   |   |   |-- module:Problem.js
|   |   |   |-- method: get(function()
|   |   |   |-- method: pre('save', function(next)
|   |   |-- Session.js
|   |   |   |-- module:Session.js
|   |   |   |-- method: get(function()
|   |   |   |-- method: pre('save', function(next)
|   |   +-- User.js
|   |       |-- module:User.js
|   |       |-- method: pre('save', async function(next)
|   |-- routes
|   |   |-- auth.js
|   |   |   |-- module:auth.js
|   |   |-- coaching.js
|   |   |   |-- module:coaching.js
|   |   |-- grader.js
|   |   |   |-- module:grader.js
|   |   |-- interviews.js
|   |   |   |-- module:interviews.js
|   |   |   |-- fn: handleError(res, error, defaultMessage = 'An unexpected error occurred') [internal]
|   |   |-- problems.js
|   |   |   |-- module:problems.js
|   |   |   |-- fn: loadProblems() [internal]
|   |   |   |-- method: loadProblems()
|   |   |-- sessions.js
|   |   |   |-- module:sessions.js
|   |   +-- users.js
|   |       |-- module:users.js
|   |-- scripts
|   |   |-- seedProblems.js
|   |   |   |-- fn: seedDatabase() [internal]
|   |   |   |-- method: seedDatabase()
|   |   +-- setupDatabase.js
|   |       |-- fn: setupDatabase() [internal]
|   |       |-- method: setupDatabase()
|   |-- services
|   |   |-- ai
|   |   |   |-- base
|   |   |   |   +-- AIService.js
|   |   |   |       |-- module:AIService.js
|   |   |   |       |-- class:AIService [internal]
|   |   |   |       |-- method: sendMessage(messages, options = {})
|   |   |   |       |-- method: generateResponse(messages, context, options = {})
|   |   |   |       |-- method: generateContent(prompt, options = {})
|   |   |   |-- prompts
|   |   |   |   +-- grader.js
|   |   |   |       |-- module:grader.js
|   |   |   |-- aiFactory.js
|   |   |   |   |-- module:aiFactory.js
|   |   |   |   |-- class:AIFactory [internal]
|   |   |   |   |-- method: createService(provider, config = {})
|   |   |   |-- claudeService.js
|   |   |   |   |-- module:claudeService.js
|   |   |   |   |-- class:ClaudeService extends AIService [internal]
|   |   |   |   |-- method: constructor(config = {})
|   |   |   |   |-- method: sendMessage(messages, options = {})
|   |   |   |   |-- method: generateContent(prompt, options = {})
|   |   |   +-- index.js
|   |   |       |-- module:index.js
|   |   |-- diagram
|   |   |   +-- diagramService.js
|   |   |       |-- module:diagramService.js
|   |   |       |-- fn: extractMermaidCode(text) [internal]
|   |   |       |-- fn: getPromptForDiagramType(diagramType, title, customPrompt) [internal]
|   |   |       |-- method: extractMermaidCode(text)
|   |   |       |-- method: getPromptForDiagramType(diagramType, title, customPrompt)
|   |   |-- engines
|   |   |   |-- baseEngine.js
|   |   |   |   |-- module:baseEngine.js
|   |   |   |   |-- class:BaseEngine [internal]
|   |   |   |   |-- method: constructor(engineConfig = {})
|   |   |   |   |-- method: processMessage(sessionId, message, options = {})
|   |   |   |   |-- method: startSession(userId, contentId, options = {})
|   |   |   |   |-- method: generateContent(sessionId, contentType, options = {})
|   |   |   |-- coachEngine.js
|   |   |   |   |-- module:coachEngine.js
|   |   |   |   |-- class:CoachEngine extends BaseEngine [internal]
|   |   |   |   |-- method: constructor(config = {})
|   |   |   |   |-- method: processMessage(sessionId, message, options = {})
|   |   |   |   |-- method: startSession(userId, problemId, options = {})
|   |   |   |   |-- method: generateContent(sessionId, topic, options = {})
|   |   |   |-- graderEngine.js
|   |   |   |   |-- module:graderEngine.js
|   |   |   |   |-- class:GraderEngine extends BaseEngine [internal]
|   |   |   |   |-- method: constructor(config = {})
|   |   |   |   |-- method: evaluateWorkbook(sessionId, workbookContent, options = {})
|   |   |   |   |-- method: _extractScores(evaluationText)
|   |   |   |   |-- method: provideFinalAssessment(interviewId, options = {})
|   |   |   |   |-- method: _buildGraderPrompt(context)
|   |   |   |   |-- method: _getDefaultGraderPrompt(context = {})
|   |   |   |-- interviewEngine.js
|   |   |   |   |-- module:interviewEngine.js
|   |   |   |   |-- class:InterviewEngine extends BaseEngine [internal]
|   |   |   |   |-- method: constructor(config = {})
|   |   |   |   |-- method: startInterview(userId, problemId, options = {})
|   |   |   |   |-- method: generateContent(sessionId, contentType, options = {})
|   |   |   |   |-- method: generateDiagram(sessionId, options = {})
|   |   |   |   |-- method: processResponse(interviewId, message, options = {})
|   |   |   |   |-- method: finalizeInterview(interview)
|   |   |   |   |-- method: _extractEntities(messages, currentStage)
|   |   |   |   |-- method: _shouldAdvanceStage(conversation, currentStage, messageCount)
|   |   |   |   |-- method: _getNextStage(currentStage)
|   |   |   |   |-- component:BaseEngine [internal]
|   |   |   |   |-- component:Interview [internal]
|   |   |   |   |-- component:Problem [internal]
|   |   |   +-- PersonaService.js
|   |   |       |-- module:PersonaService.js
|   |   |       |-- class:PersonaService [internal]
|   |   |       |-- method: constructor()
|   |   |       |-- method: initialize(config)
|   |   |       |-- method: forEach(requiredId => {
      if (!this.personas[requiredId])
|   |   |       |-- method: setActivePersona(personaId)
|   |   |       |-- method: setConciseMode(enabled)
|   |   |       |-- method: getActivePersona()
|   |   |       |-- method: getPersona(personaId)
|   |   |       |-- method: getPageSuggestions(pageId)
|   |   |       |-- method: getSystemPrompt(context = {})
|   |   |       |-- method: formatResponse(patternKey, variables = {})
|   |   |       |-- method: getAllPersonas()
|   |   |-- evaluation
|   |   |   +-- evaluationParser.js
|   |   |-- knowledge
|   |   |   |-- knowledgeService.js
|   |   |   |   |-- module:knowledgeService.js
|   |   |   |   |-- class:KnowledgeService [internal]
|   |   |   |   |-- method: constructor()
|   |   |   |   |-- method: initialize()
|   |   |   |   |-- method: queryKnowledge(query, company = 'facebook')
|   |   |   |   |-- method: _executeCommand(command, params = {})
|   |   |   |   |-- method: _getPythonScript()
|   |   |   +-- vector_store.py
|   |   |       |-- fn: initialize_vector_store() [public]
|   |   |       |-- fn: query_knowledge(query, company="facebook") [public]
|   |   +-- utils
|   |       +-- diagramUtils.js
|   |           |-- module:diagramUtils.js
|   |           |-- fn: getDiagramTypeForStage(currentStage) [internal]
|   |           |-- fn: generateSvgDiagram(entities, diagramType, title) [internal]
|   |           |-- fn: generateArchitectureDiagram(entities, title) [internal]
|   |           |-- fn: generateErDiagram(entities, title) [internal]
|   |           |-- fn: generateApiDiagram(entities, title) [internal]
|   |           |-- method: getDiagramTypeForStage(currentStage)
|   |           |-- method: generateSvgDiagram(entities, diagramType, title)
|   |           |-- method: generateArchitectureDiagram(entities, title)
|   |           |-- method: generateErDiagram(entities, title)
|   |           |-- method: generateApiDiagram(entities, title)
|   |-- utils
|   |-- config.py
|   |-- index.js
|   |   |-- module:index.js
|   |-- requirements.txt
|   |-- run.py
|   |   |-- fn: health_check() [public]
|   |   |-- fn: login() [public]
|   |   |-- fn: get_me() [public]
|   |   |-- fn: coaching_problems() [public]
|   |   |-- fn: start_coaching_session(problemId) [public]
|   +-- testAnthropic.js
|       |-- fn: testAnthropic() [internal]
|       |-- method: testAnthropic()
|-- advanced_tree_structure.txt
|-- all_source_code.txt
|-- folders.txt
|-- js_files.txt
|-- md_files.txt
|-- project_overview.txt
|-- README.md
|-- sysdesignsummarydata.txt
+-- tree_structure.txt



================================================================================
# FILE: client\components\CoachAgentInterface.js
# EXTENSION: .js
================================================================================
// client/components/CoachAgentInterface.js
import React, { useState, useRef, useEffect } from 'react';
import { MessageSquare, Send, X, User, Bot } from 'lucide-react';
// Import PersonaService – ensure you have a client-accessible copy or proxy if needed.
import PersonaService from '../../server/services/engines/PersonaService';

const CoachAgentInterface = ({ isOpen, onClose, currentPage, currentData }) => {
  const [messages, setMessages] = useState([
    {
      id: 1,
      role: 'assistant',
      content: "Hi! I'm your System Design Coach. What questions do you have about your design?",
      timestamp: new Date()
    }
  ]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const messagesEndRef = useRef(null);
  const inputRef = useRef(null);

  // Auto-scroll on new messages
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  // Focus input when opened
  useEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isOpen]);

  // Build a combined context by merging page-specific details with the active persona's system prompt.
  const getCoachContext = async () => {
    // Base context for the page
    const baseContext = {
      systemPrompt:
        currentPage === 'requirements'
          ? `Current user data: ${JSON.stringify(currentData)}.
Provide guidance on clarifying both functional and non-functional requirements.`
          : `Provide general system design guidance.`,
      suggestions:
        currentPage === 'requirements'
          ? [
              'What user scenarios should I consider?',
              'How do I estimate scale requirements?',
              'What availability is typical for this system?'
            ]
          : ['How can I improve my design?', 'What should I focus on next?']
    };

    // Get the active persona’s system prompt from PersonaService.
    const personaPrompt = PersonaService.getSystemPrompt({
      currentPage,
      designData: currentData
    });

    return {
      systemPrompt: `${personaPrompt}\n${baseContext.systemPrompt}`,
      suggestions: [
        ...(PersonaService.getActivePersona().suggestions || []),
        ...baseContext.suggestions
      ]
    };
  };

  const handleSendMessage = async () => {
    if (!input.trim()) return;
    const userMessage = {
      id: Date.now(),
      role: 'user',
      content: input,
      timestamp: new Date()
    };
    setMessages((prev) => [...prev, userMessage]);
    setInput('');
    setLoading(true);

    // Retrieve the combined context for building the AI prompt.
    const context = await getCoachContext();

    // In production, forward { message: input, systemPrompt: context.systemPrompt } to your backend.
    // For demonstration, we simulate an AI response based on keywords.
    setTimeout(() => {
      let response;
      if (input.toLowerCase().includes('bottleneck') || input.toLowerCase().includes('scale')) {
        response =
          'Focus on your high-traffic components; consider caching and horizontal scaling.';
      } else if (input.toLowerCase().includes('security')) {
        response =
          'Ensure you have proper authentication (e.g., JWT) and secure communications (HTTPS).';
      } else {
        response =
          'I suggest refining your service boundaries and improving inter-component communication.';
      }
      const coachMessage = {
        id: Date.now(),
        role: 'assistant',
        content: response,
        timestamp: new Date()
      };
      setMessages((prev) => [...prev, coachMessage]);
      setLoading(false);
    }, 1500);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-2xl h-3/4 flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200">
          <div className="flex items-center">
            <MessageSquare className="h-5 w-5 text-indigo-600 mr-2" />
            <h2 className="text-lg font-semibold">System Design Coach</h2>
            <span className="ml-2 px-2 py-0.5 bg-indigo-100 text-indigo-800 text-xs rounded-full">
              {currentPage?.charAt(0).toUpperCase() + currentPage?.slice(1)} Mode
            </span>
          </div>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
            <X className="h-5 w-5" />
          </button>
        </div>

        {/* Messages */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {messages.map((msg) => (
            <div
              key={msg.id}
              className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
            >
              <div
                className={`px-4 py-3 rounded-lg max-w-3/4 flex items-start ${
                  msg.role === 'user'
                    ? 'bg-indigo-600 text-white'
                    : 'bg-gray-100 text-gray-800'
                }`}
              >
                {msg.role === 'user' ? (
                  <User className="h-5 w-5 mr-2" />
                ) : (
                  <Bot className="h-5 w-5 mr-2" />
                )}
                <div>
                  <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                  <span className="text-xs opacity-75 block mt-1">
                    {msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                  </span>
                </div>
              </div>
            </div>
          ))}
          {loading && (
            <div className="flex justify-start">
              <div className="px-4 py-3 rounded-lg bg-gray-100 text-gray-800">
                <div className="flex items-center space-x-2">
                  <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce"></div>
                  <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                  <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style={{ animationDelay: '0.4s' }}></div>
                </div>
              </div>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>

        {/* Suggestions (optional: you can render context.suggestions here) */}
        <div className="px-4 py-2 border-t border-gray-200 bg-gray-50">
          <p className="text-xs text-gray-500 mb-1">Suggested questions:</p>
          <div className="flex flex-wrap gap-2">
            {/*
              If you want to display suggestions dynamically, you can call getCoachContext
              and store the suggestions in state.
            */}
          </div>
        </div>

        {/* Input */}
        <div className="px-4 py-3 border-t border-gray-200">
          <div className="flex">
            <input
              ref={inputRef}
              type="text"
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={(e) => e.key === 'Enter' && handleSendMessage()}
              placeholder="Ask the coach about your design..."
              className="flex-1 px-4 py-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
            />
            <button
              onClick={handleSendMessage}
              disabled={loading || !input.trim()}
              className="px-4 py-2 bg-indigo-600 text-white rounded-r-md hover:bg-indigo-700 disabled:bg-indigo-300 disabled:cursor-not-allowed"
            >
              <Send className="h-5 w-5" />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default CoachAgentInterface;



================================================================================
# FILE: client\components\coaching\TopicGuidedCoaching.js
# EXTENSION: .js
================================================================================
// client/components/coaching/TopicGuidedCoaching.js
import React, { useState, useEffect } from 'react';
import { Book, ArrowRight } from 'lucide-react';

const SYSTEM_DESIGN_TOPICS = {
  REQUIREMENTS: {
    title: 'Requirements Clarification',
    questions: [
      'What specific features are required?',
      'What scale are we designing for?',
      'What are the performance requirements?',
      'What are the security considerations?',
      'Are there any compliance requirements?'
    ],
    hints: [
      'Consider functional and non-functional requirements',
      'Quantify scale with specific metrics (QPS, DAU, etc.)',
      'Think about latency, throughput, and availability'
    ]
  },
  
  ARCHITECTURE: {
    title: 'System Architecture',
    questions: [
      'What are the core components needed?',
      'How will these components interact?',
      'What APIs will be required between components?',
      'Should we use a monolithic or microservice approach?'
    ],
    hints: [
      'Draw out the high-level architecture',
      'Consider separation of concerns',
      'Think about interfaces between systems'
    ]
  },
  
  STORAGE: {
    title: 'Data Storage',
    questions: [
      'What data needs to be stored?',
      'What is the schema design?',
      'Should we use SQL or NoSQL?',
      'What are the read/write patterns?',
      'Do we need caching?'
    ],
    hints: [
      'Consider the data access patterns',
      'Think about indexing strategies',
      'Consider eventual vs. strong consistency'
    ]
  },
  
  SCALABILITY: {
    title: 'Scaling Strategy',
    questions: [
      'What components need to scale?',
      'Should we scale horizontally or vertically?',
      'How will we handle database scaling?',
      'What are potential bottlenecks?'
    ],
    hints: [
      'Consider load balancing strategies',
      'Think about database sharding approaches',
      'Consider stateless vs. stateful services'
    ]
  },
  
  RELIABILITY: {
    title: 'Reliability & Fault Tolerance',
    questions: [
      'How will the system handle failures?',
      'What redundancy is needed?',
      'How will we monitor the system?',
      'What is our disaster recovery plan?'
    ],
    hints: [
      'Consider single points of failure',
      'Think about data replication strategies',
      'Consider circuit breaker patterns'
    ]
  }
};

const TopicGuidedCoaching = ({ currentTopic, onSendMessage, onGetMaterials }) => {
  const [activeTopic, setActiveTopic] = useState(null);
  
  useEffect(() => {
    // Set active topic based on current conversation or context
    if (currentTopic && SYSTEM_DESIGN_TOPICS[currentTopic]) {
      setActiveTopic(currentTopic);
    } else {
      // Default to requirements if no topic is active
      setActiveTopic('REQUIREMENTS');
    }
  }, [currentTopic]);
  
  if (!activeTopic) return null;
  
  const topic = SYSTEM_DESIGN_TOPICS[activeTopic];
  
  return (
    <div className="bg-white border border-gray-200 rounded-lg p-4 mb-4">
      <div className="flex justify-between items-center mb-3">
        <h3 className="font-medium text-gray-900">{topic.title}</h3>
        <button 
          onClick={() => onGetMaterials(activeTopic.toLowerCase())}
          className="text-xs bg-green-50 text-green-700 px-2 py-1 rounded border border-green-200 flex items-center"
        >
          <Book className="h-3 w-3 mr-1" />
          Learn more
        </button>
      </div>
      
      <div className="space-y-2 mb-4">
        <p className="text-sm text-gray-600 font-medium">Key Questions:</p>
        <ul className="space-y-1">
          {topic.questions.map((question, index) => (
            <li key={index} className="flex items-start">
              <button
                onClick={() => onSendMessage(question)}
                className="text-sm text-blue-600 hover:text-blue-800"
              >
                <ArrowRight className="h-3 w-3 inline mr-1 text-blue-500" />
                {question}
              </button>
            </li>
          ))}
        </ul>
      </div>
      
      {topic.hints.length > 0 && (
        <div className="bg-yellow-50 p-3 rounded border border-yellow-200">
          <p className="text-xs text-yellow-800 font-medium mb-1">Hints:</p>
          <ul className="text-xs text-yellow-700 space-y-1">
            {topic.hints.map((hint, index) => (
              <li key={index}>• {hint}</li>
            ))}
          </ul>
        </div>
      )}
      
      <div className="mt-4 flex justify-between">
        {Object.keys(SYSTEM_DESIGN_TOPICS).map((topicKey) => (
          <button
            key={topicKey}
            onClick={() => setActiveTopic(topicKey)}
            className={`text-xs px-2 py-1 rounded ${
              activeTopic === topicKey
                ? 'bg-blue-600 text-white'
                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
          >
            {SYSTEM_DESIGN_TOPICS[topicKey].title.split(' ')[0]}
          </button>
        ))}
      </div>
    </div>
  );
};

export default TopicGuidedCoaching;


================================================================================
# FILE: client\components\ConciseModeToggle.js
# EXTENSION: .js
================================================================================
// client/components/ConciseModeToggle.js
import React from 'react';
import { MessageSquare } from 'lucide-react';
import PersonaService from '../../server/services/engines/PersonaService';

const ConciseModeToggle = ({ isEnabled, onToggle }) => {
  const handleToggle = (enabled) => {
    // Update the concise mode flag in PersonaService
    PersonaService.setConciseMode(enabled);
    if (onToggle) onToggle(enabled);
  };

  return (
    <div className="flex items-center">
      <span className="mr-2 text-sm text-gray-600">Concise Mode</span>
      <label className="relative inline-flex items-center cursor-pointer">
        <input
          type="checkbox"
          className="sr-only peer"
          checked={isEnabled}
          onChange={(e) => handleToggle(e.target.checked)}
        />
        <div className="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:bg-indigo-600 peer-focus:ring-4 peer-focus:ring-indigo-300 after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:after:translate-x-full"></div>
      </label>
      <MessageSquare size={16} className="ml-2 text-gray-600" />
    </div>
  );
};

export default ConciseModeToggle;



================================================================================
# FILE: client\components\diagram\DiagramPanel.js
# EXTENSION: .js
================================================================================
// client/components/diagram/DiagramPanel.js
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { applyNodeChanges, applyEdgeChanges, addEdge } from 'reactflow';
import { X, Download, RefreshCw, MessageSquare, Code, Eye, Edit, Undo, Redo, Save, Database, Server, Globe, Archive, Grid, Share2, Box } from 'lucide-react';
import { mermaidToReactFlow, reactFlowToMermaid } from './utils/conversion';
import dynamic from 'next/dynamic';

const MermaidRenderer = dynamic(() => import('./MermaidRenderer'), { ssr: false });
const ReactFlowDiagramWithProvider = dynamic(() => import('./ReactFlowDiagram'), { ssr: false });

const DiagramPanel = ({
  hideModes = false,
  sessionId,
  sessionType = 'coaching',
  initialDiagram = null,
  onClose,
  onSave,
  onRefresh,
  onAiSuggest
}) => {
  // When hideModes is true, force viewMode to 'edit' and don't allow changing it
  const [viewMode, setViewMode] = useState('edit');
  
  // Always force edit mode when hideModes is true
  useEffect(() => {
    if (hideModes) {
      setViewMode('edit');
    }
  }, [hideModes]);

  const [mermaidCode, setMermaidCode] = useState(
    initialDiagram?.mermaidCode ||
    'graph TD\n    Client[Client] --> API[API Gateway]\n    API --> Service[Service]\n    Service --> DB[(Database)]'
  );
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [customRequest, setCustomRequest] = useState('');
  const [showCustomForm, setShowCustomForm] = useState(false);
  const [error, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const initializedRef = useRef(false);

  // Initialize from mermaid code only once
  useEffect(() => {
    if (initialDiagram && !initializedRef.current) {
      try {
        const code = initialDiagram.mermaidCode;
        setMermaidCode(code);
        const { nodes: convertedNodes, edges: convertedEdges } = mermaidToReactFlow(code);
        setNodes(convertedNodes);
        setEdges(convertedEdges);
        setHistory([{ mermaidCode: code, nodes: convertedNodes, edges: convertedEdges }]);
        setHistoryIndex(0);
        setError(null);
        initializedRef.current = true;
      } catch (err) {
        console.error('Error converting Mermaid to React Flow:', err);
        setError('Failed to initialize diagram: ' + err.message);
      }
    }
  }, [initialDiagram]);

  // Only initialize if nodes/edges are still empty and not already initialized
  useEffect(() => {
    if (!initializedRef.current && nodes.length === 0 && edges.length === 0 && mermaidCode) {
      try {
        const { nodes: convertedNodes, edges: convertedEdges } = mermaidToReactFlow(mermaidCode);
        setNodes(convertedNodes);
        setEdges(convertedEdges);
        
        if (history.length === 0) {
          setHistory([{ 
            mermaidCode, 
            nodes: convertedNodes, 
            edges: convertedEdges 
          }]);
          setHistoryIndex(0);
        }
        initializedRef.current = true;
      } catch (err) {
        console.error('Error initializing diagram:', err);
      }
    }
  }, [mermaidCode, nodes.length, edges.length, history.length]);

  const onNodesChange = useCallback((changes) => {
    setNodes((nds) => {
      const updatedNodes = applyNodeChanges(changes, nds);
      // Only update if the change is significant
      if (changes.some(change => change.type !== 'select' && change.type !== 'position')) {
        try {
          const newMermaidCode = reactFlowToMermaid({ nodes: updatedNodes, edges });
          // Only update if new code is actually different
          if (newMermaidCode !== mermaidCode) {
            setMermaidCode(newMermaidCode);
            const newState = { mermaidCode: newMermaidCode, nodes: updatedNodes, edges: JSON.parse(JSON.stringify(edges)) };
            setHistory(prev => [...prev.slice(0, historyIndex + 1), newState]);
            setHistoryIndex(prevIndex => prevIndex + 1);
          }
        } catch (err) {
          console.error('Error updating Mermaid from nodes:', err);
        }
      }
      return updatedNodes;
    });
  }, [edges, historyIndex, mermaidCode]);

  const onEdgesChange = useCallback((changes) => {
    setEdges((eds) => {
      const updatedEdges = applyEdgeChanges(changes, eds);
      if (changes.length > 0) {
        try {
          const newMermaidCode = reactFlowToMermaid({ nodes, edges: updatedEdges });
          if (newMermaidCode !== mermaidCode) {
            setMermaidCode(newMermaidCode);
            const newState = { mermaidCode: newMermaidCode, nodes: JSON.parse(JSON.stringify(nodes)), edges: JSON.parse(JSON.stringify(updatedEdges)) };
            setHistory(prev => [...prev.slice(0, historyIndex + 1), newState]);
            setHistoryIndex(prevIndex => prevIndex + 1);
          }
        } catch (err) {
          console.error('Error updating Mermaid from edges:', err);
        }
      }
      return updatedEdges;
    });
  }, [nodes, historyIndex, mermaidCode]);

  const onConnect = useCallback((connection) => {
    const newEdge = {
      ...connection,
      id: `edge-${connection.source}-${connection.target}`,
      type: 'smoothstep'
    };
    
    setEdges((eds) => {
      const updatedEdges = addEdge(newEdge, eds);
      try {
        const newMermaidCode = reactFlowToMermaid({ nodes, edges: updatedEdges });
        if (newMermaidCode !== mermaidCode) {
          setMermaidCode(newMermaidCode);
          const newState = { mermaidCode: newMermaidCode, nodes: JSON.parse(JSON.stringify(nodes)), edges: JSON.parse(JSON.stringify(updatedEdges)) };
          setHistory(prev => [...prev.slice(0, historyIndex + 1), newState]);
          setHistoryIndex(prevIndex => prevIndex + 1);
        }
      } catch (err) {
        console.error('Error updating Mermaid from connection:', err);
      }
      return updatedEdges;
    });
  }, [nodes, historyIndex, mermaidCode]);

  const handleSave = async () => {
    setIsLoading(true);
    try {
      if (onSave) {
        await onSave({ mermaidCode, reactFlowData: { nodes, edges } });
      }
      setError(null);
    } catch (err) {
      console.error('Error saving diagram:', err);
      setError('Failed to save diagram: ' + err.message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleAiSuggest = async (customPrompt = null) => {
    setIsLoading(true);
    try {
      if (onAiSuggest) {
        const suggestion = await onAiSuggest(mermaidCode, customPrompt);
        if (suggestion?.mermaidCode) {
          setMermaidCode(suggestion.mermaidCode);
          const { nodes: suggestedNodes, edges: suggestedEdges } = mermaidToReactFlow(suggestion.mermaidCode);
          setNodes(suggestedNodes);
          setEdges(suggestedEdges);
          const newState = { mermaidCode: suggestion.mermaidCode, nodes: suggestedNodes, edges: suggestedEdges };
          setHistory(prev => [...prev.slice(0, historyIndex + 1), newState]);
          setHistoryIndex(prevIndex => prevIndex + 1);
        }
      }
      setError(null);
      setShowCustomForm(false);
    } catch (err) {
      console.error('Error getting AI suggestions:', err);
      setError('Failed to get AI suggestions: ' + err.message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleUndo = useCallback(() => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      const prevState = history[newIndex];
      setMermaidCode(prevState.mermaidCode);
      setNodes(prevState.nodes);
      setEdges(prevState.edges);
      setHistoryIndex(newIndex);
    }
  }, [history, historyIndex]);

  const handleRedo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1;
      const nextState = history[newIndex];
      setMermaidCode(nextState.mermaidCode);
      setNodes(nextState.nodes);
      setEdges(nextState.edges);
      setHistoryIndex(newIndex);
    }
  }, [history, historyIndex]);

  const handleDownload = useCallback(() => {
    if (viewMode === 'preview') {
      const svgElement = document.querySelector('.mermaid svg');
      if (svgElement) {
        const svgData = new XMLSerializer().serializeToString(svgElement);
        const svgBlob = new Blob([svgData], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(svgBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `system-diagram-${Date.now()}.svg`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
    } else {
      const textBlob = new Blob([mermaidCode], { type: 'text/plain' });
      const url = URL.createObjectURL(textBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `system-diagram-${Date.now()}.mmd`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  }, [mermaidCode, viewMode]);

  const handleCustomRequest = (e) => {
    e.preventDefault();
    if (!customRequest.trim()) return;
    handleAiSuggest(customRequest);
    setCustomRequest('');
  };

  const updateMermaidFromEditor = useCallback(() => {
    try {
      const { nodes: newNodes, edges: newEdges } = mermaidToReactFlow(mermaidCode);
      setNodes(newNodes);
      setEdges(newEdges);
      setError(null);
      const lastState = history[historyIndex];
      if (!lastState || lastState.mermaidCode !== mermaidCode) {
        const newState = {
          mermaidCode,
          nodes: newNodes,
          edges: newEdges
        };
        setHistory(prev => [...prev.slice(0, historyIndex + 1), newState]);
        setHistoryIndex(prevIndex => prevIndex + 1);
      }
      
      // Only change view mode if hideModes is false
      if (!hideModes) {
        setViewMode('edit');
      }
    } catch (err) {
      setError('Invalid Mermaid code: ' + err.message);
    }
  }, [mermaidCode, history, historyIndex, hideModes]);

  const onDragStart = (event, nodeType) => {
    event.dataTransfer.setData('application/reactflow', nodeType);
    event.dataTransfer.effectAllowed = 'move';
  };

  const handleInsertNode = (type) => {
    const newNode = {
      id: `${type}_${Date.now()}`,
      type,
      position: { 
        x: 150 + Math.random() * 100, 
        y: 150 + Math.random() * 100 
      },
      data: { 
        label: `${type.charAt(0).toUpperCase() + type.slice(1)}` 
      }
    };
    
    const updatedNodes = [...nodes, newNode];
    setNodes(updatedNodes);
    
    try {
      const newMermaidCode = reactFlowToMermaid({ 
        nodes: updatedNodes, 
        edges 
      });
      setMermaidCode(newMermaidCode);
      
      const newState = { 
        mermaidCode: newMermaidCode,
        nodes: updatedNodes,
        edges: JSON.parse(JSON.stringify(edges))
      };
      
      setHistory(prev => [...prev.slice(0, historyIndex + 1), newState]);
      setHistoryIndex(prevIndex => prevIndex + 1);
    } catch (err) {
      console.error('Error updating after node insertion:', err);
    }
  };

  // The actual content to render depends on viewMode, but we force 'edit' mode when hideModes is true
  const effectiveViewMode = hideModes ? 'edit' : viewMode;

  return (
    <div className="flex flex-col h-full overflow-hidden bg-white border border-gray-200 rounded-lg shadow-sm">
      {/* Only show the toolbar when hideModes is false */}
      {!hideModes && (
        <div className="p-3 border-b border-gray-200 flex justify-between items-center">
          <div className="flex items-center space-x-2">
            <h2 className="font-semibold text-gray-800 text-sm">System Design Diagram</h2>
            <div className="flex border border-gray-300 rounded-md overflow-hidden">
              <button 
                onClick={() => setViewMode('edit')} 
                className={`px-2 py-1 text-xs ${viewMode === 'edit' ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`}
              >
                <Edit className="h-3 w-3 inline-block mr-1" />
                Edit
              </button>
              <button 
                onClick={() => setViewMode('preview')} 
                className={`px-2 py-1 text-xs ${viewMode === 'preview' ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`}
              >
                <Eye className="h-3 w-3 inline-block mr-1" />
                Preview
              </button>
              <button 
                onClick={() => setViewMode('code')} 
                className={`px-2 py-1 text-xs ${viewMode === 'code' ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200'}`}
              >
                <Code className="h-3 w-3 inline-block mr-1" />
                Code
              </button>
            </div>
          </div>
          <div className="flex space-x-1">
            <button onClick={handleUndo} disabled={historyIndex <= 0} className={`p-1 rounded ${historyIndex > 0 ? 'hover:bg-gray-100 text-gray-600' : 'text-gray-300'}`} title="Undo">
              <Undo className="h-3 w-3" />
            </button>
            <button onClick={handleRedo} disabled={historyIndex >= history.length - 1} className={`p-1 rounded ${historyIndex < history.length - 1 ? 'hover:bg-gray-100 text-gray-600' : 'text-gray-300'}`} title="Redo">
              <Redo className="h-3 w-3" />
            </button>
            <button onClick={handleSave} className="p-1 rounded hover:bg-gray-100 text-gray-600" title="Save Diagram" disabled={isLoading}>
              <Save className={`h-3 w-3 ${isLoading ? 'animate-pulse' : ''}`} />
            </button>
            <button onClick={handleDownload} className="p-1 rounded hover:bg-gray-100 text-gray-600" title="Download">
              <Download className="h-3 w-3" />
            </button>
            <button onClick={() => handleAiSuggest()} className="p-1 rounded hover:bg-gray-100 text-gray-600" title="Get AI Suggestions" disabled={isLoading}>
              <RefreshCw className={`h-3 w-3 ${isLoading ? 'animate-spin' : ''}`} />
            </button>
            <button onClick={() => setShowCustomForm(!showCustomForm)} className="p-1 rounded hover:bg-gray-100 text-gray-600" title="Custom Request">
              <MessageSquare className="h-3 w-3" />
            </button>
            {onClose && (
              <button onClick={onClose} className="p-1 rounded hover:bg-gray-100 text-gray-600" title="Close">
                <X className="h-3 w-3" />
              </button>
            )}
          </div>
        </div>
      )}
      
      {showCustomForm && !hideModes && (
        <div className="p-3 border-b border-gray-200 bg-gray-50">
          <form onSubmit={handleCustomRequest} className="flex">
            <input
              type="text"
              value={customRequest}
              onChange={(e) => setCustomRequest(e.target.value)}
              placeholder="Request specific diagram improvements..."
              className="flex-1 border border-gray-300 rounded-l-lg px-3 py-1 text-sm focus:outline-none"
            />
            <button type="submit" className="bg-blue-600 text-white px-3 py-1 rounded-r-lg text-sm" disabled={isLoading}>
              {isLoading ? 'Generating...' : 'Send'}
            </button>
          </form>
        </div>
      )}
      
      {error && (
        <div className="px-3 py-2 bg-red-50 border-b border-red-200 text-red-700 text-xs">
          {error}
        </div>
      )}
      
      <div className="flex-1 overflow-hidden">
        {/* Always render the edit view when hideModes is true */}
        {(effectiveViewMode === 'edit') && (
          <div className="h-full flex flex-col">
            <div className="flex-1">
              <ReactFlowDiagramWithProvider
                initialNodes={nodes}
                initialEdges={edges}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                onConnect={onConnect}
                onDiagramUpdate={(diagramData) => {
                  if (onSave) {
                    onSave(diagramData);
                  }
                }}
              />
            </div>
            <div className="p-2 border-t border-gray-200 bg-gray-50">
              <h3 className="text-xs font-medium mb-2">Add Components</h3>
              <div className="flex flex-wrap gap-2">
                {[
                  { type: 'client', icon: <Globe className="h-6 w-6 text-blue-500" />, label: 'Client' },
                  { type: 'service', icon: <Server className="h-6 w-6 text-green-500" />, label: 'Service' },
                  { type: 'database', icon: <Database className="h-6 w-6 text-purple-500" />, label: 'Database' },
                  { type: 'cache', icon: <Archive className="h-6 w-6 text-red-500" />, label: 'Cache' },
                  { type: 'loadBalancer', icon: <Grid className="h-6 w-6 text-orange-500" />, label: 'Load Balancer' },
                  { type: 'queue', icon: <Share2 className="h-6 w-6 text-indigo-500" />, label: 'Queue' },
                  { type: 'custom', icon: <Box className="h-6 w-6 text-gray-500" />, label: 'Custom' }
                ].map(({ type, icon, label }) => (
                  <div
                    key={type}
                    className="flex flex-col items-center p-2 bg-white border border-gray-200 rounded shadow-sm hover:bg-blue-50 hover:border-blue-200 transition-colors cursor-pointer"
                    draggable
                    onDragStart={(event) => onDragStart(event, type)}
                    onClick={() => handleInsertNode(type)}
                  >
                    {icon}
                    <span className="text-xs mt-1">{label}</span>
                  </div>
                ))}
              </div>
            </div>
          </div>
        )}
        {effectiveViewMode === 'preview' && !hideModes && (
          <div className="h-full p-4 overflow-auto">
            <MermaidRenderer code={mermaidCode} onError={(errorMsg) => setError(errorMsg)} />
          </div>
        )}
        {effectiveViewMode === 'code' && !hideModes && (
          <div className="h-full p-4 flex flex-col">
            <textarea
              value={mermaidCode}
              onChange={(e) => setMermaidCode(e.target.value)}
              className="w-full flex-1 font-mono text-sm p-4 border border-gray-300 rounded resize-none"
              placeholder="Mermaid diagram code"
            />
            <div className="mt-4">
              <button
                onClick={updateMermaidFromEditor}
                className="px-3 py-1 bg-blue-600 text-white rounded text-sm"
              >
                Apply Changes
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default DiagramPanel;


================================================================================
# FILE: client\components\diagram\DiagramToolbar.js
# EXTENSION: .js
================================================================================
// client/components/diagram/DiagramToolbar.js
import React from 'react';
import { Database, Server, Globe, Archive, Grid, Box, Share2 } from 'lucide-react';

const DiagramToolbar = () => {
  const nodeTypes = [
    {
      type: 'client',
      icon: <Globe className="h-5 w-5 text-blue-600" />,
      label: "Client",
    },
    {
      type: 'service',
      icon: <Server className="h-5 w-5 text-green-600" />,
      label: "Service",
    },
    {
      type: 'database',
      icon: <Database className="h-5 w-5 text-purple-600" />,
      label: "Database",
    },
    {
      type: 'cache',
      icon: <Archive className="h-5 w-5 text-red-600" />,
      label: "Cache",
    },
    {
      type: 'loadBalancer',
      icon: <Grid className="h-5 w-5 text-orange-600" />,
      label: "Load Balancer",
    },
    {
      type: 'microservice',
      icon: <Box className="h-5 w-5 text-teal-600" />,
      label: "Microservice",
    },
    {
      type: 'queue',
      icon: <Share2 className="h-5 w-5 text-indigo-600" />,
      label: "Queue",
    }
  ];

  // Handle dragging a node
  const onDragStart = (event, nodeType) => {
    event.dataTransfer.setData('application/reactflow', nodeType);
    event.dataTransfer.effectAllowed = 'move';
  };

  return (
    <div className="flex flex-wrap gap-2">
      {nodeTypes.map((node) => (
        <div
          key={node.type}
          className="flex flex-col items-center p-2 bg-white border border-gray-200 rounded shadow-sm hover:bg-blue-50 hover:border-blue-200 transition-colors w-24 h-24 cursor-grab"
          onDragStart={(event) => onDragStart(event, node.type)}
          draggable
        >
          {node.icon}
          <span className="text-xs mt-2 text-center">{node.label}</span>
        </div>
      ))}
    </div>
  );
};

export default DiagramToolbar;


================================================================================
# FILE: client\components\diagram\ElementTypeIndicator.js
# EXTENSION: .js
================================================================================
// client/components/diagram/ElementTypeIndicator.js
import React from 'react';
import { 
  Database, Server, Globe, Archive, Grid, Box, Share2 
} from 'lucide-react';

/**
 * Component to display a visual indicator of the node type
 * for use in the diagram and in the editor UI
 */
const ElementTypeIndicator = ({ type, size = 'md', showLabel = false, className = '' }) => {
  // Configure the element based on type
  const elements = {
    client: {
      icon: <Globe />,
      label: 'Client',
      color: 'text-blue-500'
    },
    service: {
      icon: <Server />,
      label: 'Service',
      color: 'text-green-500'
    },
    database: {
      icon: <Database />,
      label: 'Database',
      color: 'text-purple-500'
    },
    cache: {
      icon: <Archive />,
      label: 'Cache',
      color: 'text-red-500'
    },
    loadBalancer: {
      icon: <Grid />,
      label: 'Load Balancer',
      color: 'text-orange-500'
    },
    queue: {
      icon: <Share2 />,
      label: 'Queue',
      color: 'text-indigo-500'
    },
    custom: {
      icon: <Box />,
      label: 'Custom',
      color: 'text-gray-500'
    }
  };

  // Choose the element based on type, default to custom if not found
  const element = elements[type] || elements.custom;

  // Size classes for the icon
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-6 h-6',
    lg: 'w-8 h-8'
  };

  return (
    <div className={`flex items-center ${className}`}>
      <div className={`${element.color} ${sizeClasses[size] || sizeClasses.md}`}>
        {element.icon}
      </div>
      
      {showLabel && (
        <span className="ml-1 text-xs font-medium">{element.label}</span>
      )}
    </div>
  );
};

export default ElementTypeIndicator;


================================================================================
# FILE: client\components\diagram\MermaidRenderer.js
# EXTENSION: .js
================================================================================
// client/components/diagram/MermaidRenderer.js
import React, { useEffect, useRef, useState } from 'react';
import mermaid from 'mermaid';

mermaid.initialize({
  startOnLoad: true,
  theme: 'neutral',
  securityLevel: 'loose',
  flowchart: {
    useMaxWidth: false,
    htmlLabels: true,
    curve: 'linear'
  },
  fontFamily: 'ui-sans-serif, system-ui, sans-serif',
});

const MermaidRenderer = ({ code, onError }) => {
  const containerRef = useRef(null);
  const [svgContent, setSvgContent] = useState('');
  const [isRendering, setIsRendering] = useState(true);
  const [error, setError] = useState(null);
  const [renderAttempts, setRenderAttempts] = useState(0);
  
  useEffect(() => {
    setSvgContent('');
    setError(null);
    setIsRendering(true);
    
    const id = `mermaid-${Date.now()}`;
    
    const cleanup = () => {
      if (containerRef.current) {
        containerRef.current.innerHTML = '';
      }
    };
    
    const renderDiagram = async () => {
      if (!code || !containerRef.current) return;
      
      try {
        cleanup();
        const { svg } = await mermaid.render(id, code);
        setSvgContent(svg);
        setError(null);
        if (onError) {
          onError(null);
        }
      } catch (err) {
        console.error('Mermaid render error:', err);
        setError(err.message || 'Failed to render diagram');
        if (renderAttempts < 2) {
          setTimeout(() => {
            setRenderAttempts(prev => prev + 1);
            renderDiagram();
          }, 100);
        } else {
          if (onError) {
            onError(err.message || 'Failed to render diagram');
          }
        }
      } finally {
        setIsRendering(false);
      }
    };
    
    renderDiagram();
    
    return cleanup;
  }, [code, onError, renderAttempts]);
  
  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded text-red-700 whitespace-pre-wrap">
        <div className="font-medium mb-2">Error rendering diagram:</div>
        <div className="text-sm font-mono">{error}</div>
      </div>
    );
  }
  
  if (isRendering) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
      </div>
    );
  }
  
  if (svgContent) {
    return (
      <div 
        className="mermaid flex items-center justify-center p-4 h-full overflow-auto bg-white"
        dangerouslySetInnerHTML={{ __html: svgContent }}
      />
    );
  }
  
  return (
    <div className="flex items-center justify-center h-full" ref={containerRef}>
      <div className="text-gray-500">Initializing diagram...</div>
    </div>
  );
};

export default MermaidRenderer;



================================================================================
# FILE: client\components\diagram\NodeTypes\CacheNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/CacheNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Archive } from 'lucide-react';

const CacheNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-red-500">
      <div className="flex items-center">
        <Archive className="h-8 w-8 text-red-500 mr-2" />
        <div>
          <div className="text-xs text-red-700 font-medium bg-red-50 px-1 rounded mb-1">Cache</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Top}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-red-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-red-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-red-500"
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-red-500"
      />
    </div>
  );
};

export default memo(CacheNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\ClientNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/ClientNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Globe } from 'lucide-react';

const ClientNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-blue-500">
      <div className="flex items-center">
        <Globe className="h-8 w-8 text-blue-500 mr-2" />
        <div>
          <div className="text-xs text-blue-700 font-medium bg-blue-50 px-1 rounded mb-1">Client</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-blue-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-blue-500"
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-blue-500"
      />
    </div>
  );
};

export default memo(ClientNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\CustomNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/CustomNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Box } from 'lucide-react';

const CustomNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-gray-500">
      <div className="flex items-center">
        <Box className="h-8 w-8 text-gray-500 mr-2" />
        <div>
          <div className="text-xs text-gray-700 font-medium bg-gray-50 px-1 rounded mb-1">Custom</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Top}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-gray-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-gray-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-gray-500"
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-gray-500"
      />
    </div>
  );
};

export default memo(CustomNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\DatabaseNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/DatabaseNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Database } from 'lucide-react';

const DatabaseNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-purple-500">
      <div className="flex items-center">
        <Database className="h-8 w-8 text-purple-500 mr-2" />
        <div>
          <div className="text-xs text-purple-700 font-medium bg-purple-50 px-1 rounded mb-1">Database</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Top}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-purple-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-purple-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-purple-500"
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-purple-500"
      />
    </div>
  );
};

export default memo(DatabaseNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\LoadBalancerNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/LoadBalancerNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Grid } from 'lucide-react';

const LoadBalancerNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-orange-500">
      <div className="flex items-center">
        <Grid className="h-8 w-8 text-orange-500 mr-2" />
        <div>
          <div className="text-xs text-orange-700 font-medium bg-orange-50 px-1 rounded mb-1">Load Balancer</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Top}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-orange-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-orange-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-orange-500"
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-orange-500"
      />
    </div>
  );
};

export default memo(LoadBalancerNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\QueueNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/QueueNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Share2 } from 'lucide-react';

const QueueNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-indigo-500">
      <div className="flex items-center">
        <Share2 className="h-8 w-8 text-indigo-500 mr-2" />
        <div>
          <div className="text-xs text-indigo-700 font-medium bg-indigo-50 px-1 rounded mb-1">Queue</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Top}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-indigo-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-indigo-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-indigo-500"
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-indigo-500"
      />
    </div>
  );
};

export default memo(QueueNode);


================================================================================
# FILE: client\components\diagram\NodeTypes\ServiceNode.js
# EXTENSION: .js
================================================================================
// client/components/diagram/NodeTypes/ServiceNode.js
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';
import { Server } from 'lucide-react';

const ServiceNode = ({ data, isConnectable }) => {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-green-500">
      <div className="flex items-center">
        <Server className="h-8 w-8 text-green-500 mr-2" />
        <div>
          <div className="text-xs text-green-700 font-medium bg-green-50 px-1 rounded mb-1">Service</div>
          <div className="text-sm font-bold">{data.label}</div>
          {data.notes && (
            <div className="text-xs text-gray-500 mt-1">{data.notes}</div>
          )}
        </div>
      </div>
      <Handle
        type="target"
        position={Position.Top}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-green-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        isConnectable={isConnectable}
        className="w-3 h-3 bg-green-500"
      />
      <Handle
        type="source"
        position={Position.Right}
        id="right"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-green-500"
      />
      <Handle
        type="target"
        position={Position.Left}
        id="left"
        isConnectable={isConnectable}
        className="w-3 h-3 bg-green-500"
      />
    </div>
  );
};

export default memo(ServiceNode);


================================================================================
# FILE: client\components\diagram\ReactFlowDiagram.js
# EXTENSION: .js
================================================================================
// client/components/diagram/ReactFlowDiagram.js
import React, { useCallback, useRef, useState } from 'react';
import ReactFlow, {
  ReactFlowProvider,
  Controls,
  Background,
  MiniMap,
  addEdge,
  Panel
} from 'reactflow';
import { Database, Server, Globe, Archive, Grid, Share2, Box } from 'lucide-react';
import 'reactflow/dist/style.css';

// Import custom node types
import DatabaseNode from './NodeTypes/DatabaseNode';
import ServiceNode from './NodeTypes/ServiceNode';
import ClientNode from './NodeTypes/ClientNode';
import LoadBalancerNode from './NodeTypes/LoadBalancerNode';
import CacheNode from './NodeTypes/CacheNode';
import QueueNode from './NodeTypes/QueueNode';
import CustomNode from './NodeTypes/CustomNode';

// Define nodeTypes outside the component to prevent re-creation on each render
const nodeTypes = {
  database: DatabaseNode,
  service: ServiceNode,
  client: ClientNode,
  loadBalancer: LoadBalancerNode,
  cache: CacheNode,
  queue: QueueNode,
  custom: CustomNode
};

const Flow = ({ 
  initialNodes, 
  initialEdges, 
  onNodesChange, 
  onEdgesChange, 
  onConnect,
  onDiagramUpdate 
}) => {
  const reactFlowWrapper = useRef(null);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);
  const [autoLayout, setAutoLayout] = useState(false);
  const [selectedNode, setSelectedNode] = useState(null);
  const [showNodeEditor, setShowNodeEditor] = useState(false);
  const [nodeName, setNodeName] = useState('');
  const [nodeNotes, setNodeNotes] = useState('');
  const [isDragging, setIsDragging] = useState(false);
  
  // Safely get nodes and edges with defaults
  const safeNodes = Array.isArray(initialNodes) && initialNodes.length > 0 
    ? initialNodes 
    : [{ id: 'default', position: { x: 100, y: 100 }, data: { label: 'Default Node' } }];
  
  const safeEdges = Array.isArray(initialEdges) ? initialEdges : [];

  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onNodeClick = useCallback((event, node) => {
    setSelectedNode(node);
    setNodeName(node.data.label || '');
    setNodeNotes(node.data.notes || '');
    setShowNodeEditor(true);
  }, []);

  const onNodeDoubleClick = useCallback((event, node) => {
    setSelectedNode(node);
    setNodeName(node.data.label || '');
    setNodeNotes(node.data.notes || '');
    setShowNodeEditor(true);
  }, []);

  const handleSaveNodeEdit = useCallback(() => {
    if (!selectedNode) return;
    
    const updatedNodes = safeNodes.map(n => {
      if (n.id === selectedNode.id) {
        return {
          ...n,
          data: {
            ...n.data,
            label: nodeName,
            notes: nodeNotes
          }
        };
      }
      return n;
    });
    
    onNodesChange([{ type: 'reset', items: updatedNodes }]);
    setShowNodeEditor(false);
    setSelectedNode(null);
    
    if (onDiagramUpdate) {
      onDiagramUpdate({
        nodes: updatedNodes,
        edges: safeEdges
      });
    }
  }, [selectedNode, nodeName, nodeNotes, safeNodes, safeEdges, onNodesChange, onDiagramUpdate]);

  const onDrop = useCallback(
    (event) => {
      event.preventDefault();

      if (!reactFlowInstance || !reactFlowWrapper.current) {
        console.log("Can't handle drop - missing instance or wrapper");
        return;
      }

      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const type = event.dataTransfer.getData('application/reactflow');

      if (typeof type === 'undefined' || !type) {
        console.log("Invalid drag data:", type);
        return;
      }

      const position = reactFlowInstance.project({
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      });

      const defaultLabel = type.charAt(0).toUpperCase() + type.slice(1);
      const nodeId = `${type}_${Date.now()}`;
      
      const newNode = {
        id: nodeId,
        type,
        position,
        data: { 
          label: `${defaultLabel}`,
          notes: ''
        },
      };

      const updatedNodes = [...safeNodes, newNode];
      
      onNodesChange([{ type: 'add', item: newNode }]);
      
      if (onDiagramUpdate) {
        onDiagramUpdate({
          nodes: updatedNodes,
          edges: safeEdges
        });
      }
    },
    [reactFlowInstance, safeNodes, safeEdges, onNodesChange, onDiagramUpdate]
  );

  const handleConnect = useCallback((params) => {
    const newEdge = {
      ...params,
      id: `edge-${params.source}-${params.target}`,
      type: 'smoothstep',
      data: { label: '' }
    };
    
    const updatedEdges = addEdge(newEdge, safeEdges);
    onConnect(params);
    
    if (onDiagramUpdate) {
      onDiagramUpdate({
        nodes: safeNodes,
        edges: updatedEdges
      });
    }
  }, [safeNodes, safeEdges, onConnect, onDiagramUpdate]);

  const addNode = useCallback((type) => {
    const position = reactFlowInstance ? 
      { 
        x: Math.random() * 300 + 50, 
        y: Math.random() * 300 + 50 
      } : 
      { x: 100, y: 100 };
    
    const defaultLabel = type.charAt(0).toUpperCase() + type.slice(1);
    const nodeId = `${type}_${Date.now()}`;
    
    const newNode = {
      id: nodeId,
      type,
      position,
      data: { 
        label: `${defaultLabel}`,
        notes: ''
      },
    };
    
    const updatedNodes = [...safeNodes, newNode];
    onNodesChange([{ type: 'add', item: newNode }]);
    
    if (onDiagramUpdate) {
      onDiagramUpdate({
        nodes: updatedNodes,
        edges: safeEdges
      });
    }
  }, [reactFlowInstance, safeNodes, safeEdges, onNodesChange, onDiagramUpdate]);

  return (
    <div className="w-full h-full relative" ref={reactFlowWrapper} style={{ minHeight: '300px' }}>
      <ReactFlow
        nodes={safeNodes}
        edges={safeEdges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={handleConnect}
        onInit={setReactFlowInstance}
        onDrop={onDrop}
        onDragOver={onDragOver}
        onNodeClick={onNodeClick}
        onNodeDoubleClick={onNodeDoubleClick}
        nodeTypes={nodeTypes}
        fitView={false}
        attributionPosition="bottom-left"
        minZoom={0.5}
        maxZoom={2}
        deleteKeyCode={['Backspace', 'Delete']}
        multiSelectionKeyCode={['Control', 'Meta']}
        snapToGrid={autoLayout}
        snapGrid={[15, 15]}
        connectionLineStyle={{ strokeWidth: 2, stroke: '#999' }}
        connectionLineType="smoothstep"
      >
        <Controls />
        <MiniMap />
        <Background variant="dots" gap={12} size={1} />
        <Panel position="top-right">
          <div className="bg-white p-2 rounded shadow-md flex flex-col space-y-2">
            <button 
              onClick={() => setAutoLayout(!autoLayout)} 
              className={`px-2 py-1 text-xs rounded ${autoLayout ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
            >
              {autoLayout ? 'Disable Auto Layout' : 'Enable Auto Layout'}
            </button>
            <button 
              onClick={() => {
                if (reactFlowInstance) {
                  reactFlowInstance.fitView();
                }
              }}
              className="px-2 py-1 text-xs bg-gray-200 rounded"
            >
              Center View
            </button>
          </div>
        </Panel>
        <Panel position="bottom" className="w-full">
          <div className="bg-white p-2 border-t border-gray-200 flex flex-wrap justify-center gap-2">
            {[
              { type: 'client', icon: <Globe className="w-4 h-4" />, color: 'blue', label: 'Client' },
              { type: 'service', icon: <Server className="w-4 h-4" />, color: 'green', label: 'Service' },
              { type: 'database', icon: <Database className="w-4 h-4" />, color: 'purple', label: 'Database' },
              { type: 'cache', icon: <Archive className="w-4 h-4" />, color: 'red', label: 'Cache' },
              { type: 'loadBalancer', icon: <Grid className="w-4 h-4" />, color: 'orange', label: 'Load Balancer' },
              { type: 'queue', icon: <Share2 className="w-4 h-4" />, color: 'indigo', label: 'Queue' },
              { type: 'custom', icon: <Box className="w-4 h-4" />, color: 'gray', label: 'Custom' }
            ].map(({ type, icon, color, label }) => (
              <button
                key={type}
                onClick={() => addNode(type)}
                className="flex items-center px-2 py-1 text-xs rounded bg-gray-100 text-gray-700 border border-gray-200 hover:bg-gray-200"
                draggable
                onDragStart={(event) => {
                  event.dataTransfer.setData('application/reactflow', type);
                  setIsDragging(true);
                }}
                onDragEnd={() => setIsDragging(false)}
              >
                <span className="mr-1">{icon}</span>
                {label}
              </button>
            ))}
          </div>
        </Panel>
      </ReactFlow>
      
      {showNodeEditor && selectedNode && (
        <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-10">
          <div className="bg-white rounded-lg p-4 w-64">
            <h3 className="font-medium mb-2">Edit Node</h3>
            <div className="mb-4">
              <label className="block text-sm text-gray-700 mb-1">Name</label>
              <input 
                type="text" 
                value={nodeName} 
                onChange={(e) => setNodeName(e.target.value)}
                className="w-full px-2 py-1 border rounded"
              />
            </div>
            <div className="mb-4">
              <label className="block text-sm text-gray-700 mb-1">Notes</label>
              <textarea 
                value={nodeNotes} 
                onChange={(e) => setNodeNotes(e.target.value)}
                className="w-full px-2 py-1 border rounded h-20"
              />
            </div>
            <div className="flex justify-end space-x-2">
              <button 
                onClick={() => setShowNodeEditor(false)}
                className="px-3 py-1 text-sm bg-gray-200 rounded"
              >
                Cancel
              </button>
              <button 
                onClick={handleSaveNodeEdit}
                className="px-3 py-1 text-sm bg-blue-500 text-white rounded"
              >
                Save
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

// Wrapper with error handling
const ReactFlowDiagramWithProvider = (props) => {
  return (
    <ReactFlowProvider>
      <Flow {...props} />
    </ReactFlowProvider>
  );
};

export default ReactFlowDiagramWithProvider;


================================================================================
# FILE: client\components\diagram\SequenceDiagram.js
# EXTENSION: .js
================================================================================
// client/components/diagram/SequenceDiagram.js
import React, { useState, useCallback, useEffect, useRef } from 'react';
import { memo } from 'react';
import ReactFlow, { 
  ReactFlowProvider, 
  Background, 
  Controls,
  Handle, 
  Position,
  addEdge,
  applyEdgeChanges, 
  applyNodeChanges,
  Panel
} from 'reactflow';
import 'reactflow/dist/style.css';
import { User, Server, ArrowRight, Plus, Edit, Trash2 } from 'lucide-react';

// Custom Node Types for Sequence Diagrams
const ActorNode = memo(({ data, selected }) => (
  <div 
    className={`px-4 py-2 shadow-md rounded-md bg-white border-2 ${selected ? 'border-blue-700' : 'border-blue-500'}`}
  >
    <div className="flex flex-col items-center">
      <User className="h-8 w-8 text-blue-500 mb-2" />
      <div className="text-sm font-bold text-center">{data.label}</div>
    </div>
    <Handle
      type="source"
      position={Position.Bottom}
      id="bottom"
      isConnectable={false}
      className="w-3 h-3 bg-blue-500"
    />
  </div>
));

const ParticipantNode = memo(({ data, selected }) => (
  <div 
    className={`px-4 py-2 shadow-md rounded-md bg-white border-2 ${selected ? 'border-purple-700' : 'border-purple-500'}`}
  >
    <div className="flex flex-col items-center">
      <Server className="h-8 w-8 text-purple-500 mb-2" />
      <div className="text-sm font-bold text-center">{data.label}</div>
    </div>
    <Handle
      type="source"
      position={Position.Bottom}
      id="bottom"
      isConnectable={false}
      className="w-3 h-3 bg-purple-500"
    />
  </div>
));

const LifelineNode = memo(({ data, selected }) => (
  <div 
    className={`sequence-lifeline-node ${selected ? 'border-l-2 border-gray-500' : ''}`} 
    style={{ width: '2px', height: 400 }}
  >
    <div className="w-0.5 h-full bg-gray-300 mx-auto"></div>
    <Handle
      type="target"
      position={Position.Top}
      id="top"
      isConnectable={false}
      style={{ visibility: 'hidden' }}
      className="w-3 h-3 bg-gray-500"
    />
    {data.activations && data.activations.map((activation, index) => (
      <div 
        key={index}
        className="bg-gray-200 border border-gray-400"
        style={{
          position: 'absolute',
          width: '10px',
          height: `${activation.height}px`,
          left: '-4px',
          top: `${activation.top}px`,
        }}
      />
    ))}
    <Handle
      type="source"
      position={Position.Right}
      id="right"
      className="w-3 h-3 bg-gray-500"
    />
    <Handle
      type="target"
      position={Position.Left}
      id="left"
      className="w-3 h-3 bg-gray-500"
    />
  </div>
));

const MessageEdge = ({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  data,
  style = {},
}) => {
  const edgePath = `M${sourceX},${sourceY} L${targetX},${targetY}`;
  const messageText = data?.label || '';
  const isReturn = data?.type === 'return';
  const isAsync = data?.type === 'async';
  
  // Calculate text positioning
  const textX = (sourceX + targetX) / 2;
  const textY = sourceY - 10; // Position text above the line
  
  return (
    <>
      <path
        id={id}
        style={{ 
          ...style, 
          strokeDasharray: isReturn || isAsync ? '5,5' : 'none',
          stroke: isReturn ? '#888' : '#333',
          strokeWidth: 1.5
        }}
        className="react-flow__edge-path"
        d={edgePath}
      />
      {messageText && (
        <text
          x={textX}
          y={textY}
          textAnchor="middle"
          dominantBaseline="middle"
          className="text-xs fill-gray-700"
          style={{ fontSize: 10 }}
        >
          {messageText}
        </text>
      )}
      {/* Arrow head */}
      <path
        d={`M${targetX - 5},${targetY - 5} L${targetX},${targetY} L${targetX - 5},${targetY + 5}`}
        style={{
          fill: 'none',
          stroke: isReturn ? '#888' : '#333',
          strokeWidth: 1.5
        }}
      />
    </>
  );
};

// Function to convert nodes and edges to mermaid syntax
function generateMermaidCode(nodes, edges) {
  if (!nodes || !edges) return '';
  
  const participants = nodes.filter(node => 
    node.type === 'actor' || node.type === 'participant'
  );
  
  // Start with sequence diagram declaration
  let code = 'sequenceDiagram\n';
  
  // Declare participants
  participants.forEach(participant => {
    if (participant.type === 'actor') {
      code += `    actor ${participant.data.label.replace(/\s+/g, '_')}\n`;
    } else {
      code += `    participant ${participant.data.label.replace(/\s+/g, '_')}\n`;
    }
  });
  
  // Sort edges by vertical position to maintain proper sequence
  const sortedEdges = [...edges].sort((a, b) => {
    const nodeA = nodes.find(n => n.id === a.source);
    const nodeB = nodes.find(n => n.id === b.source);
    if (!nodeA || !nodeB) return 0;
    
    return nodeA.position.y - nodeB.position.y;
  });
  
  // Add messages
  sortedEdges.forEach(edge => {
    if (!edge.data?.label) return;
    
    // Find the lifelines
    const sourceLifeline = nodes.find(n => n.id === edge.source);
    const targetLifeline = nodes.find(n => n.id === edge.target);
    
    if (!sourceLifeline || !targetLifeline) return;
    
    // Find the parent participants of these lifelines
    const sourceParticipant = nodes.find(n => 
      (n.type === 'actor' || n.type === 'participant') && 
      sourceLifeline.data?.participantId === n.id
    );
    
    const targetParticipant = nodes.find(n => 
      (n.type === 'actor' || n.type === 'participant') && 
      targetLifeline.data?.participantId === n.id
    );
    
    if (!sourceParticipant || !targetParticipant) return;
    
    const sourceLabel = sourceParticipant.data.label.replace(/\s+/g, '_');
    const targetLabel = targetParticipant.data.label.replace(/\s+/g, '_');
    const messageLabel = edge.data.label;
    const messageType = edge.data.type || 'sync';
    
    if (messageType === 'sync') {
      code += `    ${sourceLabel}->>+${targetLabel}: ${messageLabel}\n`;
    } else if (messageType === 'async') {
      code += `    ${sourceLabel}-->>+${targetLabel}: ${messageLabel}\n`;
    } else if (messageType === 'return') {
      code += `    ${sourceLabel}-->>-${targetLabel}: ${messageLabel}\n`;
    }
  });
  
  return code;
}

// Main Sequence Diagram Component
const SequenceDiagram = ({ initialDiagram, onDiagramUpdate }) => {
  // Define node and edge types
  const nodeTypes = {
    actor: ActorNode,
    participant: ParticipantNode,
    lifeline: LifelineNode
  };
  
  const edgeTypes = {
    message: MessageEdge
  };
  
  // State initialization
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [selectedElement, setSelectedElement] = useState(null);
  const [messageType, setMessageType] = useState('sync');
  const [editingLabel, setEditingLabel] = useState('');
  const [isEditing, setIsEditing] = useState(false);
  
  // Use refs to prevent circular updates
  const nodesRef = useRef([]);
  const edgesRef = useRef([]);
  const mermaidCodeRef = useRef('');
  const isInitializedRef = useRef(false);
  const isMountedRef = useRef(false);
  const isUpdatingRef = useRef(false);
  
  // Initialize diagram only once
  useEffect(() => {
    // Set mounted flag
    isMountedRef.current = true;
    
    if (isInitializedRef.current) return;
    
    let diagramNodes = [];
    let diagramEdges = [];
    
    try {
      if (initialDiagram && initialDiagram.nodes && initialDiagram.nodes.length > 0) {
        // Use the provided diagram data
        diagramNodes = [...initialDiagram.nodes];
        diagramEdges = initialDiagram.edges ? [...initialDiagram.edges] : [];
        
        if (initialDiagram.mermaidCode) {
          mermaidCodeRef.current = initialDiagram.mermaidCode;
        } else {
          mermaidCodeRef.current = generateMermaidCode(diagramNodes, diagramEdges);
        }
      } else {
        // Create default sequence diagram with two participants
        const timestamp = Date.now();
        const actor1Id = `actor-${timestamp}`;
        const actor2Id = `participant-${timestamp + 1}`;
        const lifeline1Id = `lifeline-${timestamp + 2}`;
        const lifeline2Id = `lifeline-${timestamp + 3}`;
        
        diagramNodes = [
          // Participants at the top
          { 
            id: actor1Id, 
            type: 'actor', 
            position: { x: 150, y: 50 }, 
            data: { 
              label: 'User',
              id: actor1Id
            } 
          },
          { 
            id: actor2Id, 
            type: 'participant', 
            position: { x: 350, y: 50 }, 
            data: { 
              label: 'System',
              id: actor2Id
            } 
          },
          // Lifelines below each participant
          {
            id: lifeline1Id,
            type: 'lifeline',
            position: { x: 175, y: 120 },
            data: { 
              label: '', 
              participantId: actor1Id,
              height: 400,
              activations: [],
              id: lifeline1Id
            }
          },
          {
            id: lifeline2Id,
            type: 'lifeline',
            position: { x: 375, y: 120 },
            data: { 
              label: '', 
              participantId: actor2Id,
              height: 400,
              activations: [],
              id: lifeline2Id
            }
          }
        ];
        
        diagramEdges = [
          {
            id: `edge-${lifeline1Id}-${lifeline2Id}-${timestamp}`,
            source: lifeline1Id,
            target: lifeline2Id,
            sourceHandle: 'right',
            targetHandle: 'left',
            data: { 
              label: 'Request',
              type: 'sync'
            },
            type: 'message',
            animated: false
          }
        ];
        
        mermaidCodeRef.current = generateMermaidCode(diagramNodes, diagramEdges);
      }
      
      // Set initial state
      safeSetNodes(diagramNodes);
      safeSetEdges(diagramEdges);
      
      // Update refs
      nodesRef.current = diagramNodes;
      edgesRef.current = diagramEdges;
      
      isInitializedRef.current = true;
    } catch (error) {
      console.error("Error initializing sequence diagram:", error);
    }
    
    // Cleanup function
    return () => {
      isMountedRef.current = false;
    };
  }, [initialDiagram]);
  
  // Safe update functions to prevent infinite loops
  const safeSetNodes = useCallback((newNodes) => {
    if (isUpdatingRef.current) return;
    
    isUpdatingRef.current = true;
    setNodes(newNodes);
    nodesRef.current = newNodes;
    
    // Reset the flag after a small delay
    setTimeout(() => {
      isUpdatingRef.current = false;
    }, 0);
  }, []);
  
  const safeSetEdges = useCallback((newEdges) => {
    if (isUpdatingRef.current) return;
    
    isUpdatingRef.current = true;
    setEdges(newEdges);
    edgesRef.current = newEdges;
    
    // Reset the flag after a small delay
    setTimeout(() => {
      isUpdatingRef.current = false;
    }, 0);
  }, []);
  
  // Update mermaid code whenever nodes or edges change
  useEffect(() => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    // We've already updated refs in safeSet* functions
    const newMermaidCode = generateMermaidCode(nodesRef.current, edgesRef.current);
    
    // Only update if code has changed
    if (newMermaidCode !== mermaidCodeRef.current) {
      mermaidCodeRef.current = newMermaidCode;
      
      // Notify parent if callback exists
      if (onDiagramUpdate && isMountedRef.current) {
        onDiagramUpdate({
          nodes: nodesRef.current,
          edges: edgesRef.current,
          mermaidCode: newMermaidCode
        });
      }
    }
  }, [nodes, edges, onDiagramUpdate]);
  
  // Handle node changes - with strict rules for sequence diagrams
  const onNodesChange = useCallback((changes) => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    const updatedNodes = applyNodeChanges(changes, nodesRef.current);
    
    // For position changes, enforce sequence diagram rules
    const positionChanges = changes.filter(change => change.type === 'position');
    if (positionChanges.length > 0) {
      const finalNodes = updatedNodes.map(node => {
        // Find if this node was moved
        const change = positionChanges.find(c => c.id === node.id);
        if (!change) return node;
        
        // For actors/participants, only allow horizontal movement
        if (node.type === 'actor' || node.type === 'participant') {
          const newY = 50; // Fix Y position at top
          
          // Update lifeline position to match
          const correspondingLifeline = updatedNodes.find(
            n => n.type === 'lifeline' && n.data?.participantId === node.id
          );
          
          if (correspondingLifeline) {
            // Update the lifeline's x position to match the participant
            const lifelineIndex = updatedNodes.findIndex(n => n.id === correspondingLifeline.id);
            if (lifelineIndex >= 0) {
              updatedNodes[lifelineIndex] = {
                ...updatedNodes[lifelineIndex],
                position: {
                  x: node.position.x + 25, // Center the lifeline under the participant
                  y: updatedNodes[lifelineIndex].position.y
                }
              };
            }
          }
          
          return {
            ...node,
            position: {
              x: node.position.x, // Allow X movement
              y: newY // Fix Y position
            }
          };
        }
        
        // For lifelines, only allow vertical position changes
        if (node.type === 'lifeline') {
          // Find the associated participant
          const participant = updatedNodes.find(
            n => (n.type === 'actor' || n.type === 'participant') && n.id === node.data?.participantId
          );
          
          if (participant) {
            return {
              ...node,
              position: {
                x: participant.position.x + 25, // Keep aligned with participant
                y: node.position.y // Allow vertical movement
              }
            };
          }
        }
        
        return node;
      });
      
      safeSetNodes(finalNodes);
    } else {
      safeSetNodes(updatedNodes);
    }
  }, [safeSetNodes]);
  
  // Handle edge changes
  const onEdgesChange = useCallback((changes) => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    const updatedEdges = applyEdgeChanges(changes, edgesRef.current);
    safeSetEdges(updatedEdges);
  }, [safeSetEdges]);
  
  // Handle connections - enforce sequence diagram rules
  const onConnect = useCallback((params) => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    // Only allow connections between lifelines
    if (params.sourceHandle === 'right' && params.targetHandle === 'left') {
      const newEdge = {
        id: `edge-${params.source}-${params.target}-${Date.now()}`,
        source: params.source,
        target: params.target,
        sourceHandle: 'right',
        targetHandle: 'left',
        data: { 
          label: 'New Message',
          type: messageType
        },
        type: 'message',
        animated: false
      };
      
      const newEdges = addEdge(newEdge, edgesRef.current);
      safeSetEdges(newEdges);
      
      // Select the new edge
      setSelectedElement(newEdge);
      setIsEditing(true);
      setEditingLabel('New Message');
    }
  }, [messageType, safeSetEdges]);
  
  // Handle node selection
  const onNodeClick = useCallback((_, node) => {
    if (!isInitializedRef.current) return;
    
    if (node.type === 'actor' || node.type === 'participant') {
      setSelectedElement(node);
      setEditingLabel(node.data?.label || '');
      setIsEditing(false);
    }
  }, []);
  
  // Handle edge selection
  const onEdgeClick = useCallback((_, edge) => {
    if (!isInitializedRef.current) return;
    
    setSelectedElement(edge);
    setEditingLabel(edge.data?.label || '');
    setIsEditing(false);
  }, []);
  
  // Save edited label
  const saveLabel = useCallback(() => {
    if (!isInitializedRef.current || !selectedElement || !editingLabel.trim()) return;
    
    if (selectedElement.source) {
      // It's an edge
      const updatedEdges = edgesRef.current.map(e => 
        e.id === selectedElement.id 
          ? { ...e, data: { ...e.data, label: editingLabel } }
          : e
      );
      safeSetEdges(updatedEdges);
    } else {
      // It's a node
      const updatedNodes = nodesRef.current.map(n => 
        n.id === selectedElement.id 
          ? { ...n, data: { ...n.data, label: editingLabel } }
          : n
      );
      safeSetNodes(updatedNodes);
    }
    
    setIsEditing(false);
  }, [selectedElement, editingLabel, safeSetEdges, safeSetNodes]);
  
  // Add a new actor
  const addActor = useCallback(() => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    // Generate unique IDs for new nodes
    const timestamp = Date.now();
    const actorId = `actor-${timestamp}`;
    const lifelineId = `lifeline-${timestamp + 1}`;
    
    // Determine position (place new actor to the right of existing ones)
    const lastX = Math.max(
      ...nodesRef.current
        .filter(n => n.type === 'actor' || n.type === 'participant')
        .map(n => n.position.x + 200),
      100 // default starting position if no nodes exist
    );
    
    const newActor = { 
      id: actorId, 
      type: 'actor', 
      position: { x: lastX, y: 50 }, 
      data: { 
        label: 'New Actor',
        id: actorId
      } 
    };
    
    const newLifeline = {
      id: lifelineId,
      type: 'lifeline',
      position: { x: lastX + 25, y: 120 },
      data: { 
        label: '', 
        participantId: actorId,
        height: 400,
        activations: [],
        id: lifelineId
      }
    };
    
    const updatedNodes = [...nodesRef.current, newActor, newLifeline];
    safeSetNodes(updatedNodes);
    
    // Select the new actor for immediate editing
    setSelectedElement(newActor);
    setEditingLabel('New Actor');
    setIsEditing(true);
  }, [safeSetNodes]);
  
  // Add a new participant (object)
  const addParticipant = useCallback(() => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    // Generate unique IDs for new nodes
    const timestamp = Date.now();
    const participantId = `participant-${timestamp}`;
    const lifelineId = `lifeline-${timestamp + 1}`;
    
    // Determine position (place new participant to the right of existing ones)
    const lastX = Math.max(
      ...nodesRef.current
        .filter(n => n.type === 'actor' || n.type === 'participant')
        .map(n => n.position.x + 200),
      100 // default starting position if no nodes exist
    );
    
    const newParticipant = { 
      id: participantId, 
      type: 'participant', 
      position: { x: lastX, y: 50 }, 
      data: { 
        label: 'New Participant',
        id: participantId
      } 
    };
    
    const newLifeline = {
      id: lifelineId,
      type: 'lifeline',
      position: { x: lastX + 25, y: 120 },
      data: { 
        label: '', 
        participantId: participantId,
        height: 400,
        activations: [],
        id: lifelineId
      }
    };
    
    const updatedNodes = [...nodesRef.current, newParticipant, newLifeline];
    safeSetNodes(updatedNodes);
    
    // Select the new participant for immediate editing
    setSelectedElement(newParticipant);
    setEditingLabel('New Participant');
    setIsEditing(true);
  }, [safeSetNodes]);
  
  // Delete selected element
  const deleteSelected = useCallback(() => {
    if (!isInitializedRef.current || !selectedElement) return;
    
    if (selectedElement.source) {
      // It's an edge - simply remove it
      const updatedEdges = edgesRef.current.filter(e => e.id !== selectedElement.id);
      safeSetEdges(updatedEdges);
    } else {
      // It's a node
      if (selectedElement.type === 'actor' || selectedElement.type === 'participant') {
        // Remove participant and its lifeline
        const updatedNodes = nodesRef.current.filter(n => 
          n.id !== selectedElement.id && n.data?.participantId !== selectedElement.id
        );
        safeSetNodes(updatedNodes);
        
        // Remove any edges connected to the lifeline
        const lifeline = nodesRef.current.find(n => n.data?.participantId === selectedElement.id);
        if (lifeline) {
          const updatedEdges = edgesRef.current.filter(e => 
            e.source !== lifeline.id && e.target !== lifeline.id
          );
          safeSetEdges(updatedEdges);
        }
      }
    }
    
    setSelectedElement(null);
    setIsEditing(false);
  }, [selectedElement, safeSetNodes, safeSetEdges]);
  
  // Add a new message between existing lifelines
  const addMessage = useCallback(() => {
    if (!isInitializedRef.current || isUpdatingRef.current) return;
    
    // Need at least two lifelines to add a message
    const lifelines = nodesRef.current.filter(n => n.type === 'lifeline');
    if (lifelines.length < 2) return;
    
    // Get first two lifelines
    const [source, target] = lifelines.slice(0, 2);
    
    // Create a new message edge
    const newEdge = {
      id: `edge-${source.id}-${target.id}-${Date.now()}`,
      source: source.id,
      target: target.id,
      sourceHandle: 'right',
      targetHandle: 'left',
      data: { 
        label: 'New Message',
        type: messageType
      },
      type: 'message',
      animated: false
    };
    
    const updatedEdges = [...edgesRef.current, newEdge];
    safeSetEdges(updatedEdges);
    
    // Select the new message for immediate editing
    setSelectedElement(newEdge);
    setEditingLabel('New Message');
    setIsEditing(true);
  }, [messageType, safeSetEdges]);
  
  // Enable editing mode for the selected element
  const startEditing = useCallback(() => {
    if (!selectedElement) return;
    
    // Set the label based on selected element type
    if (selectedElement.source) {
      // It's an edge
      setEditingLabel(selectedElement.data?.label || '');
    } else {
      // It's a node
      setEditingLabel(selectedElement.data?.label || '');
    }
    
    setIsEditing(true);
  }, [selectedElement]);
  
  return (
    <div className="w-full h-full flex flex-col">
      {/* Toolbar */}
      <div className="p-3 border-b border-gray-200 flex justify-between items-center">
        <div className="flex space-x-2 items-center">
          <span className="text-sm font-semibold mr-2">Add:</span>
          <button
            onClick={addActor}
            className="px-3 py-1 bg-blue-100 text-blue-700 rounded-md hover:bg-blue-200 flex items-center"
          >
            <Plus size={16} className="mr-1" />
            Actor
          </button>
          <button
            onClick={addParticipant}
            className="px-3 py-1 bg-purple-100 text-purple-700 rounded-md hover:bg-purple-200 flex items-center"
          >
            <Plus size={16} className="mr-1" />
            Object
          </button>
          <span className="text-sm font-semibold mx-2">Message:</span>
          <select
            value={messageType}
            onChange={(e) => setMessageType(e.target.value)}
            className="px-2 py-1 border border-gray-300 rounded text-sm"
          >
            <option value="sync">Synchronous</option>
            <option value="async">Asynchronous</option>
            <option value="return">Return</option>
          </select>
          <button
            onClick={addMessage}
            className="px-3 py-1 bg-indigo-100 text-indigo-700 rounded-md hover:bg-indigo-200 flex items-center"
          >
            <ArrowRight size={16} className="mr-1" />
            Add Message
          </button>
          {selectedElement && (
            <button
              onClick={deleteSelected}
              className="px-3 py-1 bg-red-100 text-red-700 rounded-md hover:bg-red-200 flex items-center"
            >
              <Trash2 size={16} className="mr-1" />
              Delete
            </button>
          )}
        </div>
        
        {selectedElement && (
          <div className="flex items-center space-x-2">
            {isEditing ? (
              <div className="flex items-center">
                <input
                  type="text"
                  value={editingLabel}
                  onChange={(e) => setEditingLabel(e.target.value)}
                  className="border border-gray-300 rounded-l px-2 py-1 text-sm"
                  autoFocus
                />
                <button
                  onClick={saveLabel}
                  className="px-3 py-1 bg-green-500 text-white rounded-r hover:bg-green-600 text-sm"
                >
                  Save
                </button>
              </div>
            ) : (
              <button
                onClick={startEditing}
                className="px-3 py-1 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 flex items-center"
              >
                <Edit size={16} className="mr-1" />
                Rename
              </button>
            )}
          </div>
        )}
      </div>
      
      {/* Diagram Area */}
      <div className="flex-1 h-full relative" style={{ touchAction: 'none' }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          onNodeClick={onNodeClick}
          onEdgeClick={onEdgeClick}
          nodeTypes={nodeTypes}
          edgeTypes={edgeTypes}
          fitView
          minZoom={0.3}
          maxZoom={2}
          defaultEdgeOptions={{
            type: 'message'
          }}
        >
          <Controls />
          <Background variant="dots" size={1} gap={16} color="#f0f0f0" />
          <Panel position="bottom-right" className="bg-white py-1 px-2 rounded shadow text-xs text-gray-500">
            Time flows downward
          </Panel>
        </ReactFlow>
        
        {/* Simple instructions */}
        <div className="absolute top-2 left-2 bg-white p-2 rounded shadow-md border border-gray-200 text-xs">
          <p>• Click on elements to select them</p>
          <p>• Use the Rename button to edit labels</p>
          <p>• Connect lifelines (vertical lines) to create messages</p>
          <p>• Drag actors/objects horizontally to arrange them</p>
        </div>
      </div>
    </div>
  );
};

// Wrap with provider at the export level
const SequenceDiagramWrapped = (props) => (
  <ReactFlowProvider>
    <SequenceDiagram {...props} />
  </ReactFlowProvider>
);

export default SequenceDiagramWrapped;


================================================================================
# FILE: client\components\diagram\utils\conversion.js
# EXTENSION: .js
================================================================================
// client/components/diagram/utils/conversion.js
import { MarkerType } from 'reactflow';

// Node shape mappings from Mermaid syntax to node types
const MERMAID_NODE_TYPES = {
  '(': 'cache',           // Circle = Cache
  '[': 'service',         // Rectangle = Service
  '[[': 'service',        // Rectangle = Service variant
  '{': 'loadBalancer',    // Diamond = Load Balancer
  '((': 'database',       // Database
  '>': 'client',          // Flag shape = Client
  '([': 'queue'           // Stadium shape = Queue
};

// Extract node type from Mermaid syntax
const getNodeType = (mermaidNodeDef) => {
  // Check for standard brackets that define node shapes in Mermaid
  for (const [bracket, type] of Object.entries(MERMAID_NODE_TYPES)) {
    if (mermaidNodeDef.includes(`${bracket}`)) {
      return type;
    }
  }
  
  // Check for explicit node type if present in the node id (e.g., database_1234 = database)
  const lowerNodeDef = mermaidNodeDef.toLowerCase();
  if (lowerNodeDef.includes('database')) return 'database';
  if (lowerNodeDef.includes('client')) return 'client';
  if (lowerNodeDef.includes('service')) return 'service';
  if (lowerNodeDef.includes('cache')) return 'cache';
  if (lowerNodeDef.includes('queue')) return 'queue';
  if (lowerNodeDef.includes('loadbalancer') || lowerNodeDef.includes('load_balancer')) return 'loadBalancer';
  
  // Default to service if no type is detected
  return 'service';
};

// Extract node label from Mermaid node definition
const getNodeLabel = (nodeText) => {
  // Check for bracket notation with label: Node["Label"]
  const bracketLabelMatch = nodeText.match(/\["([^"]+)"\]/);
  if (bracketLabelMatch) {
    return bracketLabelMatch[1];
  }
  
  // Check for parenthesis notation with label: Node("Label")
  const parenLabelMatch = nodeText.match(/\("([^"]+)"\)/);
  if (parenLabelMatch) {
    return parenLabelMatch[1];
  }
  
  // Check for standard label: Node[Label]
  const standardLabelMatch = nodeText.match(/\[([^\]]+)\]/);
  if (standardLabelMatch) {
    return standardLabelMatch[1];
  }
  
  // Check for database label: Node[(Label)]
  const dbLabelMatch = nodeText.match(/\[\(([^)]+)\)\]/);
  if (dbLabelMatch) {
    return dbLabelMatch[1];
  }
  
  // Check for cache label: Node((Label))
  const cacheLabelMatch = nodeText.match(/\(\(([^)]+)\)\)/);
  if (cacheLabelMatch) {
    return cacheLabelMatch[1];
  }
  
  // Check for client label: Node>Label]
  const clientLabelMatch = nodeText.match(/>([^]]+)\]/);
  if (clientLabelMatch) {
    return clientLabelMatch[1];
  }
  
  // Check for queue label: Node([Label])
  const queueLabelMatch = nodeText.match(/\(\[([^\]]+)\]\)/);
  if (queueLabelMatch) {
    return queueLabelMatch[1];
  }
  
  // If no specific label format is found, use the node ID as label
  return nodeText;
};

// Convert Mermaid diagram code to ReactFlow nodes and edges
export const mermaidToReactFlow = (mermaidCode) => {
  if (!mermaidCode) {
    return { nodes: [], edges: [] };
  }
  
  const nodes = [];
  const edges = [];
  const nodeMap = {};
  
  try {
    // Split the Mermaid code into lines
    const lines = mermaidCode.split('\n');
    
    // Process each line
    lines.forEach((line, lineIndex) => {
      // Skip empty lines, comments, and the graph definition line
      const trimmedLine = line.trim();
      if (!trimmedLine || trimmedLine.startsWith('%') || trimmedLine.startsWith('graph ')) {
        return;
      }
      
      // Check if the line defines a node
      if (!trimmedLine.includes('-->') && !trimmedLine.includes('---') && !trimmedLine.includes('~~~')) {
        const nodeParts = trimmedLine.split('=');
        const nodeId = nodeParts[0].trim();
        const nodeDef = nodeParts.length > 1 ? nodeParts[1].trim() : nodeId;
        
        // Skip if this is not a node definition
        if (!nodeId || nodeId.includes(' ')) {
          return;
        }
        
        const type = getNodeType(nodeDef);
        
        // Extract the label from the node definition
        let label = getNodeLabel(nodeDef);
        
        // If label was not found using the special formats, try to extract from the Mermaid syntax
        if (label === nodeId && nodeDef !== nodeId) {
          // Extract text between brackets, parentheses or other syntax markers
          const simpleMatch = nodeDef.match(/\[(.*?)\]|\((.*?)\)|{(.*?)}|>(.*?)]/);
          if (simpleMatch) {
            label = simpleMatch.find(match => match && match !== nodeDef) || nodeId;
          }
        }
        
        // Create the ReactFlow node
        const node = {
          id: nodeId,
          type: type,
          position: { 
            x: 150 + (lineIndex * 50), 
            y: 100 + (lineIndex * 50) 
          },
          data: { 
            label: label || nodeId,
            notes: ''
          }
        };
        
        nodes.push(node);
        nodeMap[nodeId] = node;
      }
      // Check if the line defines an edge
      else if (trimmedLine.includes('-->') || trimmedLine.includes('---')) {
        const isDirected = trimmedLine.includes('-->');
        const edgeParts = isDirected 
          ? trimmedLine.split('-->') 
          : trimmedLine.split('---');
        
        if (edgeParts.length >= 2) {
          const sourceId = edgeParts[0].trim();
          const targetId = edgeParts[1].trim();
          
          // Extract label if present
          let label = '';
          const labelMatch = targetId.match(/\|([^|]+)\|/);
          if (labelMatch) {
            label = labelMatch[1].trim();
          }
          
          // Clean up target ID if it contains a label
          const cleanTargetId = targetId.split('|')[0].trim();
          
          // Create the ReactFlow edge
          const edge = {
            id: `edge-${sourceId}-${cleanTargetId}`,
            source: sourceId,
            target: cleanTargetId,
            label: label,
            type: 'smoothstep',
            markerEnd: isDirected ? { type: MarkerType.ArrowClosed } : undefined
          };
          
          edges.push(edge);
        }
      }
    });
    
    // If nodes have position data from a previous ReactFlow state, use it
    // Otherwise, arrange nodes in a simple grid
    if (nodes.length > 0 && !nodes[0].position) {
      const gridSize = Math.ceil(Math.sqrt(nodes.length));
      nodes.forEach((node, index) => {
        const row = Math.floor(index / gridSize);
        const col = index % gridSize;
        node.position = {
          x: 150 + (col * 200),
          y: 100 + (row * 150)
        };
      });
    }
    
    return { nodes, edges };
  } catch (error) {
    console.error('Error converting Mermaid to ReactFlow:', error);
    throw new Error(`Failed to convert Mermaid to ReactFlow: ${error.message}`);
  }
};

// Convert ReactFlow nodes and edges to Mermaid diagram code
export const reactFlowToMermaid = ({ nodes, edges }) => {
  if (!nodes || !edges) {
    return 'graph TD\n    A[Empty Diagram]';
  }
  
  try {
    let mermaidCode = 'graph TD\n';
    
    // Define node shapes based on type
    const nodeShapes = {
      database: '[(Database)]',
      service: '[Service]',
      client: '>Client]',
      cache: '((Cache))',
      loadBalancer: '{Load Balancer}',
      queue: '([Queue])',
      custom: '[Custom]'
    };
    
    // Add nodes
    nodes.forEach(node => {
      const label = node.data.label || node.id;
      const type = node.type || 'service';
      
      // Get the base shape for this node type
      let shape = nodeShapes[type] || '[Node]';
      
      // Replace the default label with the custom label (but keep the brackets/shape)
      const openBracket = shape.indexOf('[');
      const closeBracket = shape.lastIndexOf(']');
      
      if (openBracket >= 0 && closeBracket > openBracket) {
        shape = shape.substring(0, openBracket + 1) + label + shape.substring(closeBracket);
      } else {
        // For shapes that don't use square brackets
        const openParen = shape.indexOf('(');
        const closeParen = shape.lastIndexOf(')');
        
        if (openParen >= 0 && closeParen > openParen) {
          shape = shape.substring(0, openParen + 1) + label + shape.substring(closeParen);
        } else {
          // For other shapes like diamond
          const openBrace = shape.indexOf('{');
          const closeBrace = shape.lastIndexOf('}');
          
          if (openBrace >= 0 && closeBrace > openBrace) {
            shape = shape.substring(0, openBrace + 1) + label + shape.substring(closeBrace);
          } else {
            // Fallback: just add label in square brackets
            shape = `[${label}]`;
          }
        }
      }
      
      mermaidCode += `    ${node.id}${shape}\n`;
    });
    
    // Add edges
    edges.forEach(edge => {
      const arrow = '-->'; // Use directed arrows
      
      if (edge.label) {
        mermaidCode += `    ${edge.source} ${arrow} |${edge.label}| ${edge.target}\n`;
      } else {
        mermaidCode += `    ${edge.source} ${arrow} ${edge.target}\n`;
      }
    });
    
    return mermaidCode;
  } catch (error) {
    console.error('Error converting ReactFlow to Mermaid:', error);
    throw new Error(`Failed to convert ReactFlow to Mermaid: ${error.message}`);
  }
};


================================================================================
# FILE: client\components\diagram\utils\nodePresets.js
# EXTENSION: .js
================================================================================
// client/components/diagram/utils/nodePresets.js

/**
 * Node presets for system design components
 * These are used to create consistent node types for the diagram editor
 */
export const NODE_TYPES = {
    CLIENT: 'client',
    SERVICE: 'service',
    DATABASE: 'database',
    CACHE: 'cache',
    LOAD_BALANCER: 'loadBalancer',
    QUEUE: 'queue',
    CUSTOM: 'custom'
  };
  
  /**
   * Creates a new node with a unique ID based on the node type
   * @param {string} type - The type of node (from NODE_TYPES)
   * @param {object} position - The position {x, y} of the node
   * @param {string} label - The label text for the node
   * @param {string} notes - Optional notes for the node
   * @returns {object} - A React Flow node object
   */
  export const createNode = (type, position, label = '', notes = '') => {
    const nodeLabels = {
      [NODE_TYPES.CLIENT]: 'Client',
      [NODE_TYPES.SERVICE]: 'Service',
      [NODE_TYPES.DATABASE]: 'Database',
      [NODE_TYPES.CACHE]: 'Cache',
      [NODE_TYPES.LOAD_BALANCER]: 'Load Balancer',
      [NODE_TYPES.QUEUE]: 'Queue',
      [NODE_TYPES.CUSTOM]: 'Custom Component'
    };
    
    // Use provided label or default
    const nodeLabel = label || nodeLabels[type] || 'Node';
    
    return {
      id: `${type}_${Date.now()}`,
      type,
      position,
      data: {
        label: nodeLabel,
        notes
      }
    };
  };
  
  /**
   * Creates a connection between two nodes
   * @param {string} sourceId - The ID of the source node
   * @param {string} targetId - The ID of the target node
   * @param {string} label - Optional label for the connection
   * @returns {object} - A React Flow edge object
   */
  export const createEdge = (sourceId, targetId, label = '') => {
    return {
      id: `edge-${sourceId}-${targetId}`,
      source: sourceId,
      target: targetId,
      label,
      type: 'smoothstep',
      animated: false,
      style: { strokeWidth: 2 }
    };
  };
  
  /**
   * Returns a palette of node type options for the editor UI
   */
  export const getNodeTypePalette = () => [
    {
      type: NODE_TYPES.CLIENT,
      label: 'Client',
      description: 'User-facing components like web browsers or mobile apps',
      color: 'blue'
    },
    {
      type: NODE_TYPES.SERVICE,
      label: 'Service',
      description: 'Backend services that process business logic',
      color: 'green'
    },
    {
      type: NODE_TYPES.DATABASE,
      label: 'Database',
      description: 'Data storage systems (SQL, NoSQL, etc.)',
      color: 'purple'
    },
    {
      type: NODE_TYPES.CACHE,
      label: 'Cache',
      description: 'In-memory data stores for quick access (Redis, Memcached)',
      color: 'red'
    },
    {
      type: NODE_TYPES.LOAD_BALANCER,
      label: 'Load Balancer',
      description: 'Distributes network traffic across multiple servers',
      color: 'orange'
    },
    {
      type: NODE_TYPES.QUEUE,
      label: 'Queue',
      description: 'Message queues for asynchronous processing',
      color: 'indigo'
    },
    {
      type: NODE_TYPES.CUSTOM,
      label: 'Custom',
      description: 'Custom component with user-defined functionality',
      color: 'gray'
    }
  ];


================================================================================
# FILE: client\components\evaluation\EvaluationSummary.js
# EXTENSION: .js
================================================================================
// client/components/evaluation/EvaluationSummary.js
import React, { useState } from 'react';
import { ChevronDown, ChevronUp, Award, AlertTriangle, Check } from 'lucide-react';

const EvaluationSummary = ({ evaluation, scores }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  
  if (!evaluation) return null;
  
  // Extract overall score
  const overallScore = scores?.overall?.score || 0;
  
  // Determine score color
  const getScoreColor = (score) => {
    if (score >= 90) return 'text-green-600';
    if (score >= 75) return 'text-blue-600';
    if (score >= 60) return 'text-yellow-600';
    return 'text-red-600';
  };
  
  // Extract priority improvements section if present
  const priorityMatch = /Priority Improvements:[^\n]*\n((?:[\d\.\s]+[^\n]+\n)+)/i.exec(evaluation);
  const priorities = priorityMatch ? priorityMatch[1].trim() : '';
  
  // Extract strengths section if present
  const strengthsMatch = /Strengths:[^\n]*\n((?:\*\s+[^\n]+\n)+)/i.exec(evaluation);
  const strengths = strengthsMatch ? strengthsMatch[1].trim() : '';
  
  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <div className="flex justify-between items-center mb-4">
        <div className="flex items-center">
          <Award size={20} className="text-indigo-600 mr-2" />
          <h2 className="text-xl font-bold text-gray-900">Evaluation Summary</h2>
        </div>
        <div className={`text-3xl font-bold ${getScoreColor(overallScore)}`}>
          {overallScore}/100
        </div>
      </div>
      
      {/* Extract and display the summary paragraph */}
      <div className="mb-4">
        <h3 className="text-lg font-medium text-gray-900 mb-2">Overall Assessment</h3>
        <p className="text-gray-700">
          {evaluation.split(/\n\n/)[0].replace(/^.*Overall Score:.*\n/, '').trim()}
        </p>
      </div>
      
      {/* Display strengths if available */}
      {strengths && (
        <div className="mb-4">
          <h3 className="text-lg font-medium text-gray-900 mb-2 flex items-center">
            <Check size={16} className="text-green-500 mr-2" />
            Strengths
          </h3>
          <div className="pl-4 border-l-4 border-green-500">
            {strengths.split('\n').map((item, index) => (
              <p key={index} className="mb-2 text-gray-700">{item}</p>
            ))}
          </div>
        </div>
      )}
      
      {/* Display priority improvements if available */}
      {priorities && (
        <div className="mb-4">
          <h3 className="text-lg font-medium text-gray-900 mb-2 flex items-center">
            <AlertTriangle size={16} className="text-amber-500 mr-2" />
            Priority Improvements
          </h3>
          <div className="pl-4 border-l-4 border-amber-500">
            {priorities.split('\n').map((item, index) => (
              <p key={index} className="mb-2 text-gray-700">{item}</p>
            ))}
          </div>
        </div>
      )}
      
      {/* Expand/collapse full evaluation */}
      <div className="mt-4 pt-4 border-t border-gray-200">
        <button 
          onClick={() => setIsExpanded(!isExpanded)}
          className="flex items-center text-indigo-600 hover:text-indigo-800 font-medium"
        >
          {isExpanded ? (
            <>
              <ChevronUp size={18} className="mr-1" />
              Hide Full Evaluation
            </>
          ) : (
            <>
              <ChevronDown size={18} className="mr-1" />
              View Full Evaluation
            </>
          )}
        </button>
        
        {isExpanded && (
          <div className="mt-4 p-4 bg-gray-50 rounded-md">
            <pre className="whitespace-pre-wrap text-sm text-gray-700">
              {evaluation}
            </pre>
          </div>
        )}
      </div>
      
      {/* Dimension scores if expanded */}
      {isExpanded && scores && (
        <div className="mt-4 pt-4 border-t border-gray-200">
          <h3 className="text-lg font-medium text-gray-900 mb-2">Dimension Scores</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {Object.entries(scores)
              .filter(([key]) => key !== 'overall')
              .map(([dimension, { score, maxScore }]) => (
                <div key={dimension} className="bg-gray-100 p-3 rounded-lg">
                  <div className="flex justify-between items-center mb-2">
                    <span className="font-medium text-gray-800">{dimension}</span>
                    <span className={`font-bold ${getScoreColor(score)}`}>{score}/{maxScore}</span>
                  </div>
                  <div className="w-full bg-gray-300 rounded-full h-2">
                    <div 
                      className={`h-2 rounded-full ${getScoreColor(score).replace('text-', 'bg-')}`}
                      style={{ width: `${(score / maxScore) * 100}%` }}
                    ></div>
                  </div>
                </div>
              ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default EvaluationSummary;


================================================================================
# FILE: client\components\ExperienceLevelSelector.js
# EXTENSION: .js
================================================================================
// client/components/ExperienceLevelSelector.js
import React from 'react';
import { User } from 'lucide-react';

const ExperienceLevelSelector = ({ currentLevel, onLevelChange }) => {
  return (
    <div className="p-4 bg-white rounded-lg shadow-sm border border-gray-200">
      <h3 className="text-lg font-medium text-gray-900 mb-2">Experience Level</h3>
      <div className="flex items-center space-x-2 mb-2">
        <User size={18} className="text-gray-500" />
        <span className="text-sm text-gray-600">Select your experience level</span>
      </div>
      <select 
        value={currentLevel} 
        onChange={(e) => onLevelChange(e.target.value)}
        className="block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
      >
        <option value="junior">Junior Engineer</option>
        <option value="mid-level">Mid-Level Engineer</option>
        <option value="senior">Senior Engineer</option>
        <option value="staff+">Staff+ Engineer</option>
      </select>
    </div>
  );
};

export default ExperienceLevelSelector;


================================================================================
# FILE: client\components\MermaidToolbar.js
# EXTENSION: .js
================================================================================
// client/components/MermaidToolbar.js
import React from 'react';
import { Database, Server, Globe, Archive, Grid, Box, Share2, ArrowRight } from 'lucide-react';

const ComponentButton = ({ icon, label, snippet, onInsert }) => (
  <button
    onClick={() => onInsert(snippet)}
    className="flex flex-col items-center p-2 bg-white border border-gray-200 rounded shadow-sm hover:bg-blue-50 hover:border-blue-200 transition-colors w-20 h-20"
  >
    {icon}
    <span className="text-xs mt-2 text-center">{label}</span>
  </button>
);

const MermaidToolbar = ({ onInsert }) => {
  const components = [
    {
      icon: <Globe className="h-5 w-5 text-blue-600" />,
      label: "Client",
      snippet: "Client[Client] --> API"
    },
    {
      icon: <Server className="h-5 w-5 text-green-600" />,
      label: "Server",
      snippet: "Server[API Server]"
    },
    {
      icon: <Database className="h-5 w-5 text-purple-600" />,
      label: "Database",
      snippet: "DB[(Database)]"
    },
    {
      icon: <Archive className="h-5 w-5 text-red-600" />,
      label: "Cache",
      snippet: "Cache[(Cache)]"
    },
    {
      icon: <Grid className="h-5 w-5 text-orange-600" />,
      label: "Load Balancer",
      snippet: "LB{Load Balancer}"
    },
    {
      icon: <Box className="h-5 w-5 text-teal-600" />,
      label: "Microservice",
      snippet: "Service[Microservice]"
    },
    {
      icon: <Share2 className="h-5 w-5 text-indigo-600" />,
      label: "Queue",
      snippet: "Queue([Message Queue])"
    },
    {
      icon: <ArrowRight className="h-5 w-5 text-gray-600" />,
      label: "Connection",
      snippet: "A --> B"
    }
  ];

  return (
    <div className="flex flex-wrap gap-2">
      {components.map((component, index) => (
        <ComponentButton
          key={index}
          icon={component.icon}
          label={component.label}
          snippet={component.snippet}
          onInsert={onInsert}
        />
      ))}
    </div>
  );
};

export default MermaidToolbar;


================================================================================
# FILE: client\components\MetricCard.js
# EXTENSION: .js
================================================================================
import React from 'react';

const MetricCard = ({ title, value, icon, iconBgColor, progress, subtext }) => {
  return (
    <div className="bg-white rounded-xl shadow-sm border border-slate-200 p-6">
      <div className="flex items-center gap-3 mb-1">
        <div className={`h-10 w-10 rounded-lg ${iconBgColor} flex items-center justify-center`}>
          {icon}
        </div>
        <div>
          <h3 className="text-sm text-slate-500 font-medium">{title}</h3>
          <p className="text-2xl font-bold text-slate-900">{value}</p>
        </div>
      </div>
      
      {progress !== undefined && (
        <div className="w-full h-2 bg-slate-100 rounded-full mt-4">
          <div 
            className="h-2 bg-indigo-500 rounded-full" 
            style={{ width: `${progress}%` }}
          ></div>
        </div>
      )}
      
      {subtext && (
        <div className="text-sm text-slate-500 mt-4">
          {subtext}
        </div>
      )}
    </div>
  );
};

export default MetricCard;


================================================================================
# FILE: client\components\Sidebar.js
# EXTENSION: .js
================================================================================
import React from 'react';
import { useRouter } from 'next/router';
import { Book, BarChart2, Award, Layout, Clock, Activity, School } from 'lucide-react';
import { useAuth } from '../contexts/AuthContext';

const Sidebar = ({ activeTab }) => {
  const router = useRouter();
  const { user, logout } = useAuth();

  return (
    <div className="w-64 bg-slate-900 text-white p-4 flex flex-col h-full">
      <div className="flex items-center gap-3 mb-10">
        <div className="h-8 w-8 rounded-md bg-indigo-500 flex items-center justify-center">
          <Layout className="h-5 w-5 text-white" />
        </div>
        <h1 className="text-xl font-bold">System Design Coach</h1>
      </div>
      
      <div className="space-y-1">
        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'home' ? 'bg-indigo-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/dashboard')}
        >
          <div className="flex items-center">
            <Layout className="mr-3 h-4 w-4" />
            Dashboard
          </div>
        </button>
        
        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'problems' ? 'bg-indigo-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/problems')}
        >
          <div className="flex items-center">
            <Book className="mr-3 h-4 w-4" />
            Design Problems
          </div>
        </button>
        
        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'progress' ? 'bg-indigo-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/progress')}
        >
          <div className="flex items-center">
            <BarChart2 className="mr-3 h-4 w-4" />
            My Progress
          </div>
        </button>
        
        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'certs' ? 'bg-indigo-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/certifications')}
        >
          <div className="flex items-center">
            <Award className="mr-3 h-4 w-4" />
            Certifications
          </div>
        </button>

        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'coaching' ? 'bg-green-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/coaching')}
        >
          <div className="flex items-center">
            <School className="mr-3 h-4 w-4" />
            <span>Coaching Sessions</span>
          </div>
        </button>

        <button 
          className={`w-full text-left px-3 py-2 rounded ${activeTab === 'interviews' ? 'bg-indigo-700 text-white' : 'text-slate-300 hover:bg-slate-800'}`}
          onClick={() => router.push('/interviews')}
        >
          <div className="flex items-center">
            <Activity className="mr-3 h-4 w-4" />
            <span>Practice Interviews</span>
          </div>
        </button>
        
        
      </div>
      
      <div className="mt-auto">
        <div className="bg-slate-800 rounded-lg p-4 text-sm">
          <div className="flex items-center justify-between mb-3">
            <span className="font-medium">Pro Plan</span>
            <span className="bg-emerald-600 text-white px-2 py-1 rounded text-xs">Active</span>
          </div>
          <div className="flex items-center gap-2 text-slate-300 mb-3">
            <Clock className="h-4 w-4" />
            <span>Unlimited access</span>
          </div>
          <button 
            className="bg-slate-700 hover:bg-slate-600 text-sm text-white w-full py-2 rounded"
            onClick={logout}
          >
            Sign Out
          </button>
        </div>
      </div>
    </div>
  );
};

export default Sidebar;


================================================================================
# FILE: client\components\SimpleFlow.js
# EXTENSION: .js
================================================================================
import React from 'react';
import ReactFlow, { ReactFlowProvider, Background, Controls } from 'reactflow';
import 'reactflow/dist/style.css';

const initialNodes = [
  { id: '1', position: { x: 100, y: 100 }, data: { label: 'Hello' } },
  { id: '2', position: { x: 200, y: 200 }, data: { label: 'World' } }
];

const initialEdges = [
  { id: 'e1-2', source: '1', target: '2' }
];

function Flow() {
  // Debug logging
  console.log("SimpleFlow rendering with:", initialNodes, initialEdges);
  
  return (
    <div style={{width: '100%', height: '100%', position: 'relative'}}>
      <ReactFlow 
        nodes={initialNodes}
        edges={initialEdges}
        fitView
      >
        <Controls />
        <Background />
      </ReactFlow>
    </div>
  );
}

export default function SimpleFlowWithProvider() {
  return (
    <ReactFlowProvider>
      <Flow />
    </ReactFlowProvider>
  );
}


================================================================================
# FILE: client\components\SystemDesignDiagram.tsx
# EXTENSION: .tsx
================================================================================
import React, { useCallback, useState, useEffect } from 'react';
import ReactFlow, {
  Controls,
  Background,
  addEdge,
  Connection,
  NodeTypes,
  applyNodeChanges,
  applyEdgeChanges,
  Node,
  Edge,
  NodeChange,
  EdgeChange
} from 'reactflow';
import 'reactflow/dist/style.css';
import mermaid from 'mermaid';
import { Server, Database, CloudLightning, Router, Lock } from 'lucide-react';

// Custom Node Types with Detailed Rendering
const nodeTypes: NodeTypes = {
  infrastructureNode: ({ data }) => (
    <div className="bg-blue-100 p-2 rounded border border-blue-300 flex items-center">
      {data.icon}
      <span className="ml-2">{data.label}</span>
    </div>
  ),
  computationNode: ({ data }) => (
    <div className="bg-green-100 p-2 rounded border border-green-300 flex items-center">
      {data.icon}
      <span className="ml-2">{data.label}</span>
    </div>
  ),
  dataNode: ({ data }) => (
    <div className="bg-purple-100 p-2 rounded border border-purple-300 flex items-center">
      {data.icon}
      <span className="ml-2">{data.label}</span>
    </div>
  ),
};

// Sidebar Component for Adding System Design Components
const SystemDesignSidebar: React.FC<{ onAddNode: (type: string, label: string) => void }> = ({ onAddNode }) => {
  const componentTypes = [
    { 
      type: 'infrastructureNode', 
      label: 'Load Balancer', 
      icon: <Router className="h-5 w-5 text-blue-600" />,
      category: 'Infrastructure'
    },
    { 
      type: 'computationNode', 
      label: 'Web Server', 
      icon: <Server className="h-5 w-5 text-green-600" />,
      category: 'Computation'
    },
    { 
      type: 'dataNode', 
      label: 'Database', 
      icon: <Database className="h-5 w-5 text-purple-600" />,
      category: 'Data'
    },
    { 
      type: 'infrastructureNode', 
      label: 'API Gateway', 
      icon: <CloudLightning className="h-5 w-5 text-blue-600" />,
      category: 'Infrastructure'
    },
    { 
      type: 'infrastructureNode', 
      label: 'Authentication', 
      icon: <Lock className="h-5 w-5 text-blue-600" />,
      category: 'Infrastructure'
    }
  ];

  return (
    <div className="w-64 p-4 bg-gray-50 border-r">
      <h2 className="text-lg font-bold mb-4">Components</h2>
      {componentTypes.map((component, index) => (
        <button
          key={index}
          onClick={() => onAddNode(component.type, component.label)}
          className="flex items-center w-full p-2 hover:bg-gray-100 rounded mb-2"
        >
          {component.icon}
          <span className="ml-2 text-sm">{component.label}</span>
          <span className="ml-auto text-xs text-gray-500">{component.category}</span>
        </button>
      ))}
    </div>
  );
};

const SystemDesignDiagram: React.FC = () => {
  // State management for nodes and edges using regular useState
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);

  // Handler for node changes
  const onNodesChange = useCallback(
    (changes: NodeChange[]) => {
      setNodes(nds => applyNodeChanges(changes, nds));
    },
    []
  );

  // Handler for edge changes
  const onEdgesChange = useCallback(
    (changes: EdgeChange[]) => {
      setEdges(eds => applyEdgeChanges(changes, eds));
    },
    []
  );

  // Handle connections between nodes
  const onConnect = useCallback(
    (connection: Connection) => {
      const newEdge = { 
        ...connection, 
        id: `edge-${connection.source}-${connection.target}`,
        type: 'default',
        animated: true 
      };

      setEdges((eds) => addEdge(newEdge, eds));
    },
    []
  );

  // Add a new node to the diagram
  const handleAddNode = useCallback((type: string, label: string) => {
    const newNode = {
      id: `node-${Date.now()}`,
      type,
      data: { 
        label, 
        icon: type === 'infrastructureNode' ? <Router className="h-5 w-5 text-blue-600" /> :
               type === 'computationNode' ? <Server className="h-5 w-5 text-green-600" /> :
               <Database className="h-5 w-5 text-purple-600" />
      },
      position: { 
        x: Math.random() * 500, 
        y: Math.random() * 500 
      },
    };

    setNodes((prevNodes) => [...prevNodes, newNode]);
  }, []);

  // Generate Mermaid code for the current diagram
  const generateMermaidCode = useCallback(() => {
    const nodeLines = nodes.map(
      (node) => `${node.id}[${node.data.label}]`
    );
    const edgeLines = edges.map(
      (edge) => `${edge.source} --> ${edge.target}`
    );

    return `graph TD\n${[...nodeLines, ...edgeLines].join('\n')}`;
  }, [nodes, edges]);

  // Render Mermaid diagram
  const renderMermaidDiagram = useCallback(async () => {
    try {
      mermaid.initialize({ 
        startOnLoad: false,
        theme: 'default'
      });

      const { svg } = await mermaid.render('mermaid-diagram', generateMermaidCode());
      return svg;
    } catch (error) {
      console.error('Mermaid rendering error', error);
      return '';
    }
  }, [generateMermaidCode]);

  // Render the system design diagram
  return (
    <div className="flex h-screen">
      <SystemDesignSidebar onAddNode={handleAddNode} />
      <div className="flex-1">
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          nodeTypes={nodeTypes}
          fitView
        >
          <Controls />
          <Background color="#f0f0f0" />
        </ReactFlow>
      </div>
    </div>
  );
};

export default SystemDesignDiagram;


================================================================================
# FILE: client\contexts\AuthContext.js
# EXTENSION: .js
================================================================================
// client/contexts/AuthContext.js
import React, { createContext, useState, useContext, useEffect } from 'react';
import { useRouter } from 'next/router';
import Cookies from 'js-cookie';
import { loginUser, registerUser, getMe } from '../utils/api';

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const router = useRouter();
  
  // Check if user is authenticated on mount
  useEffect(() => {
    const initAuth = async () => {
      const token = Cookies.get('auth_token');
      
      if (token) {
        try {
          const userData = await getMe();
          setUser(userData.user);
          setIsAuthenticated(true);
        } catch (error) {
          console.error('Auth init error:', error);
          Cookies.remove('auth_token');
        }
      }
      
      setIsLoading(false);
    };
    
    initAuth();
  }, []);
  
  // Login function
  const login = async (email, password) => {
    try {
      const data = await loginUser(email, password);
      
      // Store token in cookie
      Cookies.set('auth_token', data.token, { expires: 7 });
      
      setUser(data.user);
      setIsAuthenticated(true);
      
      return { success: true };
    } catch (error) {
      console.error('Login error:', error);
      return {
        success: false,
        error: error.response?.data?.error || 'Login failed'
      };
    }
  };
  
  // Register function
  const register = async (name, email, password, experience) => {
    try {
      const data = await registerUser(name, email, password, experience);
      
      // Store token in cookie
      Cookies.set('auth_token', data.token, { expires: 7 });
      
      setUser(data.user);
      setIsAuthenticated(true);
      
      return { success: true };
    } catch (error) {
      console.error('Register error:', error);
      return {
        success: false,
        error: error.response?.data?.error || 'Registration failed'
      };
    }
  };
  
  // Logout function
  const logout = () => {
    Cookies.remove('auth_token');
    setUser(null);
    setIsAuthenticated(false);
    router.push('/auth/login');
  };
  
  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        isAuthenticated,
        login,
        register,
        logout,
        setUser
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);

export default AuthContext;


================================================================================
# FILE: client\next.config.js
# EXTENSION: .js
================================================================================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  images: {
    domains: ['images.unsplash.com', 'via.placeholder.com']
  },
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000/api/:path*'
      }
    ];
  },
  webpack: (config) => {
    // Remove any problematic alias for reactflow so Next.js can transpile it properly.
    config.resolve.fallback = { fs: false, net: false, tls: false };
    return config;
  }
};

module.exports = nextConfig;



================================================================================
# FILE: client\pages\_app.js
# EXTENSION: .js
================================================================================
import '../styles/globals.css';
import { AuthProvider } from '../contexts/AuthContext';

function MyApp({ Component, pageProps }) {
  return (
    <AuthProvider>
      <Component {...pageProps} />
    </AuthProvider>
  );
}

export default MyApp;


================================================================================
# FILE: client\pages\APIDesignPage.js
# EXTENSION: .js
================================================================================
// client/components/APIDesignPage.js
import React, { useState } from 'react';

const APIDesignPage = ({ data = {}, updateData }) => {
  const [formState, setFormState] = useState({
    apiEndpoints: data.apiEndpoints || '',
    authMethod: data.authMethod || '',
    rateLimit: data.rateLimit || '',
    requestResponse: data.requestResponse || ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    const newState = { ...formState, [name]: value };
    setFormState(newState);
    if (updateData) {
      updateData(newState);
    }
  };

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-bold text-gray-900">API Design</h2>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          API Endpoints
        </label>
        <textarea
          name="apiEndpoints"
          value={formState.apiEndpoints}
          onChange={handleChange}
          rows={6}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="List key API endpoints with HTTP methods and purposes..."
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Authentication & Authorization
        </label>
        <textarea
          name="authMethod"
          value={formState.authMethod}
          onChange={handleChange}
          rows={3}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="Auth methods, token handling, permissions..."
        />
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Rate Limiting & Quotas
          </label>
          <textarea
            name="rateLimit"
            value={formState.rateLimit}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="API rate limits, quotas, throttling policies..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Request/Response Format
          </label>
          <textarea
            name="requestResponse"
            value={formState.requestResponse}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="JSON structure, pagination, error handling..."
          />
        </div>
      </div>
    </div>
  );
};

export default APIDesignPage;


================================================================================
# FILE: client\pages\auth\login.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import { Layout } from 'lucide-react';
import { useAuth } from '../../contexts/AuthContext';

export default function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const { login, isAuthenticated } = useAuth();
  const router = useRouter();
  
  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated) {
      router.push('/dashboard');
    }
  }, [isAuthenticated, router]);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setIsSubmitting(true);
    
    const result = await login(email, password);
    
    if (result.success) {
      router.push('/dashboard');
    } else {
      setError(result.error);
    }
    
    setIsSubmitting(false);
  };
  
  return (
    <div className="min-h-screen bg-slate-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-xl shadow-md p-8 w-full max-w-md">
        <div className="flex justify-center mb-6">
          <div className="h-12 w-12 rounded-md bg-indigo-500 flex items-center justify-center">
            <Layout className="h-8 w-8 text-white" />
          </div>
        </div>
        
        <h1 className="text-2xl font-bold text-center mb-6">Sign in to System Design Coach</h1>
        
        {error && (
          <div className="mb-4 p-3 bg-red-50 text-red-700 rounded border border-red-200">
            {error}
          </div>
        )}
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-slate-700 mb-1">
              Email address
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-slate-700 mb-1">
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          
          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:opacity-50"
          >
            {isSubmitting ? 'Signing in...' : 'Sign in'}
          </button>
        </form>
        
        <div className="mt-6 text-center text-sm">
          <span className="text-slate-600">Don't have an account?</span>{' '}
          <Link href="/auth/register" className="text-indigo-600 hover:text-indigo-800 font-medium">
            Sign up
          </Link>
        </div>
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\auth\register.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import { Layout } from 'lucide-react';
import { useAuth } from '../../contexts/AuthContext';

export default function Register() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [experience, setExperience] = useState('intermediate');
  const [error, setError] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const { register, isAuthenticated } = useAuth();
  const router = useRouter();
  
  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated) {
      router.push('/dashboard');
    }
  }, [isAuthenticated, router]);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    console.log('Registration submitted:', { name, email, experience });
    
    try {
      const result = await register(name, email, password, experience);
      console.log('Registration result:', result);
      
      if (result.success) {
        router.push('/dashboard');
      } else {
        setError(result.error);
      }
    } catch (error) {
      console.error('Registration error:', error);
      setError(error.response?.data?.error || 'Registration failed');
    }
  };
  
  return (
    <div className="min-h-screen bg-slate-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-xl shadow-md p-8 w-full max-w-md">
        <div className="flex justify-center mb-6">
          <div className="h-12 w-12 rounded-md bg-indigo-500 flex items-center justify-center">
            <Layout className="h-8 w-8 text-white" />
          </div>
        </div>
        
        <h1 className="text-2xl font-bold text-center mb-6">Create an Account</h1>
        
        {error && (
          <div className="mb-4 p-3 bg-red-50 text-red-700 rounded border border-red-200">
            {error}
          </div>
        )}
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="name" className="block text-sm font-medium text-slate-700 mb-1">
              Full Name
            </label>
            <input
              id="name"
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-slate-700 mb-1">
              Email address
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-slate-700 mb-1">
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
              required
            />
          </div>
          
          <div>
            <label htmlFor="experience" className="block text-sm font-medium text-slate-700 mb-1">
              Experience Level
            </label>
            <select
              id="experience"
              value={experience}
              onChange={(e) => setExperience(e.target.value)}
              className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
            >
              <option value="beginner">Beginner</option>
              <option value="intermediate">Intermediate</option>
              <option value="senior">Senior</option>
              <option value="expert">Expert</option>
            </select>
          </div>
          
          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full bg-indigo-600 text-white py-2 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:opacity-50"
          >
            {isSubmitting ? 'Creating Account...' : 'Create Account'}
          </button>
        </form>
        
        <div className="mt-6 text-center text-sm">
          <span className="text-slate-600">Already have an account?</span>{' '}
          <Link href="/auth/login" className="text-indigo-600 hover:text-indigo-800 font-medium">
            Sign in
          </Link>
        </div>
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\coaching\[id].js
# EXTENSION: .js
================================================================================
// client/pages/coaching/[id].js
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useRouter } from 'next/router';
import dynamic from 'next/dynamic';
import ReactMarkdown from 'react-markdown';
import {
  ArrowLeft, Save, Send, RefreshCw, MessageSquare, CheckCircle, XCircle, Eye, Edit, 
  ClipboardList, Database, Code, Layout, BarChart, Shield, ChevronDown, ChevronUp
} from 'lucide-react';
import { applyNodeChanges, applyEdgeChanges, addEdge } from 'reactflow';
import { useAuth } from '../../contexts/AuthContext';
import {
  getCoachingSession, sendCoachingMessage, getCoachingMaterials,
  getCoachingDiagram, saveDiagram
} from '../../utils/api';
import { mermaidToReactFlow, reactFlowToMermaid } from '../../components/diagram/utils/conversion';
import TopicGuidedCoaching from '../../components/coaching/TopicGuidedCoaching';

// Import workbook components directly
import RequirementsPage from '../RequirementsPage';
import APIDesignPage from '../APIDesignPage';
import DataModelPage from '../DataModelPage';
import SystemArchitecturePage from '../SystemArchitecturePage';
import ScalingStrategyPage from '../ScalingStrategyPage';
import ReliabilitySecurityPage from '../ReliabilitySecurityPage';

const MermaidRenderer = dynamic(() => import('../../components/diagram/MermaidRenderer'), {
  ssr: false,
  loading: () => <div className="animate-pulse bg-gray-100 h-full w-full"></div>
});

const ReactFlowDiagramWithProvider = dynamic(() => import('../../components/diagram/ReactFlowDiagram'), {
  ssr: false,
  loading: () => (
    <div className="flex h-full items-center justify-center bg-gray-50">
      <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500"></div>
    </div>
  )
});

const SequenceDiagram = dynamic(() => import('../../components/diagram/SequenceDiagram'), {
  ssr: false,
  loading: () => (
    <div className="flex h-full items-center justify-center bg-gray-50">
      <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500"></div>
    </div>
  )
});

const CoachingSessionPage = () => {
  const router = useRouter();
  const { user } = useAuth();
  const messagesEndRef = useRef(null);
  
  // Safely extract session ID from router query
  const sessionId = router.query?.id;

  // Session state
  const [session, setSession] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // UI state
  const [messageInput, setMessageInput] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [activeMaterial, setActiveMaterial] = useState(null);
  const [currentTopic, setCurrentTopic] = useState('REQUIREMENTS');
  const [includeDiagram, setIncludeDiagram] = useState(false);
  const [requestDiagramSuggestions, setRequestDiagramSuggestions] = useState(false);
  
  // Add state for TopicGuidedCoaching collapsible section
  const [topicGuidedOpen, setTopicGuidedOpen] = useState(false);
  
  // Add dropdown reference
  const workbookDropdownRef = useRef(null);
  const [showWorkbookDropdown, setShowWorkbookDropdown] = useState(false);

  // Chat state
  const [messages, setMessages] = useState([]);
  const [isTyping, setIsTyping] = useState(false);

  // Diagram state
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const [diagramCode, setDiagramCode] = useState(
    'graph TD\n    Client[Client] --> API[API Gateway]\n    API --> Service[Service]\n    Service --> DB[(Database)]'
  );
  const [viewMode, setViewMode] = useState('edit');
  const [currentDiagramState, setCurrentDiagramState] = useState(null);
  const [isSavingDiagram, setIsSavingDiagram] = useState(false);
  const [diagramSuggestions, setDiagramSuggestions] = useState(null);
  const [showSuggestions, setShowSuggestions] = useState(false);

  // Workbook state
  const [rightPanelMode, setRightPanelMode] = useState('workbook'); // 'workbook' or 'diagram'
  const [activeWorkbookTab, setActiveWorkbookTab] = useState('requirements');
  const [formData, setFormData] = useState({
    requirements: {},
    api: {},
    data: {},
    architecture: {},
    scaling: {},
    reliability: {}
  });

  // Define workbook tabs
  const workbookTabs = [
    { id: 'requirements', label: 'Requirements', icon: <ClipboardList size={18} /> },
    { id: 'api', label: 'API Design', icon: <Code size={18} /> },
    { id: 'data', label: 'Data Model', icon: <Database size={18} /> },
    { id: 'architecture', label: 'Architecture', icon: <Layout size={18} /> },
    { id: 'scaling', label: 'Scaling Strategy', icon: <BarChart size={18} /> },
    { id: 'reliability', label: 'Reliability & Security', icon: <Shield size={18} /> }
  ];
  
  // Define diagram tabs
  const [diagramTabs, setDiagramTabs] = useState([
    { id: 'flowchart', label: 'Flow Diagram', active: true },
    { id: 'sequence', label: 'Sequence Diagram', active: false }
  ]);
  
  const setActiveDiagramTab = (tabId) => {
    setDiagramTabs(diagramTabs.map(tab => ({
      ...tab,
      active: tab.id === tabId
    })));
  };

  // Update form data
  const updateFormData = (section, data) => {
    setFormData(prev => ({
      ...prev,
      [section]: data
    }));
  };
  
  // Add click outside handler for workbook dropdown
  useEffect(() => {
    function handleClickOutside(event) {
      if (workbookDropdownRef.current && !workbookDropdownRef.current.contains(event.target)) {
        setShowWorkbookDropdown(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [workbookDropdownRef]);

  // Load session data
  useEffect(() => {
    if (!sessionId) return;
    
    const fetchSession = async () => {
      try {
        const data = await getCoachingSession(sessionId);
        console.log('SESSION DATA:', JSON.stringify(data, null, 2));

        const initialMessages = data.conversation 
          ? data.conversation.map((msg, index) => ({
              id: index,
              role: msg.role === 'system' ? 'system' : 
                    msg.role === 'assistant' ? 'assistant' : 'user',
              content: msg.content || "No content available",
              timestamp: msg.timestamp || new Date().toISOString()
            }))
          : [{
              id: 0,
              role: 'assistant',
              content: `Welcome to your ${data.problem?.title || 'system design'} coaching session. Let's begin our system design journey!`,
              timestamp: new Date().toISOString()
            }];

        console.log('INITIAL MESSAGES:', JSON.stringify(initialMessages, null, 2));
        setMessages(initialMessages);
        setSession(data);
        setError(null);
      } catch (err) {
        console.error(`Error fetching coaching session ${sessionId}:`, err);
        setError("Failed to load coaching session");
        setMessages([{
          id: 0,
          role: 'assistant',
          content: "Welcome to your system design coaching session. Let's get started!",
          timestamp: new Date().toISOString()
        }]);
      } finally {
        setLoading(false);
      }
    };

    fetchSession();
  }, [sessionId]);
  
  // Auto-scroll to bottom of messages
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  const detectCurrentTopic = (conversation) => {
    const topicKeywords = {
      'REQUIREMENTS': ['requirements', 'features', 'functional', 'non-functional', 'constraints', 'users', 'scale'],
      'ARCHITECTURE': ['architecture', 'components', 'services', 'monolith', 'microservices', 'api'],
      'STORAGE': ['database', 'storage', 'schema', 'SQL', 'NoSQL', 'cache', 'data model'],
      'SCALABILITY': ['scale', 'scaling', 'load balancing', 'horizontal', 'vertical', 'throughput'],
      'RELIABILITY': ['reliability', 'fault tolerance', 'redundancy', 'availability', 'monitoring']
    };
    const recentMessages = conversation.slice(-5);
    const combinedText = recentMessages.map(msg => typeof msg.content === 'string' ? msg.content.toLowerCase() : '').join(' ');
    let bestTopic = 'REQUIREMENTS';
    let highestCount = 0;
    for (const [topic, keywords] of Object.entries(topicKeywords)) {
      const count = keywords.reduce((sum, keyword) => sum + (combinedText.includes(keyword.toLowerCase()) ? 1 : 0), 0);
      if (count > highestCount) {
        highestCount = count;
        bestTopic = topic;
      }
    }
    setCurrentTopic(bestTopic);
  };

  const handleSendMessage = async (message, contextInfo = null) => {
    if (!message || typeof message !== 'string' || message.trim() === '') {
      console.error("Invalid message:", message);
      return;
    }
    if (!sessionId) {
      console.error("No valid sessionId available");
      return;
    }
    
    setIsSending(true);
    try {
      const userMessage = {
        id: messages.length,
        role: 'user',
        content: message,
        timestamp: new Date().toISOString()
      };
      setMessages(prev => [...prev, userMessage]);

      let finalContextInfo = contextInfo || {};
      if (!finalContextInfo.diagramContext && includeDiagram && currentDiagramState) {
        finalContextInfo.diagramContext = currentDiagramState;
      }
      if (!finalContextInfo.requestDiagramSuggestions && requestDiagramSuggestions) {
        finalContextInfo.requestDiagramSuggestions = true;
      }
      
      setIsTyping(true);
      const response = await sendCoachingMessage(
        sessionId,
        message,
        Object.keys(finalContextInfo).length > 0 ? finalContextInfo : null
      );
      
      console.log("Message response:", response);
      if (response && response.message) {
        const responseMessage = {
          id: messages.length + 1,
          role: response.message.role === 'coach' ? 'assistant' : response.message.role,
          content: response.message.content,
          timestamp: response.message.timestamp || new Date().toISOString()
        };
        setMessages(prev => [...prev, responseMessage]);
        setSession(prev => {
          if (!prev) return prev;
          return {
            ...prev,
            conversation: [
              ...(prev.conversation || []),
              userMessage,
              {
                role: response.message.role,
                content: response.message.content,
                timestamp: response.message.timestamp
              }
            ]
          };
        });
        if (response.diagramSuggestions) {
          handleDiagramSuggestions(response.diagramSuggestions);
        } else if (requestDiagramSuggestions) {
          handleGetDiagramSuggestion();
        }
      } else {
        setMessages(prev => [
          ...prev,
          {
            id: prev.length + 1,
            role: 'assistant',
            content: "I'm having trouble processing your request. Please try again.",
            timestamp: new Date().toISOString()
          }
        ]);
      }
    } catch (error) {
      console.error("Error sending message:", error);
      setMessages(prev => [
        ...prev,
        {
          id: prev.length + 1,
          role: 'assistant',
          content: "There was an error communicating with the coaching service. Please try again later.",
          timestamp: new Date().toISOString()
        }
      ]);
    } finally {
      setIsTyping(false);
      setIsSending(false);
    }
  };

  const handleGetMaterials = async (topic) => {
    if (!topic || !sessionId) return;
    try {
      setLoading(true);
      const materials = await getCoachingMaterials(sessionId, topic);
      setActiveMaterial(materials);
    } catch (err) {
      console.error("Error fetching materials:", err);
      setError("Failed to load learning materials");
    } finally {
      setLoading(false);
    }
  };

  const handleSendDiagramToCoach = async () => {
    if (!diagramCode || !sessionId) return;
    const message = "Can you provide feedback on my system design diagram?";
    try {
      setIsSending(true);
      const newMessage = {
        id: Date.now(),
        role: 'user',
        content: message,
        timestamp: new Date().toISOString()
      };
      setMessages(prev => [...prev, newMessage]);
      setIsTyping(true);
      const contextInfo = {
        diagramContext: currentDiagramState,
        requestDiagramFeedback: true
      };
      const response = await sendCoachingMessage(sessionId, message, contextInfo);
      if (response?.message) {
        const botMessage = {
          id: Date.now() + 1,
          role: 'assistant',
          content: response.message.content,
          timestamp: new Date().toISOString()
        };
        setMessages(prev => [...prev, botMessage]);
        setSession(prev => ({
          ...prev,
          conversation: [
            ...(prev.conversation || []),
            { role: 'user', content: message },
            { role: 'assistant', content: response.message.content }
          ]
        }));
        if (response.diagramSuggestions) {
          handleDiagramSuggestions(response.diagramSuggestions);
        }
      }
    } catch (err) {
      console.error("Error sending diagram for feedback:", err);
      const errorMessage = {
        id: Date.now() + 1,
        role: 'system',
        content: 'Failed to get diagram feedback. Please try again.',
        error: true,
        timestamp: new Date().toISOString()
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
      setIsSending(false);
    }
  };

  const handleDiagramSuggestions = (suggestions) => {
    if (!suggestions || !suggestions.mermaidCode) return;
    try {
      const { nodes: suggestedNodes, edges: suggestedEdges } = mermaidToReactFlow(suggestions.mermaidCode);
      const markedNodes = suggestedNodes.map(node => ({
        ...node,
        style: { ...node.style, border: '2px dashed #4f46e5' },
        data: { ...node.data, suggested: true }
      }));
      const markedEdges = suggestedEdges.map(edge => ({
        ...edge,
        style: { ...edge.style, strokeDasharray: '5,5', stroke: '#4f46e5' },
        data: { ...edge.data, suggested: true }
      }));
      setDiagramSuggestions({
        nodes: markedNodes,
        edges: markedEdges,
        mermaidCode: suggestions.mermaidCode
      });
      setShowSuggestions(true);
    } catch (err) {
      console.error("Error processing diagram suggestions:", err);
    }
  };

  const handleAcceptSuggestions = () => {
    if (!diagramSuggestions) return;
    const updatedNodes = [...nodes, ...diagramSuggestions.nodes.filter(
      sugNode => !nodes.some(node => node.id === sugNode.id)
    )];
    const updatedEdges = [...edges, ...diagramSuggestions.edges.filter(
      sugEdge => !edges.some(edge => edge.id === sugEdge.id)
    )];
    setNodes(updatedNodes);
    setEdges(updatedEdges);
    setDiagramCode(diagramSuggestions.mermaidCode);
    setCurrentDiagramState({
      nodes: updatedNodes,
      edges: updatedEdges,
      mermaidCode: diagramSuggestions.mermaidCode
    });
    setDiagramSuggestions(null);
    setShowSuggestions(false);
  };

  const handleDiscardSuggestions = () => {
    setDiagramSuggestions(null);
    setShowSuggestions(false);
  };

  const handleSaveDiagram = async () => {
    if (!sessionId) return;
    try {
      setIsSavingDiagram(true);
      const diagramData = {
        mermaidCode: diagramCode,
        reactFlowData: { nodes, edges }
      };
      await saveDiagram(sessionId, diagramData);
      setSession(prev => ({
        ...prev,
        diagram: diagramData
      }));
    } catch (err) {
      console.error("Error saving diagram:", err);
      setError("Failed to save diagram");
    } finally {
      setIsSavingDiagram(false);
    }
  };

  const handleGetDiagramSuggestion = async () => {
    if (!sessionId) return;
    try {
      setLoading(true);
      const suggestion = await getCoachingDiagram(sessionId);
      if (suggestion?.mermaidCode) {
        try {
          const { nodes: convertedNodes, edges: convertedEdges } = mermaidToReactFlow(suggestion.mermaidCode);
          const markedNodes = convertedNodes.map(node => ({
            ...node,
            style: { ...node.style, border: '2px dashed #4f46e5' },
            data: { ...node.data, suggested: true }
          }));
          const markedEdges = convertedEdges.map(edge => ({
            ...edge,
            style: { ...edge.style, strokeDasharray: '5,5', stroke: '#4f46e5' },
            data: { ...edge.data, suggested: true }
          }));
          setDiagramSuggestions({
            nodes: markedNodes,
            edges: markedEdges,
            mermaidCode: suggestion.mermaidCode
          });
          setShowSuggestions(true);
        } catch (err) {
          console.error("Error converting AI diagram:", err);
        }
      }
    } catch (err) {
      console.error("Error getting diagram suggestion:", err);
      setError("Failed to get diagram suggestion");
    } finally {
      setLoading(false);
    }
  };

  const onNodesChange = useCallback(
    (changes) => {
      setNodes(nds => {
        const updatedNodes = applyNodeChanges(changes, nds);
        try {
          const newDiagramCode = reactFlowToMermaid({ nodes: updatedNodes, edges });
          setDiagramCode(newDiagramCode);
          setCurrentDiagramState({ nodes: updatedNodes, edges, mermaidCode: newDiagramCode });
        } catch (err) {
          console.error("Error updating Mermaid code:", err);
        }
        return updatedNodes;
      });
    },
    [edges]
  );

  const onEdgesChange = useCallback(
    (changes) => {
      setEdges(eds => {
        const updatedEdges = applyEdgeChanges(changes, eds);
        try {
          const newDiagramCode = reactFlowToMermaid({ nodes, edges: updatedEdges });
          setDiagramCode(newDiagramCode);
          setCurrentDiagramState({ nodes, edges: updatedEdges, mermaidCode: newDiagramCode });
        } catch (err) {
          console.error("Error updating Mermaid code:", err);
        }
        return updatedEdges;
      });
    },
    [nodes]
  );

  const onConnect = useCallback(
    (params) => {
      const newEdge = { ...params, id: `e${params.source}-${params.target}` };
      setEdges(eds => {
        const updatedEdges = addEdge(newEdge, eds);
        try {
          const newDiagramCode = reactFlowToMermaid({ nodes, edges: updatedEdges });
          setDiagramCode(newDiagramCode);
          setCurrentDiagramState({ nodes, edges: updatedEdges, mermaidCode: newDiagramCode });
        } catch (err) {
          console.error("Error updating Mermaid code:", err);
        }
        return updatedEdges;
      });
    },
    [nodes]
  );

  const handleDiagramUpdate = (diagramData) => {
    setCurrentDiagramState(diagramData);
  };

  const renderDiagramEditor = () => {
    // Get active diagram tab
    const activeDiagramTab = diagramTabs.find(tab => tab.active)?.id || 'flowchart';
    
    if (activeDiagramTab === 'sequence') {
      return (
        <div className="relative h-full">
          <SequenceDiagram 
            initialDiagram={currentDiagramState}
            onDiagramUpdate={handleDiagramUpdate}
          />
        </div>
      );
    }
    
    // Default flowchart diagram
    if (viewMode === 'edit') {
      return (
        <div className="relative h-full">
          <ReactFlowDiagramWithProvider
            initialNodes={nodes}
            initialEdges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onDiagramUpdate={handleDiagramUpdate}
          />
          {showSuggestions && diagramSuggestions && (
            <div className="absolute inset-0 bg-black bg-opacity-10 z-10 flex flex-col">
              <div className="bg-yellow-50 p-3 border-b border-yellow-200">
                <div className="flex justify-between items-center">
                  <p className="text-sm text-yellow-800">
                    <span className="font-medium">AI has suggested diagram changes</span>
                  </p>
                  <div className="flex space-x-2">
                    <button 
                      onClick={handleAcceptSuggestions}
                      className="px-3 py-1 bg-green-600 text-white text-sm rounded flex items-center"
                    >
                      <CheckCircle className="h-4 w-4 mr-1" />
                      Accept Changes
                    </button>
                    <button 
                      onClick={handleDiscardSuggestions}
                      className="px-3 py-1 bg-gray-600 text-white text-sm rounded flex items-center"
                    >
                      <XCircle className="h-4 w-4 mr-1" />
                      Discard
                    </button>
                  </div>
                </div>
              </div>
              <div className="flex-1 relative">
                <ReactFlowDiagramWithProvider
                  initialNodes={diagramSuggestions.nodes}
                  initialEdges={diagramSuggestions.edges}
                  onNodesChange={() => {}}
                  onEdgesChange={() => {}}
                  onConnect={() => {}}
                />
              </div>
            </div>
          )}
        </div>
      );
    } else if (viewMode === 'preview') {
      return <MermaidRenderer code={diagramCode} />;
    } else {
      return (
        <div className="h-full p-4 flex flex-col">
          <textarea
            value={diagramCode}
            onChange={e => setDiagramCode(e.target.value)}
            className="w-full flex-1 font-mono text-sm p-2 border border-gray-300 rounded"
          />
          <div className="mt-2">
            <button
              onClick={() => {
                try {
                  const { nodes: newNodes, edges: newEdges } = mermaidToReactFlow(diagramCode);
                  setNodes(newNodes);
                  setEdges(newEdges);
                  setViewMode('edit');
                } catch (err) {
                  console.error("Error parsing Mermaid code:", err);
                  alert("Invalid Mermaid code: " + err.message);
                }
              }}
              className="px-3 py-1 bg-blue-600 text-white text-sm rounded"
            >
              Apply Changes
            </button>
          </div>
        </div>
      );
    }
  };

  // Render active workbook component
  const getActiveWorkbookComponent = () => {
    switch (activeWorkbookTab) {
      case 'requirements':
        return <RequirementsPage data={formData.requirements} updateData={(data) => updateFormData('requirements', data)} />;
      case 'api':
        return <APIDesignPage data={formData.api} updateData={(data) => updateFormData('api', data)} />;
      case 'data':
        return <DataModelPage data={formData.data} updateData={(data) => updateFormData('data', data)} />;
      case 'architecture':
        return <SystemArchitecturePage data={formData.architecture} updateData={(data) => updateFormData('architecture', data)} />;
      case 'scaling':
        return <ScalingStrategyPage data={formData.scaling} updateData={(data) => updateFormData('scaling', data)} />;
      case 'reliability':
        return <ReliabilitySecurityPage data={formData.reliability} updateData={(data) => updateFormData('reliability', data)} />;
      default:
        return <RequirementsPage data={formData.requirements} updateData={(data) => updateFormData('requirements', data)} />;
    }
  };

  if (loading && !session) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
        <div className="ml-3 text-gray-600">Loading session data...</div>
      </div>
    );
  }

  if (error && !session && messages.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-screen">
        <div className="text-red-500 mb-4">{error}</div>
        <button
          onClick={() => router.back()}
          className="px-4 py-2 bg-blue-600 text-white rounded"
        >
          Go Back
        </button>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-screen bg-gray-50">
      {/* Header */}
      <header className="bg-white border-b border-gray-200 p-4">
        <div className="flex justify-between items-center">
          <div className="flex items-center">
            <button
              onClick={() => router.push('/coaching')}
              className="p-1 rounded-full hover:bg-gray-100 mr-2"
            >
              <ArrowLeft className="h-5 w-5 text-gray-600" />
            </button>
            <h1 className="text-lg font-semibold">
              {session?.problem?.title || 'System Design Coaching'}
            </h1>
          </div>
          <div className="flex items-center space-x-2">
            <div className="mr-2">
              <div className="flex border border-gray-300 rounded-lg overflow-hidden">
                <button
                  onClick={() => setRightPanelMode('workbook')}
                  className={`px-4 py-2 text-sm font-medium ${
                    rightPanelMode === 'workbook'
                      ? 'bg-blue-600 text-white'
                      : 'bg-white text-gray-700 hover:bg-gray-100'
                  }`}
                >
                  Workbook
                </button>
                <button
                  onClick={() => setRightPanelMode('diagram')}
                  className={`px-4 py-2 text-sm font-medium ${
                    rightPanelMode === 'diagram'
                      ? 'bg-blue-600 text-white'
                      : 'bg-white text-gray-700 hover:bg-gray-100'
                  }`}
                >
                  Diagram
                </button>
              </div>
            </div>
            <button
              onClick={handleSaveDiagram}
              className={`flex items-center px-3 py-1 rounded text-sm ${
                isSavingDiagram
                  ? 'bg-gray-300 text-gray-700'
                  : 'bg-blue-600 text-white hover:bg-blue-700'
              }`}
              disabled={isSavingDiagram}
            >
              <Save className="h-4 w-4 mr-1" />
              {isSavingDiagram ? 'Saving...' : 'Save Progress'}
            </button>
          </div>
        </div>
      </header>

      {/* Main content */}
      <div className="flex-1 flex overflow-hidden">
        {/* Left panel - Chat */}
        <div className="w-1/2 flex flex-col border-r border-gray-200">
          {/* Messages area */}
          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            <div className="bg-white border border-gray-200 rounded-lg mb-4 overflow-hidden">
              <div className="flex justify-between items-center cursor-pointer p-3 bg-indigo-50 border-b border-gray-200" 
                   onClick={() => setTopicGuidedOpen(!topicGuidedOpen)}>
                <h3 className="font-medium text-indigo-700">Topic Guided Coaching</h3>
                {topicGuidedOpen ? (
                  <ChevronUp className="h-5 w-5 text-indigo-600" />
                ) : (
                  <ChevronDown className="h-5 w-5 text-indigo-600" />
                )}
              </div>
              {topicGuidedOpen && (
                <div className="p-3">
                  <TopicGuidedCoaching 
                    currentTopic={currentTopic}
                    onSendMessage={(question) => handleSendMessage(question)}
                    onGetMaterials={handleGetMaterials}
                  />
                </div>
              )}
            </div>
            
            {messages.length > 0 ? (
              messages.map((msg, index) => (
                <div
                  key={msg.id || index}
                  className={`p-3 rounded-lg ${
                    msg.role === 'user'
                      ? 'bg-blue-100 ml-auto max-w-md'
                      : msg.role === 'system'
                        ? 'bg-gray-100 text-gray-700'
                        : 'bg-white border border-gray-200 max-w-lg'
                  } ${msg.error ? 'border-red-300 text-red-600' : ''}`}
                >
                  <ReactMarkdown
                    components={{
                      code({ node, inline, className, children, ...props }) {
                        const match = /language-(\w+)/.exec(className || '');
                        return !inline && match ? (
                          <div className="rounded border border-gray-200 overflow-hidden my-2">
                            <div className="bg-gray-50 border-b border-gray-200 px-4 py-1 text-xs text-gray-500 font-mono">
                              {match[1]}
                            </div>
                            <pre className="bg-white p-4 overflow-auto text-sm">
                              <code className={className} {...props}>
                                {children}
                              </code>
                            </pre>
                          </div>
                        ) : (
                          <code className="font-mono text-sm bg-gray-50 px-1 py-0.5 rounded text-pink-600" {...props}>
                            {children}
                          </code>
                        );
                      }
                    }}
                  >
                    {msg.content}
                  </ReactMarkdown>
                </div>
              ))
            ) : (
              <div className="text-center text-gray-500 py-8">
                No messages yet. Start by asking a question about system design.
              </div>
            )}
            {isTyping && (
              <div className="bg-white border border-gray-200 rounded-lg p-3 max-w-lg">
                <div className="flex space-x-2">
                  <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style={{ animationDelay: '0ms' }}></div>
                  <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style={{ animationDelay: '150ms' }}></div>
                  <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce" style={{ animationDelay: '300ms' }}></div>
                </div>
              </div>
            )}
            <div ref={messagesEndRef} />
          </div>

          {/* Message input */}
          <div className="p-4 border-t border-gray-200">
            <div className="p-3 mb-3 bg-blue-50 border border-blue-100 rounded-lg">
              <div className="flex items-center space-x-6">
                <label className="flex items-center cursor-pointer">
                  <input
                    type="checkbox"
                    className="mr-2 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    checked={includeDiagram}
                    onChange={() => setIncludeDiagram(!includeDiagram)}
                  />
                  <span className="text-blue-700 font-medium">Include current design</span>
                </label>
                <label className="flex items-center cursor-pointer">
                  <input
                    type="checkbox"
                    className="mr-2 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    checked={requestDiagramSuggestions}
                    onChange={() => setRequestDiagramSuggestions(!requestDiagramSuggestions)}
                  />
                  <span className="text-blue-700 font-medium">Request diagram suggestions</span>
                </label>
              </div>
            </div>
            <form
              onSubmit={(e) => {
                e.preventDefault();
                if (messageInput.trim()) {
                  handleSendMessage(messageInput);
                  setMessageInput('');
                }
              }}
              className="flex"
            >
              <input
                type="text"
                value={messageInput}
                onChange={(e) => setMessageInput(e.target.value)}
                placeholder="Type your message..."
                className="flex-1 border border-gray-300 rounded-l-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                disabled={isSending}
              />
              <button
                type="submit"
                className={`px-4 py-2 rounded-r-md flex items-center justify-center ${
                  isSending
                    ? 'bg-gray-300 text-gray-700'
                    : 'bg-blue-600 text-white hover:bg-blue-700'
                }`}
                disabled={isSending}
              >
                {isSending ? (
                  <RefreshCw className="h-5 w-5 animate-spin" />
                ) : (
                  <Send className="h-5 w-5" />
                )}
              </button>
            </form>
          </div>
        </div>

        {/* Right panel - Diagram or Workbook */}
        <div className="w-1/2 flex flex-col">
          {rightPanelMode === 'diagram' ? (
            <>
              {/* Diagram mode controls */}
              <div className="bg-white border-b border-gray-200 p-3">
                <div className="flex justify-between items-center">
                  {/* Diagram type tabs */}
                  <div className="flex space-x-4">
                    {diagramTabs.map(tab => (
                      <button
                        key={tab.id}
                        onClick={() => setActiveDiagramTab(tab.id)}
                        className={`px-4 py-2 text-sm font-medium rounded-lg ${
                          tab.active
                            ? 'bg-blue-100 text-blue-700 border border-blue-200'
                            : 'text-gray-600 hover:bg-gray-100'
                        }`}
                      >
                        {tab.label}
                      </button>
                    ))}
                  </div>
                  
                  {/* Diagram view controls */}
                  <div className="flex space-x-1">
                    <button
                      onClick={() => setViewMode('edit')}
                      className={`px-3 py-1 text-xs rounded-lg border ${
                        viewMode === 'edit'
                          ? 'bg-blue-50 text-blue-700 border-blue-200'
                          : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50'
                      }`}
                    >
                      <Edit className="h-3 w-3 inline mr-1" />
                      Edit
                    </button>
                    <button
                      onClick={() => setViewMode('preview')}
                      className={`px-3 py-1 text-xs rounded-lg border ${
                        viewMode === 'preview'
                          ? 'bg-blue-50 text-blue-700 border-blue-200'
                          : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50'
                      }`}
                    >
                      <Eye className="h-3 w-3 inline mr-1" />
                      Preview
                    </button>
                    <button
                      onClick={() => setViewMode('code')}
                      className={`px-3 py-1 text-xs rounded-lg border ${
                        viewMode === 'code'
                          ? 'bg-blue-50 text-blue-700 border-blue-200'
                          : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50'
                      }`}
                    >
                      <Code className="h-3 w-3 inline mr-1" />
                      Code
                    </button>
                  </div>
                  
                  <button
                    onClick={handleSendDiagramToCoach}
                    className="px-3 py-1 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                  >
                    Get Feedback
                  </button>
                </div>
              </div>
              {/* Diagram content */}
              <div className="flex-1 overflow-hidden">
                {renderDiagramEditor()}
              </div>
            </>
          ) : (
            <>
              {/* Workbook tabs */}
              <div className="bg-white border-b border-gray-200">
                <div className="flex w-full overflow-hidden relative">
                  <div className="flex flex-1 overflow-x-auto">
                    {workbookTabs.map((tab) => (
                      <button
                        key={tab.id}
                        onClick={() => setActiveWorkbookTab(tab.id)}
                        className={`flex items-center py-3 px-4 text-sm font-medium whitespace-nowrap transition-colors ${
                          activeWorkbookTab === tab.id
                            ? 'border-b-2 border-indigo-600 text-indigo-700 bg-indigo-50'
                            : 'border-b-2 border-transparent text-gray-600 hover:text-gray-800 hover:bg-gray-50'
                        }`}
                      >
                        <span className="mr-2">{tab.icon}</span>
                        <span className="truncate">{tab.label}</span>
                      </button>
                    ))}
                  </div>
                  <div className="absolute right-0 top-0 h-full bg-gradient-to-l from-white to-transparent w-12 flex items-center justify-end">
                    <button 
                      onClick={() => setShowWorkbookDropdown(!showWorkbookDropdown)}
                      className="h-full px-2 text-gray-500 hover:text-indigo-600">
                      <ChevronDown size={16} />
                    </button>
                  </div>
                  {/* Workbook tab dropdown */}
                  {showWorkbookDropdown && (
                    <div 
                      ref={workbookDropdownRef}
                      className="absolute right-2 top-12 bg-white shadow-lg border border-gray-200 rounded-md z-10">
                      <div className="py-1">
                        {workbookTabs.map((tab) => (
                          <button
                            key={tab.id}
                            onClick={() => {
                              setActiveWorkbookTab(tab.id);
                              setShowWorkbookDropdown(false);
                            }}
                            className={`flex items-center w-full text-left px-4 py-2 text-sm ${
                              activeWorkbookTab === tab.id
                                ? 'bg-indigo-50 text-indigo-700'
                                : 'text-gray-700 hover:bg-gray-100'
                            }`}
                          >
                            <span className="mr-2">{tab.icon}</span>
                            {tab.label}
                          </button>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </div>
              
              {/* Workbook content area */}
              <div className="flex-1 overflow-auto">
                {getActiveWorkbookComponent()}
              </div>
            </>
          )}
        </div>
      </div>
      
      {/* Learning materials modal */}
      {activeMaterial && (
        <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50">
          <div className="bg-white rounded-lg max-w-3xl max-h-[80vh] w-full overflow-hidden">
            <div className="p-4 border-b border-gray-200 flex justify-between items-center">
              <h3 className="font-medium text-lg">{activeMaterial.title}</h3>
              <button
                onClick={() => setActiveMaterial(null)}
                className="p-1 rounded-full hover:bg-gray-100"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                </svg>
              </button>
            </div>
            <div className="p-4 overflow-y-auto max-h-[calc(80vh-8rem)]">
              <ReactMarkdown>{activeMaterial.content}</ReactMarkdown>
            </div>
            <div className="p-4 border-t border-gray-200 flex justify-end">
              <button
                onClick={() => setActiveMaterial(null)}
                className="px-4 py-2 bg-blue-600 text-white rounded"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default CoachingSessionPage;


================================================================================
# FILE: client\pages\coaching\index.js
# EXTENSION: .js
================================================================================
// client/pages/coaching/index.js
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../../contexts/AuthContext';
import { ArrowRight, School } from 'lucide-react';
import Sidebar from '../../components/Sidebar';
import { getCoachingProblems, startCoachingSession } from '../../utils/api';

export default function CoachingIndexPage() {
  const router = useRouter();
  const { isAuthenticated } = useAuth();
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [startingSession, setStartingSession] = useState(false);

  useEffect(() => {
    if (!isAuthenticated) {
      router.push('/auth/login');
      return;
    }

    fetchProblems();
  }, [isAuthenticated, router]);

  const fetchProblems = async () => {
    try {
      setLoading(true);
      const data = await getCoachingProblems();
      
      console.log("Coaching problems response:", data);
      
      // Check if data is an array (direct response) or has a problems property
      if (Array.isArray(data)) {
        setProblems(data);
      } else if (data && data.problems) {
        setProblems(data.problems);
      } else {
        console.error("Invalid data format:", data);
      }
    } catch (error) {
      console.error('Error fetching coaching problems:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleStartSession = async (problemId) => {
    try {
      setStartingSession(true);
      const response = await startCoachingSession(problemId);
      
      console.log('Start session response:', response);
      
      // Check for different response formats
      if (response && response.session && response.session._id) {
        router.push(`/coaching/${response.session._id}`);
      } else if (response && response.id) {
        router.push(`/coaching/${response.id}`);
      } else if (response) {
        // If we have any response, try to use it
        const id = response._id || response.sessionId || response.id || problemId;
        router.push(`/coaching/${id}`);
      } else {
        console.error('Invalid response format:', response);
      }
    } catch (error) {
      console.error('Error starting coaching session:', error);
    } finally {
      setStartingSession(false);
    }
  };

  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeTab="coaching" />
      
      <div className="flex-1 overflow-auto p-6">
        <div className="mb-8">
          <h1 className="text-2xl font-bold text-gray-900">System Design Coach</h1>
          <p className="text-gray-600 mt-1">Learn system design concepts with guided coaching sessions.</p>
        </div>
        
        {loading ? (
          <div className="flex justify-center mt-12">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600"></div>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {problems.length > 0 ? (
              problems.map(problem => (
                <div 
                  key={problem.id} 
                  className="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden hover:shadow-md transition-shadow"
                >
                  <div className="p-6">
                    <div className="flex items-start justify-between mb-2">
                      <h3 className="text-lg font-semibold text-gray-900">{problem.title}</h3>
                      <span className={`px-2 py-1 rounded text-xs font-medium ${
                        problem.difficulty === 'beginner' ? 'bg-green-100 text-green-800' :
                        problem.difficulty === 'intermediate' ? 'bg-blue-100 text-blue-800' :
                        'bg-purple-100 text-purple-800'
                      }`}>
                        {problem.difficulty}
                      </span>
                    </div>
                    <p className="text-gray-600 text-sm mb-4 line-clamp-2">{problem.description || 'Practice your system design skills with this problem.'}</p>
                    <div className="flex items-center justify-between mt-4">
                      <div className="flex items-center text-sm text-gray-500">
                        <School className="h-4 w-4 mr-1" />
                        <span>{problem.estimatedTime || 30} mins</span>
                      </div>
                      <button
                        onClick={() => handleStartSession(problem.id)}
                        disabled={startingSession}
                        className="flex items-center text-green-600 hover:text-green-800 text-sm font-medium"
                      >
                        Start learning
                        <ArrowRight className="h-4 w-4 ml-1" />
                      </button>
                    </div>
                  </div>
                </div>
              ))
            ) : (
              <div className="col-span-3 bg-white p-6 rounded-lg shadow text-center">
                <p className="text-gray-600">No coaching problems found. Please check back later.</p>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\dashboard.js
# EXTENSION: .js
================================================================================
import Link from 'next/link';
import Sidebar from '../components/Sidebar';
import MetricCard from '../components/MetricCard';
import { Activity, Users, BookOpen, Bookmark, BarChart2 } from 'lucide-react';

export default function Dashboard({ onSelectWorkbook }) {
  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeTab="dashboard" />
      <div className="flex-1 overflow-auto p-6">
        <div className="mb-8">
          <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
          <p className="text-gray-600 mt-1">View your system design practice statistics</p>
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
          <MetricCard 
            title="Sessions Completed" 
            value="12"
            icon={<Activity className="h-6 w-6 text-white" />}
            iconBgColor="bg-blue-500"
            progress={60}
            subtext="20 sessions total"
          />
          <MetricCard 
            title="Hours Practiced" 
            value="24.5"
            icon={<BookOpen className="h-6 w-6 text-white" />}
            iconBgColor="bg-green-500"
            progress={75}
            subtext="Target: 30 hours"
          />
          <MetricCard 
            title="Avg. Score" 
            value="8.4"
            icon={<BarChart2 className="h-6 w-6 text-white" />}
            iconBgColor="bg-purple-500"
            progress={84}
            subtext="Out of 10"
          />
          <MetricCard 
            title="Designs Saved" 
            value="7"
            icon={<Bookmark className="h-6 w-6 text-white" />}
            iconBgColor="bg-orange-500"
            subtext="3 shared with community"
          />
        </div>
        
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-8">
          <h2 className="text-lg font-semibold mb-4">Continue Your Learning</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <button 
              onClick={onSelectWorkbook}
              className="flex items-center p-4 border border-indigo-200 rounded-lg bg-indigo-50 text-indigo-700 hover:bg-indigo-100"
            >
              <div className="rounded-full bg-indigo-100 p-3 mr-4">
                <BookOpen className="h-6 w-6 text-indigo-600" />
              </div>
              <div>
                <h3 className="font-medium">System Design Workbook</h3>
                <p className="text-sm text-indigo-600">Create structured system designs</p>
              </div>
            </button>
            
            <Link href="/interviews">
              <div className="flex items-center p-4 border border-green-200 rounded-lg bg-green-50 text-green-700 hover:bg-green-100 cursor-pointer">
                <div className="rounded-full bg-green-100 p-3 mr-4">
                  <Users className="h-6 w-6 text-green-600" />
                </div>
                <div>
                  <h3 className="font-medium">Practice Interviews</h3>
                  <p className="text-sm text-green-600">Simulate real interviews</p>
                </div>
              </div>
            </Link>
          </div>
        </div>
        
        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
          <h2 className="text-lg font-semibold mb-4">Recent Activity</h2>
          <div className="space-y-4">
            <div className="flex items-start border-b border-gray-100 pb-4">
              <div className="rounded-full bg-blue-100 p-2 mr-4">
                <Activity className="h-5 w-5 text-blue-600" />
              </div>
              <div>
                <h3 className="font-medium">Completed Practice Interview</h3>
                <p className="text-sm text-gray-600">You scored 8.5/10 on "Design Twitter"</p>
                <p className="text-xs text-gray-500 mt-1">2 days ago</p>
              </div>
            </div>
            <div className="flex items-start border-b border-gray-100 pb-4">
              <div className="rounded-full bg-purple-100 p-2 mr-4">
                <BookOpen className="h-5 w-5 text-purple-600" />
              </div>
              <div>
                <h3 className="font-medium">Completed System Design</h3>
                <p className="text-sm text-gray-600">You created "URL Shortener" design</p>
                <p className="text-xs text-gray-500 mt-1">3 days ago</p>
              </div>
            </div>
            <div className="flex items-start">
              <div className="rounded-full bg-green-100 p-2 mr-4">
                <Bookmark className="h-5 w-5 text-green-600" />
              </div>
              <div>
                <h3 className="font-medium">Saved Design Template</h3>
                <p className="text-sm text-gray-600">You saved "E-commerce Platform" template</p>
                <p className="text-xs text-gray-500 mt-1">5 days ago</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\DataModelPage.js
# EXTENSION: .js
================================================================================
// client/components/DataModelPage.js
import React, { useState } from 'react';

const DataModelPage = ({ data = {}, updateData }) => {
  const [formState, setFormState] = useState({
    entities: data.entities || '',
    relationships: data.relationships || '',
    databaseChoice: data.databaseChoice || '',
    schemaDesign: data.schemaDesign || '',
    caching: data.caching || ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    const newState = { ...formState, [name]: value };
    setFormState(newState);
    if (updateData) {
      updateData(newState);
    }
  };

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-bold text-gray-900">Data Model</h2>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Key Entities
        </label>
        <textarea
          name="entities"
          value={formState.entities}
          onChange={handleChange}
          rows={4}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="List main data entities and their attributes..."
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Entity Relationships
        </label>
        <textarea
          name="relationships"
          value={formState.relationships}
          onChange={handleChange}
          rows={4}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="Define relationships between entities (1:1, 1:N, M:N)..."
        />
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Database Selection
          </label>
          <textarea
            name="databaseChoice"
            value={formState.databaseChoice}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="SQL vs NoSQL, specific database technologies..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Schema Design
          </label>
          <textarea
            name="schemaDesign"
            value={formState.schemaDesign}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Tables/collections structure, indexes..."
          />
        </div>
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Caching Strategy
        </label>
        <textarea
          name="caching"
          value={formState.caching}
          onChange={handleChange}
          rows={3}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="Cache layers, TTL policies, invalidation strategies..."
        />
      </div>
    </div>
  );
};

export default DataModelPage;


================================================================================
# FILE: client\pages\index.js
# EXTENSION: .js
================================================================================
import React, { useState } from 'react';
import Dashboard from './dashboard';
import WorkbookLayout from './WorkbookLayout';

export default function Home() {
  const [view, setView] = useState('dashboard');
  
  if (view === 'workbook') {
    return <WorkbookLayout onBack={() => setView('dashboard')} />;
  }
  
  return <Dashboard onSelectWorkbook={() => setView('workbook')} />;
}


================================================================================
# FILE: client\pages\interviews\[id].js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../../contexts/AuthContext';
import { Clock, Send, Clipboard } from 'lucide-react';
import Sidebar from '../../components/Sidebar';
import { getInterview, sendInterviewMessage, completeInterview as completeInterviewApi } from '../../utils/api';

export default function InterviewPage() {
  const router = useRouter();
  const { id } = router.query;
  const { isAuthenticated, user } = useAuth();
  const [interview, setInterview] = useState(null);
  const [message, setMessage] = useState('');
  const [loading, setLoading] = useState(true);
  const [sending, setSending] = useState(false);
  const [timeRemaining, setTimeRemaining] = useState(null);
  const messagesEndRef = useRef(null);
  const timerRef = useRef(null);

  // Fetch interview data when component mounts or ID changes
  useEffect(() => {
    if (!isAuthenticated) {
      router.push('/auth/login');
      return;
    }

    if (id) {
      console.log("Fetching interview with ID:", id);
      fetchInterview();
    }
  }, [id, isAuthenticated, router]);

  // Set up timer to update time remaining
  useEffect(() => {
    if (interview?.startTime) {
      const intervalId = setInterval(updateTimeRemaining, 1000);
      return () => clearInterval(intervalId);
    }
  }, [interview]);

  // Auto-scroll to bottom of messages when conversation updates
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [interview?.conversation]);

  // Function to fetch interview data from API
  const fetchInterview = async () => {
    try {
      setLoading(true);
      // Make API call to get interview data
      console.log("Making API call to get interview:", id);
      const data = await getInterview(id);
      console.log("Received interview data:", data);
      
      // If we get valid data, use it
      if (data && data.interview) {
        setInterview(data.interview);
      } else {
        // Otherwise, use a mock interview for development
        console.log("Using mock interview data");
        setInterview({
          id: id,
          problemId: "url-shortener",
          status: "in_progress",
          currentStage: "introduction",
          startTime: new Date().toISOString(),
          timeLimit: 45,
          conversation: [
            {
              role: "interviewer",
              content: "Welcome to your system design interview. Today I'd like you to design a URL shortener service like TinyURL or bit.ly. We have about 45 minutes for this discussion. Could you start by telling me how you understand this problem and what key requirements we should consider?",
              stage: "introduction",
              timestamp: new Date().toISOString()
            }
          ]
        });
      }
      
      updateTimeRemaining();
    } catch (error) {
      console.error('Error fetching interview:', error);
      
      // Even on error, provide mock data so the UI works
      setInterview({
        id: id,
        problemId: "url-shortener",
        status: "in_progress",
        currentStage: "introduction",
        startTime: new Date().toISOString(),
        timeLimit: 45,
        conversation: [
          {
            role: "interviewer",
            content: "Welcome to your system design interview. Today I'd like you to design a URL shortener service like TinyURL or bit.ly. We have about 45 minutes for this discussion. Could you start by telling me how you understand this problem and what key requirements we should consider?",
            stage: "introduction",
            timestamp: new Date().toISOString()
          }
        ]
      });
    } finally {
      setLoading(false);
    }
  };

  // Function to update time remaining in interview
  const updateTimeRemaining = () => {
    if (!interview?.startTime) return;
    
    // Calculate time remaining based on start time and time limit
    const startTime = new Date(interview.startTime).getTime();
    const timeLimit = interview.timeLimit * 60 * 1000; // convert minutes to ms
    const now = Date.now();
    const elapsed = now - startTime;
    const remaining = Math.max(0, timeLimit - elapsed);
    
    setTimeRemaining(remaining);
    
    // If time is up and interview is still in progress, automatically complete it
    if (remaining === 0 && interview.status === 'in_progress') {
      handleCompleteInterview();
    }
  };

  // Function to format milliseconds as minutes:seconds
  const formatTime = (ms) => {
    if (ms === null) return '--:--';
    
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  };

  // Function to handle sending a new message
  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!message.trim() || sending) return;
    
    try {
      setSending(true);
      
      // Immediately update UI with user's message for better UX
      const updatedInterview = {
        ...interview,
        conversation: [
          ...interview.conversation,
          {
            role: "candidate",
            content: message,
            stage: interview.currentStage,
            timestamp: new Date().toISOString()
          }
        ]
      };
      setInterview(updatedInterview);
      
      // Clear input field immediately
      setMessage('');
      
      // Then send to server and get response
      console.log("Sending message to interview:", id, message);
      const response = await sendInterviewMessage(id, message);
      
      if (response && response.interview) {
        setInterview(response.interview);
      } else {
        // If API fails, simulate a response
        setTimeout(() => {
          const mockedResponse = {
            ...updatedInterview,
            conversation: [
              ...updatedInterview.conversation,
              {
                role: "interviewer",
                content: "That's a good point. Could you elaborate more on how you would handle scaling this system to millions of users?",
                stage: updatedInterview.currentStage,
                timestamp: new Date().toISOString()
              }
            ]
          };
          setInterview(mockedResponse);
        }, 1000);
      }
    } catch (error) {
      console.error('Error sending message:', error);
      
      // On error, still provide a simulated response
      setTimeout(() => {
        const mockedResponse = {
          ...interview,
          conversation: [
            ...interview.conversation,
            {
              role: "interviewer",
              content: "Interesting approach. Let's talk about how you'd handle the database design for this system.",
              stage: interview.currentStage,
              timestamp: new Date().toISOString()
            }
          ]
        };
        setInterview(mockedResponse);
      }, 1000);
    } finally {
      setSending(false);
    }
  };

  // Function to handle completing the interview
  // FIXED: Renamed from completeInterview to handleCompleteInterview to avoid recursion
  const handleCompleteInterview = async () => {
    try {
      // Call the imported API function
      console.log("Completing interview:", id);
      const response = await completeInterviewApi(id);
      
      if (response && response.interview) {
        setInterview(response.interview);
      }
      
      // Navigate to results page
      router.push(`/interviews/results/${id}`);
    } catch (error) {
      console.error('Error completing interview:', error);
      
      // Even on error, navigate to results
      router.push(`/interviews/results/${id}`);
    }
  };

  // Show loading state
  if (loading) {
    return (
      <div className="flex h-screen">
        <Sidebar activeTab="interviews" />
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading interview...</p>
          </div>
        </div>
      </div>
    );
  }

  // Show error state if interview not found
  if (!interview) {
    return (
      <div className="flex h-screen">
        <Sidebar activeTab="interviews" />
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <p className="text-red-600 mb-4">Interview not found</p>
            <button 
              onClick={() => router.push('/interviews')}
              className="bg-indigo-600 text-white px-4 py-2 rounded"
            >
              Back to Interviews
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Main interview UI
  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeTab="interviews" />
      
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* Header section with timer and controls */}
        <div className="bg-white border-b border-gray-200 p-4 flex justify-between items-center">
          <div>
            <h1 className="text-xl font-semibold">{interview.problem?.title || 'System Design Interview'}</h1>
            <p className="text-sm text-gray-500">
              Current stage: <span className="font-medium capitalize">{interview.currentStage}</span>
            </p>
          </div>
          
          <div className="flex items-center space-x-4">
            <div className={`flex items-center space-x-2 px-3 py-1 rounded-full ${
              timeRemaining < 300000 ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'
            }`}>
              <Clock className="h-4 w-4" />
              <span className="font-mono font-medium">{formatTime(timeRemaining)}</span>
            </div>
            
            <button 
              onClick={handleCompleteInterview}
              className="bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded text-sm"
            >
              End Interview
            </button>
          </div>
        </div>
        
        {/* Chat message area */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4">
          {interview.conversation.map((msg, index) => (
            <div 
              key={index} 
              className={`flex ${msg.role === 'interviewer' ? 'justify-start' : 'justify-end'}`}
            >
              <div className={`max-w-3xl rounded-lg p-4 ${
                msg.role === 'interviewer' 
                  ? 'bg-white border border-gray-200 text-gray-800' 
                  : 'bg-indigo-600 text-white'
              }`}>
                <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                {msg.role === 'interviewer' && (
                  <p className="text-xs text-gray-500 mt-1 capitalize">
                    {msg.stage} phase
                  </p>
                )}
              </div>
            </div>
          ))}
          <div ref={messagesEndRef} />
        </div>
        
        {/* Message input area */}
        <div className="bg-white border-t border-gray-200 p-4">
          <form onSubmit={handleSendMessage} className="flex space-x-4">
            <input
              type="text"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              placeholder="Type your response..."
              className="flex-1 border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              disabled={interview.status !== 'in_progress'}
            />
            <button
              type="submit"
              disabled={!message.trim() || sending || interview.status !== 'in_progress'}
              className="bg-indigo-600 text-white px-4 py-2 rounded-lg disabled:bg-indigo-300 flex items-center"
            >
              {sending ? (
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
              ) : (
                <>
                  <Send className="h-5 w-5 mr-2" />
                  Send
                </>
              )}
            </button>
          </form>
        </div>
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\interviews\index.js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Sidebar from '../../components/Sidebar';
import { Activity, Clock, Users, BookOpen } from 'lucide-react';
import { useAuth } from '../../contexts/AuthContext';
import { getInterviewProblems, startInterview } from '../../utils/api';

export default function InterviewsPage() {
  const router = useRouter();
  const { isAuthenticated, isLoading } = useAuth();
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedProblem, setSelectedProblem] = useState(null);
  const [starting, setStarting] = useState(false);

  // Check authentication and fetch problems when component mounts
  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      router.push('/auth/login');
      return;
    }

    if (isAuthenticated) {
      fetchProblems();
    }
  }, [isAuthenticated, isLoading, router]);

  // Fetch problem data from API with debugging
  const fetchProblems = async () => {
    try {
      setLoading(true);
      const data = await getInterviewProblems();
      console.log("API Response:", data); // Debug the API response
      
      // Handle both possible data structures
      if (data && data.problems) {
        setProblems(data.problems);
      } else if (Array.isArray(data)) {
        setProblems(data);
      } else {
        // Fallback to hardcoded problems if API returns unexpected format
        setProblems([
          {
            id: "url-shortener",
            title: "Design a URL Shortener",
            difficulty: "intermediate",
            description: "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly.",
            estimatedTime: 45
          },
          {
            id: "social-feed",
            title: "Design a Social Media Feed",
            difficulty: "advanced",
            description: "Design a news feed system that can handle millions of users posting and viewing content in real-time.",
            estimatedTime: 60
          },
          {
            id: "distributed-cache",
            title: "Design a Distributed Cache",
            difficulty: "intermediate",
            description: "Design a distributed caching system that can scale to handle high traffic and provide fast access to frequently used data.",
            estimatedTime: 50
          }
        ]);
      }
    } catch (error) {
      console.error('Error fetching problems:', error);
      setError('Failed to load interview problems. Using demo problems instead.');
      
      // Set fallback problems on error
      setProblems([
        {
          id: "url-shortener",
          title: "Design a URL Shortener",
          difficulty: "intermediate",
          description: "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly.",
          estimatedTime: 45
        },
        {
          id: "social-feed",
          title: "Design a Social Media Feed",
          difficulty: "advanced",
          description: "Design a news feed system that can handle millions of users posting and viewing content in real-time.",
          estimatedTime: 60
        },
        {
          id: "distributed-cache",
          title: "Design a Distributed Cache",
          difficulty: "intermediate",
          description: "Design a distributed caching system that can scale to handle high traffic and provide fast access to frequently used data.",
          estimatedTime: 50
        }
      ]);
    } finally {
      setLoading(false);
    }
  };

  // Handle starting a new interview
  const handleStartInterview = async (problemId) => {
    try {
      setStarting(true);
      const response = await startInterview(problemId);
      
      // Determine the ID to use for navigation
      const interviewId = response?.interview?.id || "1";
      router.push(`/interviews/${interviewId}`);
    } catch (error) {
      console.error('Error starting interview:', error);
      setError('Failed to start interview. Please try again later.');
      
      // On error, still navigate to a demo interview
      router.push('/interviews/1');
      setStarting(false);
    }
  };

  // Show problem details when a card is clicked
  const openProblemDetails = (problem) => {
    setSelectedProblem(problem);
  };

  // Close the problem details modal
  const closeProblemDetails = () => {
    setSelectedProblem(null);
  };

  // Loading state while fetching problems
  if (isLoading || loading) {
    return (
      <div className="flex h-screen">
        <Sidebar activeTab="interviews" />
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading interview problems...</p>
          </div>
        </div>
      </div>
    );
  }

  // Now log the current problems to debug
  console.log("Problems state before render:", problems);

  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeTab="interviews" />
      
      <div className="flex-1 p-8 overflow-auto">
        <div className="max-w-7xl mx-auto">
          <div className="mb-8">
            <h1 className="text-2xl font-bold mb-2">Practice Interviews</h1>
            <p className="text-gray-600">
              Select a system design problem to start a simulated interview session. Each interview will guide you through the key aspects of system design.
            </p>
          </div>
          
          {error && (
            <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-md mb-6">
              {error}
            </div>
          )}
          
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {problems && problems.length > 0 ? (
              // Map through actual problems if available
              problems.map((problem, index) => (
                <div 
                  key={problem.id || index}
                  className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 hover:shadow-md transition-shadow cursor-pointer"
                  onClick={() => openProblemDetails(problem)}
                >
                  <div className="flex justify-between items-start mb-4">
                    <h3 className="text-lg font-semibold">{problem.title}</h3>
                    <span className={`text-xs px-2 py-1 rounded-full ${
                      problem.difficulty === 'beginner' ? 'bg-green-100 text-green-800' :
                      problem.difficulty === 'intermediate' ? 'bg-blue-100 text-blue-800' :
                      'bg-purple-100 text-purple-800'
                    }`}>
                      {problem.difficulty.charAt(0).toUpperCase() + problem.difficulty.slice(1)}
                    </span>
                  </div>
                  <p className="text-gray-600 text-sm mb-4 line-clamp-2">
                    {problem.description}
                  </p>
                  <div className="flex justify-between items-center text-sm text-gray-500">
                    <div className="flex items-center">
                      <Clock className="h-4 w-4 mr-1" />
                      <span>{problem.estimatedTime} minutes</span>
                    </div>
                    <span>Google, Amazon</span>
                  </div>
                </div>
              ))
            ) : (
              // Show placeholder cards if no problems found
              Array.from({ length: 3 }).map((_, index) => (
                <div 
                  key={index}
                  className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 hover:shadow-md transition-shadow cursor-pointer"
                  onClick={() => openProblemDetails({
                    id: index === 0 ? "url-shortener" : index === 1 ? "social-feed" : "distributed-cache",
                    title: index === 0 ? "Design a URL Shortener" : index === 1 ? "Design a Social Media Feed" : "Design a Distributed Cache",
                    difficulty: index === 0 ? "intermediate" : index === 1 ? "advanced" : "intermediate",
                    description: index === 0 
                      ? "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly." 
                      : index === 1 
                      ? "Design a news feed system that can handle millions of users posting and viewing content in real-time." 
                      : "Design a distributed caching system that can scale to handle high traffic and provide fast access to frequently used data.",
                    estimatedTime: index === 0 ? 45 : index === 1 ? 60 : 50
                  })}
                >
                  <div className="flex justify-between items-start mb-4">
                    <h3 className="text-lg font-semibold">
                      {index === 0 ? "Design a URL Shortener" : 
                      index === 1 ? "Design a Social Media Feed" : 
                      "Design a Distributed Cache"}
                    </h3>
                    <span className="text-xs px-2 py-1 rounded-full bg-blue-100 text-blue-800">
                      {index === 0 ? "Intermediate" : index === 1 ? "Advanced" : "Intermediate"}
                    </span>
                  </div>
                  <p className="text-gray-600 text-sm mb-4">
                    {index === 0 ? "Create a service that takes long URLs and creates unique short URLs, similar to TinyURL or bit.ly." :
                    index === 1 ? "Design a news feed system that can handle millions of users posting and viewing content in real-time." :
                    "Design a distributed caching system that can scale to handle high traffic and provide fast access to frequently used data."}
                  </p>
                  <div className="flex justify-between items-center text-sm text-gray-500">
                    <div className="flex items-center">
                      <Clock className="h-4 w-4 mr-1" />
                      <span>{index === 0 ? "45" : index === 1 ? "60" : "50"} minutes</span>
                    </div>
                    <span>{index === 0 ? "Google, Uber" : index === 1 ? "Facebook, Twitter" : "Amazon, Netflix"}</span>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </div>
      
      {/* Problem Detail Modal */}
      {selectedProblem && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-auto">
            <div className="p-6">
              <div className="flex justify-between items-start mb-4">
                <h2 className="text-xl font-bold">{selectedProblem.title}</h2>
                <span className={`text-xs px-2 py-1 rounded-full ${
                  selectedProblem.difficulty === 'beginner' ? 'bg-green-100 text-green-800' :
                  selectedProblem.difficulty === 'intermediate' ? 'bg-blue-100 text-blue-800' :
                  'bg-purple-100 text-purple-800'
                }`}>
                  {selectedProblem.difficulty.charAt(0).toUpperCase() + selectedProblem.difficulty.slice(1)}
                </span>
              </div>
              
              <p className="text-gray-600 mb-6">
                {selectedProblem.description}
              </p>
              
              <div className="grid grid-cols-2 gap-4 mb-6">
                <div className="bg-gray-50 p-4 rounded-lg">
                  <div className="flex items-center mb-2">
                    <Clock className="h-5 w-5 text-gray-400 mr-2" />
                    <span className="font-medium">Duration</span>
                  </div>
                  <p className="text-gray-600">{selectedProblem.estimatedTime} minutes</p>
                </div>
                
                <div className="bg-gray-50 p-4 rounded-lg">
                  <div className="flex items-center mb-2">
                    <Activity className="h-5 w-5 text-gray-400 mr-2" />
                    <span className="font-medium">Focus Areas</span>
                  </div>
                  <p className="text-gray-600">Scalability, Data modeling, APIs</p>
                </div>
              </div>
              
              <div className="mb-6">
                <h3 className="font-medium mb-2">Interview Guidance</h3>
                <ul className="text-gray-600 space-y-2">
                  <li>• Think out loud throughout the interview</li>
                  <li>• Ask clarifying questions before diving into solutions</li>
                  <li>• Consider trade-offs in your design decisions</li>
                  <li>• Focus on high-level architecture first, then dive deeper</li>
                </ul>
              </div>
              
              <div className="flex space-x-3">
                <button
                  onClick={closeProblemDetails}
                  className="flex-1 px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
                >
                  Cancel
                </button>
                <button
                  onClick={() => handleStartInterview(selectedProblem.id)}
                  disabled={starting}
                  className="flex-1 px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 disabled:bg-indigo-300"
                >
                  {starting ? 'Starting...' : 'Start Interview'}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}


================================================================================
# FILE: client\pages\interviews\results\[id].js
# EXTENSION: .js
================================================================================
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { useAuth } from '../../../contexts/AuthContext';
import { 
  CheckCircle, 
  XCircle, 
  AlertCircle, 
  Award, 
  BarChart2,
  MessageSquare,
  Clock
} from 'lucide-react';
import Sidebar from '../../../components/Sidebar';
import { getInterviewResults } from '../../../utils/api';

export default function InterviewResultsPage() {
  const router = useRouter();
  const { id } = router.query;
  const { isAuthenticated } = useAuth();
  const [results, setResults] = useState(null);
  const [conversation, setConversation] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [activeTab, setActiveTab] = useState('summary');

  // Fetch results when component mounts
  useEffect(() => {
    if (!isAuthenticated) {
      router.push('/auth/login');
      return;
    }

    if (id) {
      console.log("Fetching results for interview:", id);
      fetchResults();
    }
  }, [id, isAuthenticated, router]);

  // Function to fetch interview results
  const fetchResults = async () => {
    try {
      setLoading(true);
      
      // Make API call to get results
      console.log("Making API call to get results:", id);
      const data = await getInterviewResults(id);
      console.log("Received results data:", data);
      
      // If we get valid data, use it
      if (data && data.results) {
        setResults(data.results);
        setConversation(data.conversation || []);
      } else {
        // Otherwise, use mock results for development
        console.log("Using mock results data");
        setResults({
          requirementsScore: 8,
          scaleEstimationScore: 7,
          architectureScore: 8,
          componentDesignScore: 7,
          tradeoffsScore: 6,
          communicationScore: 9,
          overallScore: 7.5,
          feedback: "You did a good job of identifying key requirements and proposing a reasonable architecture. Your communication was clear and structured. To improve, consider exploring more trade-offs and edge cases in your design. You might also want to think more about how to handle very large scale scenarios, particularly around database sharding and caching strategies."
        });
        
        // Set mock conversation if needed
        if (!data || !data.conversation) {
          setConversation([
            {
              role: "interviewer",
              content: "Welcome to your system design interview. Today I'd like you to design a URL shortener service like TinyURL or bit.ly. We have about 45 minutes for this discussion. Could you start by telling me how you understand this problem and what key requirements we should consider?",
              stage: "introduction",
              timestamp: new Date(Date.now() - 3600000).toISOString()
            },
            {
              role: "candidate",
              content: "I understand that we need to design a service that takes long URLs and creates shorter ones that redirect to the original URL when accessed. Key requirements would include the ability to generate unique short URLs, redirect efficiently, handle high traffic, and ensure the system is scalable and reliable.",
              stage: "introduction",
              timestamp: new Date(Date.now() - 3540000).toISOString()
            },
            {
              role: "interviewer",
              content: "Great start! Let's focus on clarifying the requirements. What functional and non-functional requirements do you think are important for a URL shortening service?",
              stage: "requirements",
              timestamp: new Date(Date.now() - 3500000).toISOString()
            }
          ]);
        }
      }
    } catch (error) {
      console.error('Error fetching results:', error);
      setError('Failed to load interview results. Please try again later.');
      
      // Use mock data even on error
      setResults({
        requirementsScore: 8,
        scaleEstimationScore: 7,
        architectureScore: 8,
        componentDesignScore: 7,
        tradeoffsScore: 6,
        communicationScore: 9,
        overallScore: 7.5,
        feedback: "You did a good job of identifying key requirements and proposing a reasonable architecture. Your communication was clear and structured. To improve, consider exploring more trade-offs and edge cases in your design."
      });
    } finally {
      setLoading(false);
    }
  };

  // Function to determine color based on score
  const getScoreColor = (score) => {
    if (score >= 8) return 'text-green-600';
    if (score >= 6) return 'text-yellow-600';
    return 'text-red-600';
  };

  // Function to get appropriate icon based on score
  const getScoreIcon = (score) => {
    if (score >= 8) return <CheckCircle className="h-5 w-5 text-green-600" />;
    if (score >= 6) return <AlertCircle className="h-5 w-5 text-yellow-600" />;
    return <XCircle className="h-5 w-5 text-red-600" />;
  };

  // Show loading state
  if (loading) {
    return (
      <div className="flex h-screen">
        <Sidebar activeTab="interviews" />
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
            <p className="text-gray-600">Loading interview results...</p>
          </div>
        </div>
      </div>
    );
  }

  // Show error state
  if (error || !results) {
    return (
      <div className="flex h-screen">
        <Sidebar activeTab="interviews" />
        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <p className="text-red-600 mb-4">{error || 'Results not found'}</p>
            <button 
              onClick={() => router.push('/interviews')}
              className="bg-indigo-600 text-white px-4 py-2 rounded"
            >
              Back to Interviews
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Main results UI
  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeTab="interviews" />
      
      <div className="flex-1 overflow-auto">
        <div className="max-w-7xl mx-auto p-6">
          <div className="mb-6">
            <h1 className="text-2xl font-bold mb-2">Interview Results</h1>
            <p className="text-gray-600">
              Review your performance and feedback from your system design interview.
            </p>
          </div>
          
          {/* Results summary card */}
          <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
            <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between mb-6">
              <div>
                <h2 className="text-xl font-bold mb-1">Overall Performance</h2>
                <p className="text-gray-600">
                  Your interview assessment and detailed feedback
                </p>
              </div>
              
              <div className="mt-4 lg:mt-0 flex items-center">
                <div className="flex items-center justify-center h-16 w-16 rounded-full bg-indigo-50 mr-4">
                  <span className="text-2xl font-bold text-indigo-600">
                    {results.overallScore}
                  </span>
                </div>
                <div>
                  <p className="font-medium">Overall Score</p>
                  <p className="text-sm text-gray-500">Out of 10</p>
                </div>
              </div>
            </div>
            
            {/* Detailed scores grid */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.requirementsScore)}
                </div>
                <div>
                  <p className="font-medium">Requirements Gathering</p>
                  <p className={`${getScoreColor(results.requirementsScore)} font-medium`}>
                    {results.requirementsScore}/10
                  </p>
                </div>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.scaleEstimationScore)}
                </div>
                <div>
                  <p className="font-medium">Scale Estimation</p>
                  <p className={`${getScoreColor(results.scaleEstimationScore)} font-medium`}>
                    {results.scaleEstimationScore}/10
                  </p>
                </div>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.architectureScore)}
                </div>
                <div>
                  <p className="font-medium">Architecture Design</p>
                  <p className={`${getScoreColor(results.architectureScore)} font-medium`}>
                    {results.architectureScore}/10
                  </p>
                </div>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.componentDesignScore)}
                </div>
                <div>
                  <p className="font-medium">Component Design</p>
                  <p className={`${getScoreColor(results.componentDesignScore)} font-medium`}>
                    {results.componentDesignScore}/10
                  </p>
                </div>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.tradeoffsScore)}
                </div>
                <div>
                  <p className="font-medium">Trade-offs Analysis</p>
                  <p className={`${getScoreColor(results.tradeoffsScore)} font-medium`}>
                    {results.tradeoffsScore}/10
                  </p>
                </div>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg flex items-center">
                <div className="mr-3">
                  {getScoreIcon(results.communicationScore)}
                </div>
                <div>
                  <p className="font-medium">Communication</p>
                  <p className={`${getScoreColor(results.communicationScore)} font-medium`}>
                    {results.communicationScore}/10
                  </p>
                </div>
              </div>
            </div>
            
            {/* Feedback section */}
            <div className="mb-6">
              <h3 className="font-medium mb-3">Detailed Feedback</h3>
              <div className="bg-gray-50 p-4 rounded-lg">
                <p className="text-gray-700 whitespace-pre-line">
                  {results.feedback}
                </p>
              </div>
            </div>
            
            {/* Action buttons */}
            <div className="flex flex-wrap gap-3 border-t pt-6">
              <button
                onClick={() => router.push('/interviews')}
                className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700"
              >
                Practice Another Problem
              </button>
              
              <button
                onClick={() => setActiveTab('conversation')}
                className="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
              >
                Review Conversation
              </button>
            </div>
          </div>
          
          {/* Conversation review tab */}
          {activeTab === 'conversation' && (
            <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
              <h2 className="text-xl font-bold mb-4">Interview Conversation</h2>
              
              <div className="space-y-4">
                {conversation.map((msg, index) => (
                  <div 
                    key={index} 
                    className={`flex ${msg.role === 'interviewer' ? 'justify-start' : 'justify-end'}`}
                  >
                    <div className={`max-w-3xl rounded-lg p-4 ${
                      msg.role === 'interviewer' 
                        ? 'bg-gray-50 border border-gray-200 text-gray-800' 
                        : 'bg-indigo-50 border border-indigo-200 text-gray-800'
                    }`}>
                      <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                      <p className="text-xs text-gray-500 mt-2">
                        {msg.role === 'interviewer' ? 'Interviewer' : 'You'} • {msg.stage} stage
                      </p>
                    </div>
                  </div>
                ))}
              </div>
              
              <div className="mt-6">
                <button
                  onClick={() => setActiveTab('summary')}
                  className="px-4 py-2 border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-50"
                >
                  Back to Results
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\ReliabilitySecurityPage.js
# EXTENSION: .js
================================================================================
// client/components/ReliabilitySecurityPage.js
import React, { useState } from 'react';

const ReliabilitySecurityPage = ({ data = {}, updateData }) => {
  const [formState, setFormState] = useState({
    faultTolerance: data.faultTolerance || '',
    dataBackup: data.dataBackup || '',
    monitoring: data.monitoring || '',
    securityMeasures: data.securityMeasures || '',
    compliance: data.compliance || '',
    disasterRecovery: data.disasterRecovery || ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    const newState = { ...formState, [name]: value };
    setFormState(newState);
    if (updateData) {
      updateData(newState);
    }
  };

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-bold text-gray-900">Reliability & Security</h2>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Fault Tolerance
        </label>
        <textarea
          name="faultTolerance"
          value={formState.faultTolerance}
          onChange={handleChange}
          rows={3}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="Redundancy, failover mechanisms, circuit breakers..."
        />
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Data Backup & Recovery
          </label>
          <textarea
            name="dataBackup"
            value={formState.dataBackup}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Backup strategies, recovery point objectives..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Monitoring & Alerting
          </label>
          <textarea
            name="monitoring"
            value={formState.monitoring}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Monitoring tools, metrics collection, alerting..."
          />
        </div>
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Security Measures
        </label>
        <textarea
          name="securityMeasures"
          value={formState.securityMeasures}
          onChange={handleChange}
          rows={4}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="Authentication, authorization, encryption, secure coding practices..."
        />
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Compliance & Regulations
          </label>
          <textarea
            name="compliance"
            value={formState.compliance}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="GDPR, HIPAA, SOC2, etc. compliance measures..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Disaster Recovery
          </label>
          <textarea
            name="disasterRecovery"
            value={formState.disasterRecovery}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Disaster recovery plans, multi-region strategy..."
          />
        </div>
      </div>
    </div>
  );
};

export default ReliabilitySecurityPage;


================================================================================
# FILE: client\pages\RequirementsPage.js
# EXTENSION: .js
================================================================================
// client/components/RequirementsPage.js
import React, { useState } from 'react';

const RequirementsPage = ({ data = {}, updateData }) => {
  const [formState, setFormState] = useState({
    functionalReqs: data.functionalReqs || '',
    nonFunctionalReqs: data.nonFunctionalReqs || '',
    constraints: data.constraints || '',
    userTypes: data.userTypes || '',
    scale: data.scale || ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    const newState = { ...formState, [name]: value };
    setFormState(newState);
    if (updateData) {
      updateData(newState);
    }
  };

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-bold text-gray-900">Requirements Analysis</h2>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Functional Requirements
        </label>
        <textarea
          name="functionalReqs"
          value={formState.functionalReqs}
          onChange={handleChange}
          rows={5}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="List the main features and functionalities the system should provide..."
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Non-Functional Requirements
        </label>
        <textarea
          name="nonFunctionalReqs"
          value={formState.nonFunctionalReqs}
          onChange={handleChange}
          rows={4}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="Performance, security, scalability requirements..."
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Constraints
        </label>
        <textarea
          name="constraints"
          value={formState.constraints}
          onChange={handleChange}
          rows={3}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="Technical, business, or regulatory constraints..."
        />
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            User Types
          </label>
          <textarea
            name="userTypes"
            value={formState.userTypes}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Describe different types of users..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Scale & Load
          </label>
          <textarea
            name="scale"
            value={formState.scale}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Expected traffic, data volume, request rates..."
          />
        </div>
      </div>
    </div>
  );
};

export default RequirementsPage;


================================================================================
# FILE: client\pages\ScalingStrategyPage.js
# EXTENSION: .js
================================================================================
// client/components/ScalingStrategyPage.js
import React, { useState } from 'react';

const ScalingStrategyPage = ({ data = {}, updateData }) => {
  const [formState, setFormState] = useState({
    scaleApproach: data.scaleApproach || '',
    loadBalancing: data.loadBalancing || '',
    dbScaling: data.dbScaling || '',
    caching: data.caching || '',
    cdn: data.cdn || '',
    serviceDiscovery: data.serviceDiscovery || ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    const newState = { ...formState, [name]: value };
    setFormState(newState);
    if (updateData) {
      updateData(newState);
    }
  };

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-bold text-gray-900">Scaling Strategy</h2>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Scaling Approach
        </label>
        <textarea
          name="scaleApproach"
          value={formState.scaleApproach}
          onChange={handleChange}
          rows={4}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="Vertical vs horizontal scaling, auto-scaling strategies..."
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Load Balancing
        </label>
        <textarea
          name="loadBalancing"
          value={formState.loadBalancing}
          onChange={handleChange}
          rows={3}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="Load balancing approaches and algorithms..."
        />
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Database Scaling
          </label>
          <textarea
            name="dbScaling"
            value={formState.dbScaling}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Sharding, replication, read replicas..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Caching Strategy
          </label>
          <textarea
            name="caching"
            value={formState.caching}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Multi-level caching, distributed caches..."
          />
        </div>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            CDN Architecture
          </label>
          <textarea
            name="cdn"
            value={formState.cdn}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Content delivery strategy, edge caching..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Service Discovery & Orchestration
          </label>
          <textarea
            name="serviceDiscovery"
            value={formState.serviceDiscovery}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Service discovery, container orchestration..."
          />
        </div>
      </div>
    </div>
  );
};

export default ScalingStrategyPage;


================================================================================
# FILE: client\pages\SystemArchitecturePage.js
# EXTENSION: .js
================================================================================
// client/components/SystemArchitecturePage.js
import React, { useState } from 'react';

const SystemArchitecturePage = ({ data = {}, updateData }) => {
  const [formState, setFormState] = useState({
    overview: data.overview || '',
    components: data.components || '',
    dataFlow: data.dataFlow || '',
    technologies: data.technologies || '',
    deploymentModel: data.deploymentModel || ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    const newState = { ...formState, [name]: value };
    setFormState(newState);
    if (updateData) {
      updateData(newState);
    }
  };

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-bold text-gray-900">System Architecture</h2>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Architecture Overview
        </label>
        <textarea
          name="overview"
          value={formState.overview}
          onChange={handleChange}
          rows={4}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="High-level description of the architecture (monolith, microservices, etc.)..."
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Key Components
        </label>
        <textarea
          name="components"
          value={formState.components}
          onChange={handleChange}
          rows={4}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="Services, modules, and their responsibilities..."
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Data Flow
        </label>
        <textarea
          name="dataFlow"
          value={formState.dataFlow}
          onChange={handleChange}
          rows={4}
          className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
          placeholder="How data flows between components and services..."
        />
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Technologies & Frameworks
          </label>
          <textarea
            name="technologies"
            value={formState.technologies}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Key technologies, frameworks, and libraries..."
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Deployment Model
          </label>
          <textarea
            name="deploymentModel"
            value={formState.deploymentModel}
            onChange={handleChange}
            rows={3}
            className="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
            placeholder="Cloud infrastructure, containerization, etc..."
          />
        </div>
      </div>
    </div>
  );
};

export default SystemArchitecturePage;


================================================================================
# FILE: client\pages\test-flow.js
# EXTENSION: .js
================================================================================
import dynamic from 'next/dynamic';

const SimpleFlow = dynamic(() => import('../components/SimpleFlow'), { 
  ssr: false,
  loading: () => (
    <div className="flex h-full items-center justify-center bg-gray-50">
      <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500"></div>
    </div>
  )
});

export default function TestPage() {
  return (
    <div style={{ width: '100%', height: '100vh', padding: '20px' }}>
      <h1 className="text-2xl font-bold mb-4">React Flow Test Page</h1>
      <div style={{ width: '100%', height: 'calc(100vh - 100px)', border: '1px solid #ccc' }}>
        <SimpleFlow />
      </div>
    </div>
  );
}


================================================================================
# FILE: client\pages\WorkbookLayout.js
# EXTENSION: .js
================================================================================
// pages/WorkbookLayout.js
import React, { useState } from 'react';
import { ClipboardList, Database, Code, Layout, BarChart, Shield, MessageSquare, LogOut, Menu, X, User } from 'lucide-react';
import ExperienceLevelSelector from '../components/ExperienceLevelSelector';
import ConciseModeToggle from '../components/ConciseModeToggle';
import { getEvaluation } from '../utils/api';

// Placeholder components - replace these with your actual components when ready
const RequirementsPage = () => <div>Requirements Page</div>;
const APIDesignPage = () => <div>API Design Page</div>;
const DataModelPage = () => <div>Data Model Page</div>;
const SystemArchitecturePage = () => <div>System Architecture Page</div>;
const ScalingStrategyPage = () => <div>Scaling Strategy Page</div>;
const ReliabilitySecurityPage = () => <div>Reliability & Security Page</div>;
const CoachAgentInterface = ({ isOpen, onClose, currentPage, currentData }) => (
  isOpen ? <div>Coach Interface for {currentPage}</div> : null
);

const WorkbookLayout = ({ onBack, sessionId }) => {
  const [activeTab, setActiveTab] = useState('requirements');
  const [showCoach, setShowCoach] = useState(false);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [userLevel, setUserLevel] = useState('mid-level');
  const [conciseMode, setConciseMode] = useState(true);
  
  const [formData, setFormData] = useState({
    requirements: {},
    api: {},
    data: {},
    architecture: {},
    scaling: {},
    reliability: {}
  });
  
  // Mock function for updating form data
  const updateFormData = (section, data) => {
    setFormData({
      ...formData,
      [section]: data
    });
  };
  
  // Define tabs for navigation
  const tabs = [
    { id: 'requirements', label: 'Requirements', icon: <ClipboardList size={18} /> },
    { id: 'api', label: 'API Design', icon: <Code size={18} /> },
    { id: 'data', label: 'Data Model', icon: <Database size={18} /> },
    { id: 'architecture', label: 'Architecture', icon: <Layout size={18} /> },
    { id: 'scaling', label: 'Scaling Strategy', icon: <BarChart size={18} /> },
    { id: 'reliability', label: 'Reliability & Security', icon: <Shield size={18} /> }
  ];
  
  const getActivePageComponent = () => {
    switch (activeTab) {
      case 'requirements':
        return <RequirementsPage data={formData.requirements} updateData={(data) => updateFormData('requirements', data)} />;
      case 'api':
        return <APIDesignPage data={formData.api} updateData={(data) => updateFormData('api', data)} />;
      case 'data':
        return <DataModelPage data={formData.data} updateData={(data) => updateFormData('data', data)} />;
      case 'architecture':
        return <SystemArchitecturePage data={formData.architecture} updateData={(data) => updateFormData('architecture', data)} />;
      case 'scaling':
        return <ScalingStrategyPage data={formData.scaling} updateData={(data) => updateFormData('scaling', data)} />;
      case 'reliability':
        return <ReliabilitySecurityPage data={formData.reliability} updateData={(data) => updateFormData('reliability', data)} />;
      default:
        return <RequirementsPage data={formData.requirements} updateData={(data) => updateFormData('requirements', data)} />;
    }
  };
  
  // Handler for "Ask Coach" button clicks from any page
  const handleAskCoach = async () => {
    const currentData = {
      ...formData[activeTab],
      userLevel,
      conciseMode,
      currentPage: activeTab
    };
    
    try {
      // Get all workbook content for evaluation
      if (sessionId) {
        const allWorkbookData = {
          requirements: formData.requirements,
          api: formData.api,
          data: formData.data,
          architecture: formData.architecture,
          scaling: formData.scaling,
          reliability: formData.reliability
        };
        
        // Get evaluation in background (don't await to keep UI responsive)
        getEvaluation(sessionId, allWorkbookData, userLevel, conciseMode)
          .catch(err => console.error('Background evaluation error:', err));
      }
    } catch (error) {
      console.error('Error in handleAskCoach:', error);
    }
    
    setShowCoach(true);
  };
  
  return (
    <div className="flex flex-col h-screen bg-gray-100">
      {/* Top Navigation Bar */}
      <header className="bg-white border-b border-gray-200 shadow-sm">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between h-16">
            <div className="flex">
              <div className="flex-shrink-0 flex items-center">
                <Layout className="h-8 w-8 text-indigo-600" />
                <span className="font-bold text-lg text-gray-900 ml-2">System Design Coach</span>
              </div>
            </div>
            
            <div className="hidden md:ml-6 md:flex md:items-center md:space-x-4">
              <button 
                onClick={onBack}
                className="text-gray-500 hover:text-gray-700 px-3 py-2 rounded-md text-sm font-medium"
              >
                Dashboard
              </button>
              <button className="bg-indigo-50 text-indigo-700 px-3 py-2 rounded-md text-sm font-medium">
                Workbook
              </button>
              <button className="text-gray-500 hover:text-gray-700 px-3 py-2 rounded-md text-sm font-medium">
                History
              </button>
              
              {/* Add settings panel with concise mode toggle and experience level */}
              <div className="ml-4 flex items-center space-x-4">
                <ConciseModeToggle 
                  isEnabled={conciseMode}
                  onToggle={setConciseMode}
                />
                
                <div className="border-l border-gray-300 h-6"></div>
                
                <div className="flex items-center">
                  <User size={16} className="text-gray-500 mr-2" />
                  <select 
                    value={userLevel} 
                    onChange={(e) => setUserLevel(e.target.value)}
                    className="text-sm border-none bg-transparent focus:ring-0 text-gray-600 p-0"
                  >
                    <option value="junior">Junior</option>
                    <option value="mid-level">Mid-Level</option>
                    <option value="senior">Senior</option>
                    <option value="staff+">Staff+</option>
                  </select>
                </div>
              </div>
            </div>
            
            <div className="flex items-center">
              <button 
                onClick={handleAskCoach}
                className="flex items-center px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700"
              >
                <MessageSquare size={18} className="mr-2" />
                <span className="hidden md:inline">Ask Coach</span>
              </button>
              
              <div className="ml-4 relative">
                <div className="ml-3 relative">
                  <div>
                    <button className="flex items-center text-gray-500 hover:text-gray-700">
                      <span className="sr-only">Open user menu</span>
                      <LogOut size={18} />
                    </button>
                  </div>
                </div>
              </div>
              
              <div className="-mr-2 flex items-center md:hidden">
                <button
                  onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
                  className="inline-flex items-center justify-center p-2 rounded-md text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:bg-gray-100 focus:text-gray-500"
                >
                  <span className="sr-only">Open main menu</span>
                  {mobileMenuOpen ? <X size={24} /> : <Menu size={24} />}
                </button>
              </div>
            </div>
          </div>
        </div>
      </header>
      
      {/* Tabs Navigation */}
      <div className="hidden md:block bg-white border-b border-gray-200">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex">
            {tabs.map((tab) => (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                className={`flex items-center py-4 px-4 text-sm font-medium ${
                  activeTab === tab.id
                    ? 'border-b-2 border-indigo-500 text-indigo-600'
                    : 'text-gray-500 hover:text-gray-700 hover:border-b-2 hover:border-gray-300'
                }`}
              >
                {tab.icon}
                <span className="ml-2">{tab.label}</span>
              </button>
            ))}
          </div>
        </div>
      </div>
      
      {/* Mobile menu, show/hide based on menu state */}
      {mobileMenuOpen && (
        <div className="md:hidden">
          <div className="pt-2 pb-3 space-y-1">
            {tabs.map((tab) => (
              <button
                key={tab.id}
                onClick={() => {
                  setActiveTab(tab.id);
                  setMobileMenuOpen(false);
                }}
                className={`flex items-center w-full px-3 py-2 text-base font-medium ${
                  activeTab === tab.id
                    ? 'bg-indigo-50 text-indigo-700'
                    : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'
                }`}
              >
                {tab.icon}
                <span className="ml-3">{tab.label}</span>
              </button>
            ))}
          </div>
          
          {/* Mobile Settings */}
          <div className="pt-4 pb-3 border-t border-gray-200">
            <div className="flex items-center px-4">
              <div className="flex-shrink-0">
                <User className="h-10 w-10 text-gray-400" />
              </div>
              <div className="ml-3">
                <div className="text-base font-medium text-gray-800">Settings</div>
              </div>
            </div>
            <div className="mt-3 space-y-1">
              <div className="px-4 py-2 flex justify-between items-center">
                <span className="text-base font-medium text-gray-800">Concise Mode</span>
                <ConciseModeToggle 
                  isEnabled={conciseMode}
                  onToggle={setConciseMode}
                />
              </div>
              <div className="px-4 py-2">
                <div className="flex justify-between items-center">
                  <span className="text-base font-medium text-gray-800">Experience Level</span>
                  <select 
                    value={userLevel} 
                    onChange={(e) => setUserLevel(e.target.value)}
                    className="mt-1 block w-1/2 pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
                  >
                    <option value="junior">Junior</option>
                    <option value="mid-level">Mid-Level</option>
                    <option value="senior">Senior</option>
                    <option value="staff+">Staff+</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
      
      {/* Main content area */}
      <main className="flex-1 overflow-auto">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
          {getActivePageComponent()}
        </div>
      </main>
      
      {/* Coach agent dialog */}
      {showCoach && (
        <CoachAgentInterface
          isOpen={showCoach}
          onClose={() => setShowCoach(false)}
          currentPage={activeTab}
          currentData={{
            ...formData[activeTab],
            userLevel,
            conciseMode
          }}
        />
      )}
    </div>
  );
};

export default WorkbookLayout;


================================================================================
# FILE: client\postcss.config.js
# EXTENSION: .js
================================================================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


================================================================================
# FILE: client\tailwind.config.js
# EXTENSION: .js
================================================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./pages/**/*.{js,ts,jsx,tsx}",
      "./components/**/*.{js,ts,jsx,tsx}"
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }


================================================================================
# FILE: client\utils\api.js
# EXTENSION: .js
================================================================================
// client/utils/api.js
import axios from 'axios';
import Cookies from 'js-cookie';

// Create an Axios instance with a base URL
const API_URL = typeof window !== 'undefined' ? 
  (process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000') : 
  'http://localhost:5000';

  const api = axios.create({
    baseURL: API_URL,
    timeout: 60000, // Increase timeout to 60 seconds
    retries: 3,
    retryDelay: 1000,
  });
  
  // Add retry logic to axios
  api.interceptors.response.use(null, async (error) => {
    const { config } = error;
    if (!config || !config.retries) return Promise.reject(error);
    
    config.retryCount = config.retryCount || 0;
    
    if (config.retryCount >= config.retries) {
      return Promise.reject(error);
    }
    
    config.retryCount += 1;
    console.log(`Retrying request (${config.retryCount}/${config.retries})`);
    
    // Wait before retrying
    await new Promise(resolve => setTimeout(resolve, config.retryDelay));
    return api(config);
  });

// Attach the auth token to every request if present
api.interceptors.request.use(
  (config) => {
    const token = Cookies.get('auth_token');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Add response interceptor for better error handling
api.interceptors.response.use(
  (response) => response,
  (error) => {
    // Log detailed error information
    if (error.response) {
      console.error('API Error Response:', {
        status: error.response.status,
        data: error.response.data,
        headers: error.response.headers,
      });
    } else if (error.request) {
      console.error('API Error Request:', error.request);
    } else {
      console.error('API Error Message:', error.message);
    }
    return Promise.reject(error);
  }
);

// === Authentication APIs ===
export const loginUser = async (email, password) => {
  try {
    const response = await api.post('/api/auth/login', { email, password });
    return response.data;
  } catch (error) {
    console.error('Login error:', error);
    throw error;
  }
};

export const registerUser = async (name, email, password, experience) => {
  try {
    const response = await api.post('/api/auth/register', { name, email, password, experience });
    return response.data;
  } catch (error) {
    console.error('Registration error:', error);
    throw error;
  }
};

export const getMe = async () => {
  try {
    const response = await api.get('/api/auth/me');
    return response.data;
  } catch (error) {
    console.error('Get user profile error:', error);
    throw error;
  }
};

export const logoutUser = async () => {
  try {
    const response = await api.post('/api/auth/logout');
    return response.data;
  } catch (error) {
    console.error('Logout error:', error);
    throw error;
  }
};

// === Interview APIs ===
export const sendInterviewMessage = async (interviewId, message, options = {}) => {
  try {
    const payload = { message };
    
    // Add optional parameters if provided
    if (options.userLevel) payload.userLevel = options.userLevel;
    if (options.conciseMode !== undefined) payload.conciseMode = options.conciseMode;
    
    const response = await api.post(`/api/interviews/${interviewId}/message`, payload);
    return response.data;
  } catch (error) {
    console.error('Error sending interview message:', error);
    throw error;
  }
};

export const getInterviews = async () => {
  try {
    const response = await api.get('/api/interviews');
    return response.data;
  } catch (error) {
    console.error('Error fetching interviews:', error);
    throw error;
  }
};

export const getInterview = async (id) => {
  try {
    const response = await api.get(`/api/interviews/${id}`);
    return response.data;
  } catch (error) {
    console.error('Error fetching interview:', error);
    throw error;
  }
};

export const getInterviewProblems = async () => {
  try {
    const response = await api.get('/api/interviews/problems');
    return response.data;
  } catch (error) {
    console.error('Error fetching interview problems:', error);
    throw error;
  }
};

export const startInterview = async (problemId, options = {}) => {
  try {
    const payload = { problemId };
    
    // Add optional parameters if provided
    if (options.userLevel) payload.userLevel = options.userLevel;
    if (options.conciseMode !== undefined) payload.conciseMode = options.conciseMode;
    
    const response = await api.post('/api/interviews/start', payload);
    return response.data;
  } catch (error) {
    console.error('Error starting interview:', error);
    throw error;
  }
};

export const completeInterview = async (interviewId) => {
  try {
    const response = await api.post(`/api/interviews/${interviewId}/complete`);
    return response.data;
  } catch (error) {
    console.error('Error completing interview:', error);
    throw error;
  }
};

export const sendMessage = async (interviewId, message, options = {}) => {
  try {
    const payload = { message };
    
    // Add optional parameters if provided
    if (options.userLevel) payload.userLevel = options.userLevel;
    if (options.conciseMode !== undefined) payload.conciseMode = options.conciseMode;
    
    const response = await api.post(`/api/interviews/${interviewId}/message`, payload);
    return response.data;
  } catch (error) {
    console.error('Error sending message:', error);
    throw error;
  }
};

export const endInterview = async (interviewId) => {
  try {
    const response = await api.post(`/api/interviews/${interviewId}/end`);
    return response.data;
  } catch (error) {
    console.error('Error ending interview:', error);
    throw error;
  }
};

export const getInterviewResults = async (interviewId) => {
  try {
    const response = await api.get(`/api/interviews/${interviewId}/results`);
    return response.data;
  } catch (error) {
    console.error('Error fetching interview results:', error);
    throw error;
  }
};

// === Coaching APIs ===
export const getCoachingSessions = async () => {
  try {
    const response = await api.get('/api/coaching');
    return response.data;
  } catch (error) {
    console.error('Error fetching coaching sessions:', error);
    throw error;
  }
};

export const getCoachingProblems = async () => {
  try {
    const response = await api.get('/api/coaching/problems');
    return response.data;
  } catch (error) {
    console.error('Error fetching coaching problems:', error);
    throw error;
  }
};

export const startCoachingSession = async (problemId, options = {}) => {
  try {
    console.log('API: Starting coaching session for:', problemId);
    
    const payload = { };
    
    // Add optional parameters if provided
    if (options.userLevel) payload.userLevel = options.userLevel;
    if (options.conciseMode !== undefined) payload.conciseMode = options.conciseMode;
    
    const response = await api.post(`/api/coaching/start/${problemId}`, payload);
    console.log('API: Session start response:', JSON.stringify(response.data, null, 2));
    return response.data;
  } catch (error) {
    console.error('API: Error starting coaching session:', error);
    throw error;
  }
};

export const getCoachingSession = async (id) => {
  if (!id) {
    return {
      id: 'default',
      conversation: [{
        role: 'assistant',
        content: "Welcome to your system design coaching session. Let's get started!",
        timestamp: new Date().toISOString()
      }],
      problem: { title: 'System Design Coaching' }
    };
  }
  
  try {
    const response = await api.get(`/api/coaching/${id}`);
    
    // Ensure conversation exists with at least one message
    const conversation = response.data.conversation && response.data.conversation.length > 0 
      ? response.data.conversation 
      : [{
          role: 'assistant',
          content: `Welcome to your ${response.data.problem?.title || 'system design'} coaching session!`,
          timestamp: new Date().toISOString()
        }];
    
    return {
      ...response.data,
      conversation
    };
  } catch (error) {
    console.error(`Error fetching coaching session ${id}:`, error);
    return {
      id,
      conversation: [{
        role: 'assistant',
        content: "Welcome to your system design coaching session. Let's get started!",
        timestamp: new Date().toISOString()
      }],
      problem: { title: 'System Design Coaching' }
    };
  }
};

export const sendCoachingMessage = async (sessionId, message, contextInfo = null) => {
  try {
    if (!sessionId) {
      console.error("No sessionId provided to sendCoachingMessage");
      throw new Error("No sessionId provided");
    }
    
    if (!message || typeof message !== 'string' || message.trim() === '') {
      console.error("Invalid message provided to sendCoachingMessage");
      throw new Error("Invalid message format");
    }
    
    // Use api instance instead of axios directly
    const response = await api.post(`/api/coaching/${sessionId}/message`, { 
      message,
      contextInfo // Include contextInfo which may contain userLevel and conciseMode
    });
    
    return response.data;
  } catch (error) {
    console.error("Error sending coaching message:", error);
    throw error;
  }
};

export const getCoachingMaterials = async (sessionId, topic, options = {}) => {
  // Handle missing sessionId
  if (!sessionId || sessionId === 'undefined' || sessionId === 'null') {
    console.warn('No valid sessionId provided to getCoachingMaterials');
    // Return generic materials instead of failing
    return {
      title: `Learning Materials: ${topic || 'System Design'}`,
      content: '<p>Please refresh the page or start a new session to access learning materials.</p>'
    };
  }

  try {
    const payload = { topic };
    
    // Add optional parameters if provided
    if (options.userLevel) payload.userLevel = options.userLevel;
    if (options.conciseMode !== undefined) payload.conciseMode = options.conciseMode;
    
    const response = await api.post(`/api/coaching/${sessionId}/materials`, payload);
    
    // If no materials found, return a default
    if (!response.data) {
      return {
        title: `Learning Materials: ${topic}`,
        content: '<p>No specific materials available for this topic yet.</p>'
      };
    }
    
    return response.data;
  } catch (error) {
    console.error('Error fetching coaching materials:', error);
    // Return fallback content
    return {
      title: `Learning Materials: ${topic}`,
      content: '<p>Unable to load learning materials at this time.</p>'
    };
  }
};

// === Diagram APIs ===
export const getInterviewDiagram = async (interviewId, diagramType = 'architecture', customPrompt = null) => {
  try {
    const response = await api.post(`/api/interviews/${interviewId}/diagram`, {
      diagramType,
      customPrompt
    });
    return response.data;
  } catch (error) {
    console.error('Error generating interview diagram:', error);
    throw error;
  }
};

export const getCoachingDiagram = async (sessionId, diagramType = 'architecture', customPrompt = null) => {
  // Handle missing sessionId
  if (!sessionId || sessionId === 'undefined' || sessionId === 'null') {
    console.warn('No valid sessionId provided to getCoachingDiagram');
    return {
      mermaidCode: 'graph TD\n    Client[Client] --> API[API Gateway]\n    API --> Service[Service]\n    Service --> DB[(Database)]'
    };
  }

  try {
    const response = await api.post(`/api/coaching/${sessionId}/diagram`, {
      diagramType,
      customPrompt
    });
    
    if (!response.data || !response.data.mermaidCode) {
      return {
        mermaidCode: 'graph TD\n    Client[Client] --> API[API Gateway]\n    API  --> Service[Service]\n    Service --> DB[(Database)]'
      };
    }
    
    return response.data;
  } catch (error) {
    console.error('Error generating coaching diagram:', error);
    // Return a default diagram
    return {
      mermaidCode: 'graph TD\n    Client[Client] --> API[API Gateway]\n    API  --> Service[Service]\n    Service --> DB[(Database)]'
    };
  }
};

export const saveDiagram = async (sessionId, diagramData) => {
  // Handle missing sessionId
  if (!sessionId || sessionId === 'undefined' || sessionId === 'null') {
    console.warn('No valid sessionId provided to saveDiagram');
    return { 
      success: false, 
      message: 'Session ID is required to save the diagram' 
    };
  }

  try {
    const response = await api.post(`/api/coaching/${sessionId}/diagram/save`, {
      diagram: diagramData
    });
    return response.data;
  } catch (error) {
    console.error('Error saving diagram:', error);
    // Return a simple success message even on failure to keep UI responsive
    return { success: false, message: 'Failed to save diagram, but you can continue working' };
  }
};

export const getDiagramTypes = async () => {
  try {
    const response = await api.get('/api/interviews/diagram/types');
    return response.data.types;
  } catch (error) {
    console.error('Error fetching diagram types:', error);
    return {
      ARCHITECTURE: 'architecture',
      ER: 'entity-relationship',
      SEQUENCE: 'sequence',
      API: 'api',
      COMPONENT: 'component',
      FLOW: 'flow'
    };
  }
};

// === Problem APIs ===
export const getProblems = async () => {
  try {
    const response = await api.get('/api/problems');
    return response.data;
  } catch (error) {
    console.error('Error fetching problems:', error);
    throw error;
  }
};

export const getProblem = async (id) => {
  try {
    const response = await api.get(`/api/problems/${id}`);
    return response.data;
  } catch (error) {
    console.error('Error fetching problem:', error);
    throw error;
  }
};

// === Grader APIs (NEW) ===
export const getEvaluation = async (sessionId, workbookContent, userLevel = 'mid-level', conciseMode = true) => {
  try {
    if (!sessionId) {
      console.error("No sessionId provided to getEvaluation");
      throw new Error("No sessionId provided");
    }
    
    const response = await api.post(`/api/grader/evaluate/${sessionId}`, {
      workbookContent,
      userLevel,
      conciseMode
    });
    
    return response.data;
  } catch (error) {
    console.error('Error getting evaluation:', error);
    throw error;
  }
};

export const getFinalAssessment = async (interviewId, userLevel = 'mid-level', conciseMode = true) => {
  try {
    if (!interviewId) {
      console.error("No interviewId provided to getFinalAssessment");
      throw new Error("No interviewId provided");
    }
    
    const response = await api.post(`/api/grader/assessment/${interviewId}`, {
      userLevel,
      conciseMode
    });
    
    return response.data;
  } catch (error) {
    console.error('Error getting final assessment:', error);
    throw error;
  }
};

export const getEvaluationHistory = async (sessionId) => {
  try {
    if (!sessionId) {
      console.error("No sessionId provided to getEvaluationHistory");
      throw new Error("No sessionId provided");
    }
    
    const response = await api.get(`/api/grader/${sessionId}`);
    return response.data;
  } catch (error) {
    console.error('Error getting evaluation history:', error);
    throw error;
  }
};

export const getLatestEvaluation = async (sessionId) => {
  try {
    if (!sessionId) {
      console.error("No sessionId provided to getLatestEvaluation");
      throw new Error("No sessionId provided");
    }
    
    const response = await api.get(`/api/grader/latest/${sessionId}`);
    return response.data;
  } catch (error) {
    console.error('Error getting latest evaluation:', error);
    throw error;
  }
};

export default api;


================================================================================
# FILE: data\persona\coachPersona.js
# EXTENSION: .js
================================================================================
// server/data/persona/coachPersona.js

module.exports = {
  id: "coach",
  name: "Design Coach",
  role: "coach",
  description:
    "A supportive system design coach that guides users through system design interviews and helps them refine their ideas using focused questioning and clear examples.",
  systemPrompt: `
You are a System Design Coach specializing in helping users learn and apply system design concepts. Your purpose is to guide users through the learning process without directly solving their problems. Adapt your teaching style based on the user's demonstrated knowledge level while remaining supportive and educational.

COACHING APPROACH:
- Use a blend of Socratic questioning, examples, and explanations.
- **Ask only one clear, focused question at a time and wait for the user's response before proceeding.**
- Provide narrative, context-rich feedback without relying solely on bullet lists.
- Always refer to the project context and any workbook content provided.
- Balance theory with practical implementation advice.

WORKBOOK AWARENESS:
- Reference specific workbook sections when relevant.
- Use workbook data to tailor your explanations and question depth.

When responding, be concise yet narrative. Keep paragraphs short (3-4 sentences) and conclude with a thoughtful question to promote further discussion.
  `,
  suggestions: [
    "What are the key trade-offs in your design?",
    "How does your approach address scalability?",
    "What alternatives did you consider and why?"
  ],
  pageSuggestions: {
    requirements: [
      "What are the core functional and non-functional requirements?",
      "Have you considered all stakeholder inputs for this section?"
    ],
    api: [
      "How should the API be structured?",
      "What security measures should be in place for your endpoints?"
    ],
    architecture: [
      "What are the key components of your architecture?",
      "How do these components interact in your design?"
    ]
  },
  responsePatterns: {
    default:
      "Provide a detailed, narrative explanation that references the project context and workbook data.",
    concise:
      "Provide a brief, context-aware explanation with clear, direct points."
  }
};



================================================================================
# FILE: data\persona\graderPersona.js
# EXTENSION: .js
================================================================================
// server/data/personas/graderPersona.js

module.exports = {
   id: "grader",
   name: "Design Grader",
   role: "grader",
   description:
     "An objective system design grader that evaluates designs based on a structured rubric. Provide both numerical scores and qualitative feedback without being overly critical.",
   systemPrompt: `
 You are a System Design Grader responsible for evaluating system design solutions.
 Use a consistent, objective evaluation framework that covers requirements analysis, architecture, data modeling, scalability, and reliability.
 Provide a brief summary assessment with numerical scores and actionable feedback for improvement.
 Your tone is neutral and analytical, focusing on substance rather than presentation style.
 
 EVALUATION FRAMEWORK:
 - Requirements Analysis: Assess clarity and completeness.
 - System Interface: Evaluate API design and consistency.
 - Capacity Estimation: Review assumptions and calculations.
 - Data Modeling: Examine schema design and relationships.
 - High-Level Architecture: Consider component interactions.
 - Scalability & Performance: Check for bottlenecks and optimization.
 - Reliability & Fault Tolerance: Evaluate redundancy and failure recovery.
 
 Provide your feedback with both scores and specific suggestions for improvement.
 `,
   suggestions: [
     "What are the most critical gaps in this design?",
     "How could the scalability be improved?",
     "What trade-offs should be considered to optimize performance?"
   ],
   responsePatterns: {
     default:
       "Provide a structured evaluation with a summary, dimensional breakdown, and prioritized improvements.",
     concise:
       "Give a brief summary of strengths and weaknesses along with key improvement suggestions."
   }
 };
 


================================================================================
# FILE: data\persona\interviewerPersona.js
# EXTENSION: .js
================================================================================
// server/data/personas/interviewerPersona.js

module.exports = {
    id: "interviewer",
    name: "Design Interviewer",
    role: "interviewer",
    description:
      "A professional system design interviewer who simulates a FAANG-level technical interview. You assess system design skills by asking challenging questions and probing the candidate’s reasoning.",
    systemPrompt: `
  You are a System Design Interviewer simulating a realistic FAANG-level technical interview.
  Your role is to challenge the candidate with probing questions while maintaining a neutral, professional tone.
  Ask clear, focused questions and request trade-off justifications without giving direct solutions.
  
  INTERVIEW STRUCTURE:
  1. Clarify the problem statement.
  2. Ask about functional and non-functional requirements.
  3. Probe the high-level architecture and component interactions.
  4. Challenge the candidate on scalability, performance, and reliability aspects.
  5. Wrap up by summarizing strengths and weaknesses.
  
  Keep your responses concise and use a Socratic approach. Do not provide direct solutions.
  `,
    suggestions: [
      "Can you explain how your design handles a sudden traffic spike?",
      "What are the trade-offs of your chosen architecture?",
      "How do you plan to monitor and scale this system?"
    ],
    pageSuggestions: {
      general: [
        "Could you clarify your assumptions?",
        "What alternative approaches did you consider?"
      ]
    },
    responsePatterns: {
      default:
        "Ask follow-up questions to probe deeper into the candidate's design decisions.",
      concise:
        "Pose a clear, focused question that challenges the candidate to justify their choices."
    }
  };
  


================================================================================
# FILE: data\problems.js
# EXTENSION: .js
================================================================================
// server/data/problems.js
// This file exports an array of detailed problem contexts for your system design challenges.
// Each problem includes extensive details such as constraints, scale requirements, architecture notes,
// business requirements, user stories, performance metrics, and additional considerations.

module.exports = [
    {
      id: "urlShortener",
      title: "URL Shortener Service",
      description: "Design a scalable URL shortener service similar to TinyURL or bit.ly. The service must generate unique short URLs that redirect to the original long URLs.",
      additionalInfo: "The service should support high-frequency URL creation and redirection, include URL analytics, abuse prevention, custom aliases, and expiration policies.",
      constraints: {
        shortCodeLength: 7,
        redirectionLatency: "Target <50ms under peak load",
        availability: "99.99% uptime with multi-region support",
        security: "Validate URLs to prevent injection; enforce rate limiting and anti-abuse measures",
        dataConsistency: "Eventual consistency for URL mappings; strong consistency for analytics data"
      },
      scaleRequirements: {
        estimatedQPS: "Approximately 1000 QPS during peak hours",
        expectedDataVolume: "Billions of URL mappings over time",
        storage: "In-memory caches (e.g., Redis) for fast lookups plus persistent storage (e.g., NoSQL) for durability",
        cachingStrategy: "Aggressive caching for redirection paths with periodic persistence updates"
      },
      architectureNotes: "Consider a distributed microservice architecture with components for URL generation, redirection, and analytics. Use a distributed hash table for mappings and plan for collision resolution, custom aliases, and URL expiration.",
      businessRequirements: "Monetization via premium custom URLs and analytics dashboards; integration with third-party platforms via a robust API.",
      userStories: [
        "As a user, I want to quickly shorten a long URL for easy sharing.",
        "As an admin, I need to monitor URL usage and detect abuse.",
        "As a developer, I want a reliable API for URL shortening integration."
      ],
      performanceMetrics: {
        averageResponseTime: "<50ms for redirects",
        throughput: "Support at least 1 million redirections per day",
        errorRate: "<0.1% failed redirections"
      },
      additionalConsiderations: "Handle duplicate requests, custom alias conflicts, and periodic cleanup of expired URLs."
    },
    {
      id: "socialMediaFeed",
      title: "Social Media Feed",
      description: "Design a system to provide a personalized, real-time feed for a social media platform that aggregates posts, images, videos, and trending topics.",
      additionalInfo: "The feed must support both algorithmic and chronological ordering and enable user interactions (likes, comments, shares) with continuous updates.",
      constraints: {
        personalization: "Tailor feed ranking based on user behavior and interests",
        refreshLatency: "Feed updates within 200ms for active users",
        availability: "99.9% uptime during peak usage",
        consistency: "Eventual consistency for feed data; strong consistency for critical interactions"
      },
      scaleRequirements: {
        estimatedQPS: "Tens of thousands of QPS during peak periods",
        expectedDataVolume: "Billions of posts, comments, and media references",
        storage: "Distributed storage for posts/media, with CDNs for media delivery",
        caching: "In-memory caching for frequently accessed timelines and trending topics"
      },
      architectureNotes: "Adopt a hybrid approach using both push and pull for feed updates. Employ message queues for notifications and microservices for separation of concerns across post management, user interactions, and trending analytics.",
      businessRequirements: "Integration with advertising platforms, monetization through sponsored posts, and developer APIs for third-party integrations.",
      userStories: [
        "As a user, I want a feed that updates to reflect my interests.",
        "As a content creator, I need analytics on engagement.",
        "As a marketer, I want targeted advertising based on trends."
      ],
      performanceMetrics: {
        refreshTime: "Under 200ms for timeline updates",
        dailyActiveUsers: "Support up to 100 million users",
        errorRate: "<0.5% feed failures during peak load"
      },
      additionalConsiderations: "Address content moderation, spam filtering, and bot content; balance algorithmic recommendations with user control."
    },
    {
      id: "rideSharing",
      title: "Ride Sharing Application",
      description: "Design a ride-sharing system that efficiently matches drivers with riders in real-time, handling dynamic pricing and high availability.",
      additionalInfo: "The application must process real-time location data, perform rapid driver-rider matching, and support surge pricing along with robust notifications and in-app payments.",
      constraints: {
        realTimeProcessing: "Process location updates and matching within 100ms",
        dynamicPricing: "Implement a transparent, near real-time surge pricing algorithm",
        availability: "High fault tolerance with multi-region redundancy",
        security: "Secure user data (location, payment) with encryption and strong authentication"
      },
      scaleRequirements: {
        estimatedQPS: "Support thousands of concurrent ride requests during peak events",
        dataVolume: "Continuous streams of geolocation data from many users",
        storage: "Geospatial databases for tracking and scalable messaging systems (e.g., Kafka) for real-time data",
        caching: "Caching for high-frequency lookups of driver availability and nearby requests"
      },
      architectureNotes: "Use a microservices architecture with dedicated services for matching, pricing, notifications, and payments. Employ event-driven communication for real-time updates and design regional clusters to minimize latency.",
      businessRequirements: "Include driver and rider ratings, in-app payments, and support for scheduled/on-demand rides; integrate with mapping/navigation APIs.",
      userStories: [
        "As a rider, I want to request a ride quickly and see my pickup time.",
        "As a driver, I need clear ride requests with pickup/drop-off details.",
        "As an operator, I want to monitor ride activity and adjust surge pricing dynamically."
      ],
      performanceMetrics: {
        matchingLatency: "<100ms for pairing",
        systemUptime: "99.95% uptime",
        successRate: "Over 99% ride completion success"
      },
      additionalConsiderations: "Plan for cancellations, no-shows, and traffic variations; consider integration with public transit data and robust peak-load handling."
    }
  ];
  


================================================================================
# FILE: server\config.py
# EXTENSION: .py
================================================================================
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Database Configuration
MONGO_URI = os.getenv('MONGO_URI')

# Authentication Configuration
JWT_SECRET = os.getenv('JWT_SECRET')

# API Keys
ANTHROPIC_API_KEY = os.getenv('ANTHROPIC_API_KEY')
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

# Server Configuration
PORT = int(os.getenv('PORT', 5000))



================================================================================
# FILE: server\config\aiConfig.js
# EXTENSION: .js
================================================================================
// server/config/aiConfig.js
module.exports = {
    defaultProvider: process.env.AI_PROVIDER || 'claude',
    claude: {
      apiKey: process.env.ANTHROPIC_API_KEY,
      model: 'claude-3-5-sonnet-latest',
      maxTokens: 1000,
      temperature: 0.7,
      maxRetries: 5
    }
  };
  


================================================================================
# FILE: server\index.js
# EXTENSION: .js
================================================================================
// server/index.js
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const dotenv = require('dotenv');
const morgan = require('morgan');
const path = require('path');

dotenv.config();
const app = express();
const PORT = process.env.PORT || 5000;

// ------------------------------
// Initialize PersonaService
// ------------------------------
const coachPersona = require('../data/persona/coachPersona');
const interviewerPersona = require('../data/persona/interviewerPersona');
const graderPersona = require('../data/persona/graderPersona');

const personaConfig = {
  personas: [coachPersona, interviewerPersona, graderPersona]
};

const PersonaService = require('./services/engines/PersonaService');
PersonaService.initialize(personaConfig);
console.log("Initialized personas:", PersonaService.getAllPersonas().map(p => p.id).join(", "));

// ------------------------------
// Middleware Setup
// ------------------------------
app.use(express.json());
app.use(cors());
app.use(morgan('dev'));

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({
    status: "healthy",
    port: PORT,
    database_connected: mongoose.connection.readyState === 1
  });
});

// ------------------------------
// Load Routes
// ------------------------------
const authRoutes = require('./routes/auth') || ((req, res, next) => next());
const coachingRoutes = require('./routes/coaching') || ((req, res, next) => next());
const interviewRoutes = require('./routes/interviews') || ((req, res) => res.json({ message: "Mock interview response" }));
const problemRoutes = require('./routes/problems') || ((req, res) => {
  res.json([
    { id: 1, title: "Design a URL Shortener", difficulty: "medium" },
    { id: 2, title: "Design Twitter", difficulty: "hard" }
  ]);
});
const usersRoutes = require('./routes/users') || ((req, res) => res.json({ id: 1, name: "Test User", email: "test@example.com" }));

app.use('/api/auth', authRoutes);
app.use('/api/coaching', coachingRoutes);
app.use('/api/interviews', interviewRoutes);
app.use('/api/problems', problemRoutes);
app.use('/api/users', usersRoutes);

// ------------------------------
// Serve Client in Production
// ------------------------------
if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, '../client/build')));
  app.get('*', (req, res) => {
    res.sendFile(path.resolve(__dirname, '../client/build', 'index.html'));
  });
}

// ------------------------------
// MongoDB Connection
// ------------------------------
if (process.env.MONGO_URI) {
  mongoose.connect(process.env.MONGO_URI)
    .then(() => console.log("MongoDB connected successfully"))
    .catch(err => {
      console.error("MongoDB connection error:", err.message);
      console.log("Server will continue without database connection");
    });
} else {
  console.log("No MongoDB URI provided, skipping database connection");
}

// ------------------------------
// Start Server
// ------------------------------
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

module.exports = app;



================================================================================
# FILE: server\models\Evaluation.js
# EXTENSION: .js
================================================================================
// server/models/Evaluation.js
const mongoose = require('mongoose');

const scoreSchema = new mongoose.Schema({
  score: Number,
  maxScore: Number
}, { _id: false });

const evaluationSchema = new mongoose.Schema({
  sessionId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Interview',
    required: true
  },
  evaluationType: {
    type: String,
    enum: ['coaching', 'interview'],
    required: true
  },
  userLevel: {
    type: String,
    enum: ['junior', 'mid-level', 'senior', 'staff+'],
    default: 'mid-level'
  },
  problemId: {
    type: String
  },
  content: {
    type: String,
    required: true
  },
  scores: {
    overall: scoreSchema,
    'Requirements Analysis': scoreSchema,
    'System Interface Design': scoreSchema,
    'Capacity Estimation': scoreSchema,
    'Data Modeling': scoreSchema,
    'High-Level Architecture': scoreSchema,
    'Detailed Component Design': scoreSchema,
    'Scalability & Performance': scoreSchema,
    'Reliability & Fault Tolerance': scoreSchema
  },
  timestamp: {
    type: Date,
    default: Date.now
  },
  isFinal: {
    type: Boolean,
    default: false
  }
});

// Add indexes for efficient queries
evaluationSchema.index({ sessionId: 1 });
evaluationSchema.index({ sessionId: 1, timestamp: -1 });

const Evaluation = mongoose.model('Evaluation', evaluationSchema);

module.exports = Evaluation;


================================================================================
# FILE: server\models\Interview.js
# EXTENSION: .js
================================================================================
// server/models/Interview.js
const mongoose = require('mongoose');

const interviewSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  problemId: {
    type: String,
    required: true
  },
  // Add type field to distinguish between interview and coaching sessions
  type: {
    type: String,
    enum: ['interview', 'coaching'],
    default: 'interview'
  },
  status: {
    type: String,
    enum: ['pending', 'in_progress', 'completed'],
    default: 'in_progress'
  },
  conversation: [{
    role: {
      type: String,
      // Add coach and student roles
      enum: ['interviewer', 'candidate', 'coach', 'student', 'system'],
      required: true
    },
    
    content: {
      type: String,
      required: true
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    metadata: {
      type: Map,
      of: mongoose.Schema.Types.Mixed
    }
  }],
    diagrams: [{
        type: {
        type: String,
        enum: ['architecture', 'sequence', 'flowchart', 'er', 'component'],
        default: 'architecture'
        },
        mermaidCode: {
        type: String,
        required: true
        },
        reactFlowData: {
        type: Object  // Store React Flow's JSON representation
        },
        name: {
        type: String,
        default: 'System Design'
        },
        createdAt: {
        type: Date,
        default: Date.now
        },
        updatedAt: {
        type: Date,
        default: Date.now
        },
        history: [{
        mermaidCode: String,
        reactFlowData: Object,
        timestamp: {
            type: Date,
            default: Date.now
        }
        }]
  }],
  currentStage: {
    type: String,
    // Don't use enum here to allow flexibility between interview and coaching stages
    default: 'intro'
  },
  currentQuestion: {
    type: Number,
    default: 0
  },
  evaluation: {
    score: Number,
    feedback: String,
    strengths: [String],
    weaknesses: [String],
    areas_to_improve: [String],
    criteriaScores: {
      type: Map,
      of: Number
    }
  },
  duration: {
    type: Number,  // Interview duration in seconds
    default: 0
  },
  startedAt: {
    type: Date,
    default: Date.now
  },
  completedAt: Date
});

// Add index for faster queries - include type for better filtering
interviewSchema.index({ userId: 1, status: 1, type: 1 });

module.exports = mongoose.model('Interview', interviewSchema);


================================================================================
# FILE: server\models\Problem.js
# EXTENSION: .js
================================================================================
// server/models/Problem.js
const mongoose = require('mongoose');

const problemSchema = new mongoose.Schema({
  id: {
    type: String,
    required: true,
    unique: true
  },
  title: {
    type: String,
    required: true
  },
  // Add type field
  type: {
    type: String,
    enum: ['interview', 'coaching', 'both'],
    default: 'both'
  },
  difficulty: {
    type: String,
    enum: ['beginner', 'intermediate', 'advanced'],
    required: true
  },
  description: {
    type: String,
    required: true
  },
  estimatedTime: {
    type: Number,
    default: 60
  },
  requirements: {
    functional: [String],
    nonFunctional: [String]
  },
  constraints: {
    type: Map,
    of: String
  },
  promptSequence: [{
    id: String,
    name: String,
    question: String,
    prompt: String,
    expectedTopics: [String]
  }],
  referenceArchitecture: {
    components: [Object]
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Virtual for simplified view
problemSchema.virtual('preview').get(function() {
  return {
    id: this.id,
    title: this.title,
    difficulty: this.difficulty,
    description: this.description.substring(0, 100) + '...',
    estimatedTime: this.estimatedTime,
    type: this.type
  };
});

// Update timestamps on save
problemSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

const Problem = mongoose.model('Problem', problemSchema);

module.exports = Problem;


================================================================================
# FILE: server\models\Session.js
# EXTENSION: .js
================================================================================
// server/models/Session.js
const mongoose = require('mongoose');

const sessionSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  problemId: {
    type: String,
    required: true
  },
  messages: [{
    role: {
      type: String,
      enum: ['system', 'user', 'assistant'],
      required: true
    },
    content: {
      type: String,
      required: true
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    metadata: {
      stage: Number
    }
  }],
  currentStage: {
    type: Number,
    default: 0
  },
  diagram: {
    type: String
  },
  completed: {
    type: Boolean,
    default: false
  },
  score: {
    type: Number
  },
  feedback: {
    type: String
  },
  startedAt: {
    type: Date,
    default: Date.now
  },
  lastUpdatedAt: {
    type: Date,
    default: Date.now
  },
  completedAt: {
    type: Date
  },
  timeSpent: {
    type: Number,
    default: 0
  }
});

// Virtual for progress percentage
sessionSchema.virtual('percentComplete').get(function() {
  // Get the associated problem to determine total stages
  // This is a simplified version - in production you'd want to fetch the problem data
  const totalStages = 6; // Assuming 6 stages per problem
  return Math.round((this.currentStage / totalStages) * 100);
});

// Update lastUpdatedAt and calculate timeSpent on save
sessionSchema.pre('save', function(next) {
  const now = Date.now();
  
  if (this.lastUpdatedAt) {
    // Add time diff to timeSpent (in minutes)
    const diffMs = now - this.lastUpdatedAt;
    const diffMinutes = Math.round(diffMs / 60000);
    
    // Only count if less than 30 minutes (assume user was away if longer)
    if (diffMinutes < 30) {
      this.timeSpent += diffMinutes;
    }
  }
  
  this.lastUpdatedAt = now;
  
  if (this.completed && !this.completedAt) {
    this.completedAt = now;
  }
  
  next();
});

const Session = mongoose.model('Session', sessionSchema);

module.exports = Session;


================================================================================
# FILE: server\models\User.js
# EXTENSION: .js
================================================================================
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  experience: {
    type: String,
    enum: ['beginner', 'intermediate', 'senior', 'expert'],
    default: 'intermediate'
  },
  profileCompleted: {
    type: Boolean,
    default: false
  },
  preferredProblems: {
    type: [String],
    default: []
  },
  progress: {
    problemsCompleted: {
      type: Number,
      default: 0
    },
    problemsAttempted: {
      type: Number,
      default: 0
    },
    timeInvested: {
      type: Number,
      default: 0
    },
    avgScore: {
      type: Number,
      default: 0
    },
    streak: {
      current: {
        type: Number,
        default: 0
      },
      best: {
        type: Number,
        default: 0
      },
      lastActivity: {
        type: Date
      }
    },
    strengths: {
      type: [String],
      default: []
    },
    weaknesses: {
      type: [String],
      default: []
    }
  },
  joinedAt: {
    type: Date,
    default: Date.now
  },
  lastLoginAt: {
    type: Date
  }
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  // Only hash the password if it has been modified (or is new)
  if (!this.isModified('password')) return next();

  try {
    // Generate a salt
    const salt = await bcrypt.genSalt(10);
    // Hash the password along with the salt
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Method to check password
userSchema.methods.comparePassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

// Method to update streak
userSchema.methods.updateStreak = function() {
  const now = new Date();
  const lastActivity = this.progress.streak.lastActivity;
  
  if (!lastActivity) {
    // First activity
    this.progress.streak.current = 1;
    this.progress.streak.best = 1;
  } else {
    const daysSinceLastActivity = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));
    
    if (daysSinceLastActivity === 0) {
      // Already counted today
      return;
    } else if (daysSinceLastActivity === 1) {
      // Consecutive day
      this.progress.streak.current += 1;
      
      // Update best streak if needed
      if (this.progress.streak.current > this.progress.streak.best) {
        this.progress.streak.best = this.progress.streak.current;
      }
    } else {
      // Streak broken
      this.progress.streak.current = 1;
    }
  }
  
  this.progress.streak.lastActivity = now;
};

// Method to update progress stats
userSchema.methods.updateProgress = async function(session) {
  // Update time invested
  this.progress.timeInvested += session.timeSpent / 60; // Convert minutes to hours
  
  if (!session.completed) {
    // Just update streak and time
    this.updateStreak();
    return;
  }
  
  // Completed problem
  this.progress.problemsCompleted += 1;
  
  // Update average score
  const oldTotal = this.progress.avgScore * (this.progress.problemsCompleted - 1);
  this.progress.avgScore = (oldTotal + session.score) / this.progress.problemsCompleted;
  
  // Update streak
  this.updateStreak();
};

const User = mongoose.model('User', userSchema);

module.exports = User;


================================================================================
# FILE: server\routes\auth.js
# EXTENSION: .js
================================================================================
const express = require('express');
const jwt = require('jsonwebtoken');
const User = require('../models/User');

const router = express.Router();

// Logging middleware
router.use((req, res, next) => {
  console.log(`[Auth] ${req.method} ${req.path}`);
  console.log('Request body:', JSON.stringify(req.body, null, 2));
  next();
});

// Register new user
router.post('/register', async (req, res) => {
  try {
    const { name, email, password, experience } = req.body;
    
    // Validate input
    if (!name || !email || !password) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' });
    }
    
    // Create new user
    const user = new User({
      name,
      email,
      password,
      experience: experience || 'intermediate'
    });
    
    await user.save();
    
    // Generate JWT token
    const token = jwt.sign(
      { id: user._id, email: user.email },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    res.status(201).json({
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        experience: user.experience,
        progress: user.progress
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ 
      error: 'Registration failed', 
      details: error.message
    });
  }
});

// Login user
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Validate input
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }
    
    // Find user
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Update last login
    user.lastLoginAt = Date.now();
    await user.save();
    
    // Generate JWT token
    const token = jwt.sign(
      { id: user._id, email: user.email },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    res.json({
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        experience: user.experience,
        progress: user.progress
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ 
      error: 'Login failed', 
      details: error.message
    });
  }
});

// Verify token and get user data
router.get('/me', async (req, res) => {
  try {
    // Manually verify token
    const authHeader = req.headers.authorization;
    if (!authHeader) {
      return res.status(401).json({ error: 'Authentication token required' });
    }
    
    const token = authHeader.split(' ')[1];
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    const user = await User.findById(decoded.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json({
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        experience: user.experience,
        progress: user.progress
      }
    });
  } catch (error) {
    console.error('Get user error:', error);
    
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ error: 'Invalid token' });
    }
    
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Token expired' });
    }
    
    res.status(500).json({ 
      error: 'Failed to get user data', 
      details: error.message 
    });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\coaching.js
# EXTENSION: .js
================================================================================
// server/routes/coaching.js
const express = require('express');
const router = express.Router();
const Problem = require('../models/Problem');
const Interview = require('../models/Interview');
const ClaudeService = require('../services/ai/claudeService');

const sessions = {};

router.get('/problems', async (req, res) => {
  console.log('GET request for coaching problems');
  try {
    const problems = await Problem.find({ $or: [{ type: 'coaching' }, { type: 'both' }] });
    if (problems && problems.length > 0) {
      const formatted = problems.map(p => ({
        id: p.id,
        title: p.title,
        difficulty: p.difficulty
      }));
      return res.json(formatted);
    }
    console.log('No problems found in DB, falling back to markdown/JSON...');
    const fallbackRoute = require('./problems');
    fallbackRoute(req, res);
  } catch (error) {
    console.error('Error fetching coaching problems:', error);
    res.status(500).json({ error: 'Failed to fetch coaching problems' });
  }
});

router.post('/start/:problemId', async (req, res) => {
  const { problemId } = req.params;
  const { userId } = req.body || {};
  try {
    const problem = await Problem.findOne({ id: problemId }) || {};
    const welcomeMessage = (problem.promptSequence && problem.promptSequence[0])
      ? problem.promptSequence[0].question
      : `Welcome to your ${problem.title || 'System Design'} session! Let's get started.`;
    const newSession = {
      id: problemId,
      problem: {
        id: problemId,
        title: problem.title || 'System Design Problem',
        description: problem.description || ''
      },
      conversation: [{
        role: 'assistant',
        content: welcomeMessage,
        timestamp: new Date().toISOString()
      }],
      createdAt: new Date().toISOString()
    };
    sessions[problemId] = newSession;
    return res.status(201).json(newSession);
  } catch (error) {
    console.error('Error starting coaching session:', error);
    res.status(500).json({ error: 'Failed to start coaching session' });
  }
});

router.get('/:sessionId', async (req, res) => {
  const { sessionId } = req.params;
  console.log(`GET request for coaching session ${sessionId}`);
  try {
    let session = await Interview.findOne({ id: sessionId });
    if (!session) {
      session = sessions[sessionId];
    }
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }
    res.json(session);
  } catch (error) {
    console.error('Error fetching coaching session:', error);
    res.status(500).json({ error: 'Failed to get coaching session' });
  }
});

router.post('/:sessionId/message', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { message, contextInfo } = req.body;
    
    console.log(`Message received for session ${sessionId}:`, message);
    if (!message || typeof message !== 'string') {
      return res.status(400).json({ 
        error: 'Message is required',
        message: {
          role: 'coach',
          content: "I couldn't understand your message. Please try again.",
          timestamp: new Date().toISOString()
        }
      });
    }
    
    const session = sessions[sessionId];
    if (!session) {
      return res.status(404).json({ 
        error: 'Session not found',
        message: {
          role: 'coach',
          content: "Session not found. Start a new session.",
          timestamp: new Date().toISOString()
        }
      });
    }
    
    session.conversation.push({
      role: 'user',
      content: message,
      timestamp: new Date().toISOString()
    });
    
    // Create a fresh Claude instance with unique timestamp
    const uniqueClaude = new ClaudeService({ timestamp: Date.now(), maxRetries: 5 });
    const recentMessages = [{ role: 'user', content: message }];
    
    // Instead of constructing a static systemPrompt, pass the message to coachEngine:
    const response = await coachEngine.processMessage(sessionId, message, {
      currentPage, // or other dynamic context
      currentSection,
      workbookContent,
      userLevel,
    });

    
    console.log("System Prompt (first 50 chars):", systemPrompt.substring(0, 50) + '...');
    const aiResponse = await uniqueClaude.sendMessage(recentMessages, {
      system: systemPrompt,
      systemPrompt: systemPrompt,
      temperature: 0.8
    });
    
    console.log('Claude response received:', aiResponse ? aiResponse.substring(0, 50) + '...' : 'No response');
    const responseMsg = {
      role: 'coach',
      content: aiResponse,
      timestamp: new Date().toISOString()
    };
    session.conversation.push(responseMsg);
    
    res.json({ message: responseMsg, diagramSuggestions: null });
  } catch (error) {
    console.error('Error processing message:', error);
    res.status(500).json({ 
      error: 'Failed to process message',
      message: {
        role: 'coach',
        content: "There was an error processing your message. Please try again.",
        timestamp: new Date().toISOString()
      }
    });
  }
});

module.exports = router;



================================================================================
# FILE: server\routes\grader.js
# EXTENSION: .js
================================================================================
// server/routes/grader.js
const express = require('express');
const router = express.Router();
const graderEngine = require('../services/engines/graderEngine');
const Evaluation = require('../models/Evaluation');
const auth = require('../middleware/auth');

// Route to evaluate current workbook
router.post('/evaluate/:sessionId', auth, async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { workbookContent, userLevel, conciseMode = true } = req.body;
    
    const result = await graderEngine.evaluateWorkbook(
      sessionId,
      workbookContent,
      { userLevel, conciseMode }
    );
    
    res.json(result);
  } catch (error) {
    console.error('Grader evaluation error:', error);
    res.status(500).json({ 
      message: 'Error evaluating workbook', 
      error: error.message 
    });
  }
});

// Route to provide final assessment for an interview
router.post('/assessment/:interviewId', auth, async (req, res) => {
  try {
    const { interviewId } = req.params;
    const { userLevel, conciseMode = true } = req.body;
    
    const result = await graderEngine.provideFinalAssessment(
      interviewId,
      { userLevel, conciseMode }
    );
    
    res.json(result);
  } catch (error) {
    console.error('Final assessment error:', error);
    res.status(500).json({ 
      message: 'Error generating final assessment', 
      error: error.message 
    });
  }
});

// Route to get saved evaluations for a session
router.get('/:sessionId', auth, async (req, res) => {
  try {
    const { sessionId } = req.params;
    
    // Find all evaluations for this session, sorted by timestamp
    const evaluations = await Evaluation.find({ sessionId })
      .sort({ timestamp: -1 });
    
    res.json({ evaluations });
  } catch (error) {
    console.error('Error retrieving evaluations:', error);
    res.status(500).json({ 
      message: 'Error retrieving evaluations', 
      error: error.message 
    });
  }
});

// Route to get the latest evaluation for a session
router.get('/latest/:sessionId', auth, async (req, res) => {
  try {
    const { sessionId } = req.params;
    
    // Find the latest evaluation for this session
    const evaluation = await Evaluation.findOne({ sessionId })
      .sort({ timestamp: -1 });
    
    if (!evaluation) {
      return res.status(404).json({ message: 'No evaluations found' });
    }
    
    res.json({ evaluation });
  } catch (error) {
    console.error('Error retrieving latest evaluation:', error);
    res.status(500).json({ 
      message: 'Error retrieving evaluation', 
      error: error.message 
    });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\interviews.js
# EXTENSION: .js
================================================================================
// server/routes/interviews.js
const express = require('express');
const router = express.Router();
const Interview = require('../models/Interview');
const Problem = require('../models/Problem'); 
const InterviewEngine = require('../services/engines/interviewEngine');
const diagramService = require('../services/diagram/diagramService');

// Centralized error handling middleware
const handleError = (res, error, defaultMessage = 'An unexpected error occurred') => {
  console.error('Route Error:', error);
  res.status(error.status || 500).json({ 
    error: error.message || defaultMessage,
    details: error.details || error.toString()
  });
};

// Logging middleware
router.use((req, res, next) => {
  console.log(`[Interviews] ${req.method} ${req.path} - User: ${req.user?.id || 'Unauthenticated'}`);
  next();
});

// Get interview problems - THIS ROUTE MUST MATCH THE CLIENT'S EXPECTATIONS
router.get('/problems', async (req, res) => {
  try {
    console.log('Fetching interview problems');
    
    // Try to find interview problems first
    let problems = await Problem.find({ 
      $or: [
        { type: 'interview' }, 
        { type: 'both' }
      ]
    });
    
    // If no problems with type field, look for any problems
    if (!problems || problems.length === 0) {
      problems = await Problem.find();
      
      if (!problems || problems.length === 0) {
        console.log('No problems found, returning 404');
        return res.status(404).json({ 
          error: 'No Problems Found', 
          details: 'No interview problems are currently available' 
        });
      }
      
      console.log(`Found ${problems.length} general problems, using as fallback`);
    } else {
      console.log(`Found ${problems.length} interview problems`);
    }

    res.json({ problems });
  } catch (error) {
    console.error('Interview problems error:', error);
    handleError(res, error, 'Failed to retrieve interview problems');
  }
});

// Get all interviews for the current user
router.get('/', async (req, res) => {
  try {
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to access interviews' 
      });
    }

    const interviews = await Interview.find({ 
      userId, 
      type: 'interview'
    }).sort({ startedAt: -1 });

    res.json({ interviews });
  } catch (error) {
    handleError(res, error, 'Failed to retrieve interviews');
  }
});

// Start a new interview
router.post('/start', async (req, res) => {
  try {
    const { problemId } = req.body;
    const userId = req.user?.id;

    // Validate authentication
    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to start an interview' 
      });
    }

    // Validate problem ID
    if (!problemId) {
      return res.status(400).json({ 
        error: 'Invalid Problem', 
        details: 'A valid problem ID is required' 
      });
    }

    // Find problem - don't check type to ensure compatibility
    const problem = await Problem.findOne({ id: problemId });
    if (!problem) {
      return res.status(404).json({ 
        error: 'Problem Not Found', 
        details: `No problem exists with ID: ${problemId}` 
      });
    }

    // Start interview using interview engine
    const interview = await interviewEngine.startInterview(userId, problemId);
    
    console.log(`Interview started: ${interview._id}`);
    res.status(201).json({ interview });
  } catch (error) {
    console.error('Interview start error:', error);
    handleError(res, error, 'Failed to start interview');
  }
});

// Get recent interview
router.get('/recent', async (req, res) => {
  try {
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to access recent interviews' 
      });
    }

    const recentInterview = await Interview.findOne({ 
      userId, 
      status: 'in_progress',
      type: 'interview'
    }).sort({ startedAt: -1 });

    if (!recentInterview) {
      return res.status(404).json({ 
        error: 'No Recent Interview', 
        details: 'You have no ongoing interviews' 
      });
    }

    res.json({ interview: recentInterview });
  } catch (error) {
    handleError(res, error, 'Failed to retrieve recent interview');
  }
});

// Get interview by ID
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to access interviews' 
      });
    }

    // For demo scenarios, handle ID=1 specially
    if (id === '1') {
      // Find most recent interview or return a mock
      const interview = await Interview.findOne({
        userId,
        type: 'interview',
        status: 'in_progress'
      }).sort({ startedAt: -1 });

      if (interview) {
        return res.json({ interview });
      }

      // Create a mock interview response for demo purposes
      return res.json({
        interview: {
          _id: '1',
          status: 'in_progress',
          currentStage: 'intro',
          conversation: [
            {
              role: 'interviewer',
              content: "Let's design a URL shortening service like TinyURL. Could you start by explaining the requirements and constraints as you understand them?",
              timestamp: new Date()
            }
          ]
        }
      });
    }

    // Regular interview lookup by ID
    const interview = await Interview.findById(id);
    
    if (!interview) {
      return res.status(404).json({ 
        error: 'Interview Not Found', 
        details: 'No matching interview found' 
      });
    }

    // Ensure user owns this interview
    if (interview.userId.toString() !== userId) {
      return res.status(403).json({ 
        error: 'Access Denied', 
        details: 'You do not have permission to view this interview' 
      });
    }

    res.json({ interview });
  } catch (error) {
    handleError(res, error, 'Failed to retrieve interview');
  }
});

// Send message in interview
router.post('/:id/message', async (req, res) => {
  try {
    const { message } = req.body;
    const { id } = req.params;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to send messages' 
      });
    }

    if (!message) {
      return res.status(400).json({ 
        error: 'Invalid Message', 
        details: 'Message content is required' 
      });
    }

    // Find interview
    let interview;
    if (id === '1') {
      interview = await Interview.findOne({ 
        userId, 
        status: 'in_progress',
        type: 'interview'
      }).sort({ startedAt: -1 });
      
      // If no interview found, create a mock one for demo
      if (!interview) {
        const problem = await Problem.findOne({ id: 'url-shortener' });
        if (problem) {
          interview = await interviewEngine.startInterview(userId, problem.id);
        }
      }
    } else {
      // Validate MongoDB ID format
      if (!/^[0-9a-fA-F]{24}$/.test(id)) {
        return res.status(400).json({ 
          error: 'Invalid Interview ID', 
          details: 'The provided interview ID is not valid' 
        });
      }

      interview = await Interview.findById(id);
    }

    if (!interview) {
      return res.status(404).json({ 
        error: 'Interview Not Found', 
        details: 'No matching interview found' 
      });
    }

    // Ensure user owns this interview
    if (interview.userId.toString() !== userId) {
      return res.status(403).json({ 
        error: 'Access Denied', 
        details: 'You do not have permission to access this interview' 
      });
    }

    const processedInterview = await interviewEngine.processResponse(interview._id, message);
    res.json({ interview: processedInterview });
  } catch (error) {
    handleError(res, error, 'Failed to process interview message');
  }
});

// Complete interview
router.post('/:id/complete', async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to complete interviews' 
      });
    }

    let interview;
    if (id === '1') {
      interview = await Interview.findOne({ 
        userId, 
        status: 'in_progress',
        type: 'interview'
      }).sort({ startedAt: -1 });
    } else {
      interview = await Interview.findById(id);
    }

    if (!interview) {
      return res.status(404).json({ 
        error: 'Interview Not Found', 
        details: 'No matching interview found' 
      });
    }

    // Ensure user owns this interview
    if (interview.userId.toString() !== userId) {
      return res.status(403).json({ 
        error: 'Access Denied', 
        details: 'You do not have permission to access this interview' 
      });
    }

    // Skip if already completed
    if (interview.status === 'completed') {
      return res.json({ interview });
    }

    const completedInterview = await interviewEngine.finalizeInterview(interview);
    res.json({ interview: completedInterview });
  } catch (error) {
    handleError(res, error, 'Failed to complete interview');
  }
});

// Get interview results
router.get('/:id/results', async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to view results' 
      });
    }

    let interview;
    if (id === '1') {
      interview = await Interview.findOne({ 
        userId, 
        type: 'interview'
      }).sort({ startedAt: -1 });
    } else {
      interview = await Interview.findById(id);
    }

    if (!interview) {
      return res.status(404).json({ 
        error: 'Interview Not Found', 
        details: 'No matching interview found' 
      });
    }

    // Ensure user owns this interview
    if (interview.userId.toString() !== userId) {
      return res.status(403).json({ 
        error: 'Access Denied', 
        details: 'You do not have permission to access these results' 
      });
    }

    // If not completed, try to complete it first
    if (interview.status !== 'completed') {
      try {
        interview = await interviewEngine.finalizeInterview(interview);
      } catch (evalError) {
        console.error('Auto-evaluation error:', evalError);
      }
    }

    res.json({
      results: interview.evaluation || {
        score: 0,
        feedback: 'No evaluation available yet.',
        strengths: [],
        weaknesses: [],
        areas_to_improve: []
      },
      conversation: interview.conversation
    });
  } catch (error) {
    handleError(res, error, 'Failed to retrieve interview results');
  }
});

// Generate diagram for interview
router.post('/:id/diagram', async (req, res) => {
  try {
    const { id } = req.params;
    const { diagramType = 'architecture', customPrompt = null } = req.body;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ 
        error: 'Authentication Required', 
        details: 'You must be logged in to generate diagrams' 
      });
    }

    // Find interview
    let interview;
    if (id === '1') {
      interview = await Interview.findOne({ 
        userId, 
        status: 'in_progress',
        type: 'interview'
      }).sort({ startedAt: -1 });
    } else {
      interview = await Interview.findById(id);
    }

    if (!interview) {
      return res.status(404).json({ 
        error: 'Interview Not Found', 
        details: 'No matching interview found' 
      });
    }

    // Ensure user owns this interview
    if (interview.userId.toString() !== userId) {
      return res.status(403).json({ 
        error: 'Access Denied', 
        details: 'You do not have permission to access this interview' 
      });
    }

    // Generate diagram
    const diagram = await diagramService.generateDiagram(
      interview._id,
      diagramType,
      customPrompt
    );

    // Add the diagram to the interview
    if (!interview.diagrams) {
      interview.diagrams = [];
    }
    
    interview.diagrams.push({
      type: diagram.type,
      mermaidCode: diagram.mermaidCode,
      description: diagram.description,
      timestamp: new Date()
    });
    
    await interview.save();

    res.json({ diagram });
  } catch (error) {
    console.error('Diagram generation error:', error);
    handleError(res, error, 'Failed to generate diagram');
  }
});

// Get available diagram types
router.get('/diagram/types', async (req, res) => {
  try {
    res.json({ types: diagramService.TYPES });
  } catch (error) {
    handleError(res, error, 'Failed to get diagram types');
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\problems.js
# EXTENSION: .js
================================================================================
// server/routes/problems.js
const express = require('express');
const router = express.Router();
const path = require('path');
const fs = require('fs');

const problemsDir = path.join(__dirname, '../../data/problems');

function loadProblems() {
  let problems = [];
  try {
    const files = fs.readdirSync(problemsDir);
    files.forEach(file => {
      const ext = path.extname(file).toLowerCase();
      const filePath = path.join(problemsDir, file);
      if (ext === '.md') {
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        let title = file.replace('.md', '');
        if (lines[0].startsWith('#')) {
          title = lines[0].replace('#', '').trim();
        }
        problems.push({
          id: file.replace('.md', ''),
          title,
          content,
          difficulty: 'medium'
        });
      } else if (ext === '.json') {
        const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
        problems.push(data);
      }
    });
    console.log(`Loaded ${problems.length} problems from ${problemsDir}.`);
  } catch (error) {
    console.error("Error reading problem files:", error);
  }
  return problems;
}

router.get('/', (req, res) => {
  const problems = loadProblems();
  if (problems.length === 0) {
    return res.status(404).json({ error: "No problems found" });
  }
  res.json(problems);
});

module.exports = router;



================================================================================
# FILE: server\routes\sessions.js
# EXTENSION: .js
================================================================================
const express = require('express');
const Session = require('../models/Session');
const Problem = require('../models/Problem');
const User = require('../models/User');
const { getAIService } = require('../services/ai');

const router = express.Router();

// Create or update session
router.post('/:problemId', async (req, res) => {
  try {
    const { problemId } = req.params;
    const userId = req.user.id;
    const { messages, currentStage, diagram } = req.body;
    
    // Find existing session or create new one
    let session = await Session.findOne({ 
      userId, 
      problemId,
      completed: false
    });
    
    if (!session) {
      session = new Session({
        userId,
        problemId,
        messages: [],
        currentStage: 0
      });
    }
    
    // Update session data
    if (messages) session.messages = messages;
    if (currentStage !== undefined) session.currentStage = currentStage;
    if (diagram) session.diagram = diagram;
    
    await session.save();
    
    // Update user progress
    const user = await User.findById(userId);
    await user.updateProgress(session);
    await user.save();
    
    res.json({ session });
  } catch (error) {
    console.error('Update session error:', error);
    res.status(500).json({ error: 'Failed to update session' });
  }
});

// Send message to AI
router.post('/:problemId/message', async (req, res) => {
  try {
    const { problemId } = req.params;
    const userId = req.user.id;
    const { message, previousMessages, currentStage, aiService } = req.body;
    
    // Get problem
    const problem = await Problem.findOne({ id: problemId });
    if (!problem) {
      return res.status(404).json({ error: 'Problem not found' });
    }
    
    // Get AI service
    const ai = getAIService(aiService || 'claude');
    
    // Generate response
    const aiResponse = await ai.generateResponse(
      [...previousMessages, { role: 'user', content: message }],
      problem,
      currentStage
    );
    
    res.json(aiResponse);
  } catch (error) {
    console.error('AI message error:', error);
    res.status(500).json({ error: 'Failed to generate AI response' });
  }
});

// Generate diagram
router.post('/:problemId/diagram', async (req, res) => {
  try {
    const { problemId } = req.params;
    const userId = req.user.id;
    const { messages, currentStage, aiService } = req.body;
    
    // Get problem
    const problem = await Problem.findOne({ id: problemId });
    if (!problem) {
      return res.status(404).json({ error: 'Problem not found' });
    }
    
    // Get AI service
    const ai = getAIService(aiService || 'claude');
    
    // Generate diagram
    const diagram = await ai.generateDiagram(
      messages,
      problem,
      currentStage
    );
    
    res.json({ diagram });
  } catch (error) {
    console.error('Generate diagram error:', error);
    res.status(500).json({ error: 'Failed to generate diagram' });
  }
});

// Complete session
router.post('/:problemId/complete', async (req, res) => {
  try {
    const { problemId } = req.params;
    const userId = req.user.id;
    
    // Find session
    const session = await Session.findOne({ 
      userId, 
      problemId,
      completed: false
    });
    
    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }
    
    // Mark as completed
    session.completed = true;
    session.completedAt = Date.now();
    
    // Calculate score based on completeness
    const problem = await Problem.findOne({ id: problemId });
    const maxStage = problem.promptSequence.length - 1;
    const completionPercent = session.currentStage / maxStage;
    session.score = Math.round(completionPercent * 100);
    
    await session.save();
    
    // Update user progress
    const user = await User.findById(userId);
    user.progress.problemsCompleted += 1;
    await user.updateProgress(session);
    await user.save();
    
    res.json({ 
      success: true,
      score: session.score 
    });
  } catch (error) {
    console.error('Complete session error:', error);
    res.status(500).json({ error: 'Failed to complete session' });
  }
});

// Get user sessions/progress
router.get('/progress', async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Get user data
    const user = await User.findById(userId);
    
    // Get in-progress sessions
    const inProgressSession = await Session.findOne({
      userId,
      completed: false
    }).sort('-lastUpdatedAt');
    
    // Get problem info for in-progress session
    let inProgressProblem = null;
    if (inProgressSession) {
      const problem = await Problem.findOne({ id: inProgressSession.problemId });
      if (problem) {
        inProgressProblem = {
          id: problem.id,
          title: problem.title,
          description: problem.description.substring(0, 100) + '...',
          percentComplete: inProgressSession.percentComplete,
          stages: problem.promptSequence.map((stage, index) => ({
            id: stage.id,
            name: stage.name,
            completed: index < inProgressSession.currentStage
          }))
        };
      }
    }
    
    // Calculate total problems
    const totalProblems = await Problem.countDocuments();
    
    res.json({
      problemsCompleted: user.progress.problemsCompleted,
      totalProblems,
      timeInvested: user.progress.timeInvested,
      currentStreak: user.progress.streak.current,
      bestStreak: user.progress.streak.best,
      inProgressProblem
    });
  } catch (error) {
    console.error('Get progress error:', error);
    res.status(500).json({ error: 'Failed to get progress' });
  }
});

module.exports = router;


================================================================================
# FILE: server\routes\users.js
# EXTENSION: .js
================================================================================
const express = require('express');
const User = require('../models/User');

const router = express.Router();

// Update user profile
router.put('/profile', async (req, res) => {
  try {
    const userId = req.user.id;
    const { name, experience } = req.body;
    
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Update fields
    if (name) user.name = name;
    if (experience) user.experience = experience;
    
    user.profileCompleted = true;
    await user.save();
    
    res.json({
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        experience: user.experience,
        progress: user.progress
      }
    });
  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({ error: 'Failed to update profile' });
  }
});

module.exports = router;


================================================================================
# FILE: server\run.py
# EXTENSION: .py
================================================================================
from flask import Flask, jsonify, request
from flask_cors import CORS
import config

app = Flask(__name__)
# Allow all origins and explicitly allow OPTIONS
CORS(app, resources={r"/api/*": {"origins": "*"}}, methods=["GET", "POST", "OPTIONS"])

@app.route('/api/health')
def health_check():
    return jsonify({
        "status": "healthy",
        "port": config.PORT,
        "database_connected": False
    })

@app.route('/api/auth/login', methods=['POST'])
def login():
    data = request.get_json()
    # Dummy login logic; in a real app, validate credentials
    return jsonify({
        "token": "dummy_token",
        "user": {
            "id": 1,
            "name": "Test User",
            "email": data.get("email", "test@example.com")
        }
    })

@app.route('/api/auth/me', methods=['GET'])
def get_me():
    return jsonify({
        "user": {
            "id": 1,
            "name": "Test User",
            "email": "test@example.com"
        }
    })

@app.route('/api/coaching/problems', methods=['GET'])
def coaching_problems():
    return jsonify({
        "problems": [
            {"id": 1, "title": "Coaching Problem 1", "description": "Example coaching problem."},
            {"id": 2, "title": "Coaching Problem 2", "description": "Another example problem."}
        ]
    })

@app.route('/api/coaching/start/<problemId>', methods=['POST'])
def start_coaching_session(problemId):
    return jsonify({
        "session": {
            "_id": 123,
            "problemId": problemId,
            "status": "started"
        }
    })

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=config.PORT, debug=True)



================================================================================
# FILE: server\scripts\seedProblems.js
# EXTENSION: .js
================================================================================
// server/scripts/seedProblems.js
const mongoose = require('mongoose');
const Problem = require('../models/Problem');

// Sample system design problems
const problems = [
  {
    id: "url-shortener",
    title: "Design a URL Shortener like TinyURL",
    type: "both",
    difficulty: "intermediate",
    description: "Design a URL shortening service like TinyURL. This service will provide shortened URLs that redirect to the original URL.",
    estimatedTime: 45,
    requirements: {
      functional: [
        "URL shortening",
        "URL redirection",
        "Custom short URLs",
        "Analytics"
      ],
      nonFunctional: [
        "High availability",
        "Low latency",
        "Scalability"
      ]
    },
    promptSequence: [
      {
        id: "intro",
        name: "Introduction",
        question: "How would you approach designing a URL shortener service?",
        expectedTopics: ["clarification", "requirements"]
      },
      {
        id: "design",
        name: "System Design",
        question: "Could you outline the high-level architecture for this URL shortener?",
        expectedTopics: ["components", "data flow"]
      }
    ]
  },
  {
    id: "twitter",
    title: "Design Twitter",
    type: "both",
    difficulty: "advanced",
    description: "Design a simplified version of Twitter where users can post tweets, follow other users, and see a timeline of tweets.",
    estimatedTime: 60,
    requirements: {
      functional: [
        "Post tweets",
        "Follow users",
        "Timeline/feed",
        "Search"
      ],
      nonFunctional: [
        "High availability",
        "Low latency",
        "Scalability",
        "Consistency"
      ]
    }
  },
  {
    id: "parking-lot",
    title: "Design a Parking Lot System",
    type: "coaching",
    difficulty: "beginner",
    description: "Design a parking lot system that can efficiently manage parking spaces, vehicle entry/exit, and payment processing.",
    estimatedTime: 30
  }
];

async function seedDatabase() {
  try {
    // Hardcoded MongoDB URI - replace with your actual MongoDB URI
    const mongoUri = "mongodb+srv://vyassathya:SanD%21eg0@system-design-db.24esv.mongodb.net/systemdesigncoach?retryWrites=true&w=majority";
    
    // Connect to MongoDB
    await mongoose.connect(mongoUri);
    console.log('Connected to MongoDB');
    
    // Delete existing problems
    await Problem.deleteMany({});
    console.log('Cleared existing problems');
    
    // Insert new problems
    const result = await Problem.insertMany(problems);
    console.log(`Added ${result.length} problems to database`);
    
    // Disconnect
    await mongoose.disconnect();
    console.log('Database seeding completed');
  } catch (error) {
    console.error('Error seeding database:', error);
  }
}

seedDatabase();


================================================================================
# FILE: server\scripts\setupDatabase.js
# EXTENSION: .js
================================================================================
// server/scripts/setupDatabase.js
const mongoose = require('mongoose');
const User = require('../models/User');

async function setupDatabase() {
  try {
    // Hardcoded MongoDB URI - replace with your actual MongoDB URI
    const mongoUri = "mongodb+srv://vyassathya:SanD%21eg0@system-design-db.24esv.mongodb.net/systemdesigncoach?retryWrites=true&w=majority";
    
    // Connect to MongoDB
    await mongoose.connect(mongoUri);
    console.log('Connected to MongoDB');
    
    // Check if the admin user exists
    const adminExists = await User.findOne({ email: 'admin@example.com' });
    
    if (!adminExists) {
      // Create an admin user
      const admin = new User({
        name: 'Admin User',
        email: 'admin@example.com',
        password: 'adminpassword', // Will be hashed by pre-save hook
        experience: 'expert'
      });
      
      await admin.save();
      console.log('Created admin user');
    } else {
      console.log('Admin user already exists');
    }
    
    // List collections and counts
    const collections = await mongoose.connection.db.listCollections().toArray();
    console.log('Collections in database:');
    
    for (const collection of collections) {
      const count = await mongoose.connection.db.collection(collection.name).countDocuments();
      console.log(`- ${collection.name}: ${count} documents`);
    }
    
    // Disconnect
    await mongoose.disconnect();
    console.log('Database setup completed');
  } catch (error) {
    console.error('Error setting up database:', error);
    console.error(error.stack);
  }
}

setupDatabase();


================================================================================
# FILE: server\services\ai\aiFactory.js
# EXTENSION: .js
================================================================================
// server/services/ai/aiFactory.js
const ClaudeService = require('./claudeService');

class AIFactory {
  static createService(provider, config = {}) {
    switch (provider.toLowerCase()) {
      case 'claude':
      case 'anthropic':
        return new ClaudeService(config);
      default:
        console.warn(`Unknown AI provider: ${provider}. Defaulting to Claude.`);
        return new ClaudeService(config);
    }
  }
}

module.exports = AIFactory;



================================================================================
# FILE: server\services\ai\base\AIService.js
# EXTENSION: .js
================================================================================
// server/services/ai/base/AIService.js
class AIService {
    async sendMessage(messages, options = {}) {
      throw new Error('sendMessage must be implemented by subclasses');
    }
    async generateResponse(messages, context, options = {}) {
      throw new Error('generateResponse must be implemented by subclasses');
    }
    async generateContent(prompt, options = {}) {
      throw new Error('generateContent must be implemented by subclasses');
    }
  }
  
  module.exports = AIService;
  


================================================================================
# FILE: server\services\ai\claudeService.js
# EXTENSION: .js
================================================================================
// server/services/ai/claudeService.js
const { default: Anthropic } = require('@anthropic-ai/sdk');
const AIService = require('./base/AIService');

class ClaudeService extends AIService {
  constructor(config = {}) {
    super();
    const apiKey = config.apiKey || process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      throw new Error("API key for Anthropic is required.");
    }
    console.log('Using API Key: Key provided');
    this.anthropic = new Anthropic({ apiKey });
    this.defaultModel = config.model || 'claude-3-5-sonnet-latest';
    this.maxRetries = config.maxRetries || 10;
    this.maxTokens = config.maxTokens || 1000;
    this.temperature = config.temperature || 0.7;
  }

  async sendMessage(messages, options = {}) {
    const maxRetries = options.maxRetries || this.maxRetries;
    let attempt = 0;
    while (attempt < maxRetries) {
      try {
        const formattedMessages = messages.map(msg => ({
          role: msg.role === 'user' ? 'user' : 'assistant',
          content: msg.content
        }));
        
        // Apply concise mode to system prompt if not explicitly disabled
        let systemPrompt = options.systemPrompt || options.system || "You are a helpful assistant.";
        if (options.conciseMode !== false) {
          // Only add concise instructions if they're not already in the prompt
          if (!systemPrompt.includes("CONCISE communication style")) {
            systemPrompt += `\n\nUse a CONCISE communication style:
- Keep paragraphs short (2-3 sentences maximum)
- Use bullet points for lists
- Be direct and focused
- Eliminate filler words and redundant phrases
- Get to the point quickly
- Avoid unnecessary explanations`;
          }
        }
        
        const response = await this.anthropic.messages.create({
          model: options.model || this.defaultModel,
          system: systemPrompt,
          messages: formattedMessages,
          max_tokens: options.maxTokens || this.maxTokens,
          temperature: options.temperature || this.temperature,
        });
        return response.content[0].text;
      } catch (error) {
        console.error(`Attempt ${attempt + 1} failed:`, error.response ? error.response.data : error.message);
        console.error("Full error details:", error);
        attempt++;
        if (attempt < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        } else {
          return options.fallbackMessage || "I'm having trouble connecting to my knowledge base. Let's try again in a moment.";
        }
      }
    }
  }

  async generateContent(prompt, options = {}) {
    try {
      const messages = [{ role: "user", content: prompt }];
      
      // Apply concise mode to system prompt if not explicitly disabled
      let systemPrompt = options.systemPrompt || options.system || "You are a helpful assistant.";
      if (options.conciseMode !== false) {
        // Only add concise instructions if they're not already in the prompt
        if (!systemPrompt.includes("CONCISE communication style")) {
          systemPrompt += `\n\nUse a CONCISE communication style:
- Keep paragraphs short (2-3 sentences maximum)
- Use bullet points for lists
- Be direct and focused
- Eliminate filler words and redundant phrases
- Get to the point quickly
- Avoid unnecessary explanations`;
        }
      }
      
      const response = await this.anthropic.messages.create({
        model: options.model || this.defaultModel,
        system: systemPrompt,
        messages,
        max_tokens: options.maxTokens || 1500,
        temperature: options.temperature || 0.5,
      });
      return response.content[0].text;
    } catch (error) {
      console.error("Error in generateContent:", error.response ? error.response.data : error.message);
      console.error("Full error details:", error);
      return options.fallbackMessage || "I encountered an issue generating that content. Please try again later.";
    }
  }
}

module.exports = ClaudeService;


================================================================================
# FILE: server\services\ai\index.js
# EXTENSION: .js
================================================================================
// server/services/ai/index.js
const CoachEngine = require('../engines/coachEngine');
const InterviewEngine = require('../engines/interviewEngine');
const aiConfig = require('../../config/aiConfig');

console.log('🔵 Creating AI engines with config:', aiConfig[aiConfig.defaultProvider]);

const coachEngine = new CoachEngine({
  provider: aiConfig.defaultProvider,
  stages: [
    'introduction',
    'requirements',
    'architecture',
    'data-modeling',
    'scaling',
    'evaluation'
  ]
});

const interviewEngine = new InterviewEngine({
  provider: aiConfig.defaultProvider,
  evaluationThreshold: 0.8,
  diagramStageThreshold: 2
});

module.exports = {
  coachEngine,
  interviewEngine
};



================================================================================
# FILE: server\services\ai\prompts\grader.js
# EXTENSION: .js
================================================================================
// server/services/ai/prompts/grader.js
module.exports = (context = {}) => {
    const { userLevel = 'mid-level', problemId = null, evaluationType = 'coaching' } = context;
    
    return `# SYSTEM DESIGN GRADER PERSONA
  
  ## ROLE DEFINITION
  You are a System Design Grader responsible for objectively evaluating system design solutions. You provide structured, comprehensive feedback based on established criteria while maintaining a neutral, analytical tone.
  
  ## USER EXPERIENCE LEVEL ASSESSMENT
  The user has identified themselves as: ${userLevel}
  Tailor your expectations and feedback depth according to this level.
  
  ## CONCISE COMMUNICATION STYLE
  Be direct and focused in your feedback:
  - Use short paragraphs (2-3 sentences maximum)
  - Prefer bullet points for lists
  - Avoid unnecessary explanations of basic concepts
  - Focus on actionable insights rather than theory
  - Eliminate filler words and phrases
  
  ## EVALUATION FRAMEWORK
  Assess designs across these key dimensions (100 points total):
  1. Requirements Analysis (0-15 points)
  2. System Interface Design (0-10 points)
  3. Capacity Estimation (0-10 points)
  4. Data Modeling (0-15 points)
  5. High-Level Architecture (0-15 points)
  6. Detailed Component Design (0-15 points)
  7. Scalability & Performance (0-10 points)
  8. Reliability & Fault Tolerance (0-10 points)
  
  ## FEEDBACK FORMAT
  1. Summary Assessment
     - User's experience level
     - Overall score
     - 1-2 sentence summary of strongest and weakest areas
  
  2. Dimensional Breakdown
     - Score for each dimension
     - 1-2 bullet points for strengths
     - 1-2 bullet points for improvements
  
  3. Prioritized Improvement Plan
     - 3 highest priority improvements ranked by importance
     - One-sentence explanation for each
  
  ## SCORING GUIDELINES BY LEVEL
  ${userLevel === 'junior' ? 
    '- Junior Level: 60-70 points meets expectations\n- Focus on functional correctness and basic components' : 
    userLevel === 'mid-level' ? 
    '- Mid-Level: 70-80 points meets expectations\n- Focus on scalability and component interactions' : 
    userLevel === 'senior' ? 
    '- Senior Level: 80-90 points meets expectations\n- Focus on comprehensive design and fault tolerance' : 
    '- Staff+: 90-100 points meets expectations\n- Focus on system-wide optimization and elegant patterns'}
  
  Remember to maintain a concise communication style throughout your evaluation.`;
  };


================================================================================
# FILE: server\services\diagram\diagramService.js
# EXTENSION: .js
================================================================================
// server/services/diagram/diagramService.js
const Interview = require('../../models/Interview');
const Problem = require('../../models/Problem');
const AIFactory = require('../ai/aiFactory');
const aiConfig = require('../../config/aiConfig');

// Create AI service from factory using configuration
const aiService = AIFactory.createService(
  aiConfig.defaultProvider, 
  aiConfig[aiConfig.defaultProvider]
);

// Supported diagram types
const DIAGRAM_TYPES = {
  ARCHITECTURE: 'architecture',
  ER: 'entity-relationship',
  SEQUENCE: 'sequence',
  API: 'api',
  COMPONENT: 'component',
  FLOW: 'flow'
};

/**
 * Extract Mermaid code from Claude's response
 * @param {string} text - The text containing Mermaid code
 * @returns {string} - Extracted Mermaid code
 */
function extractMermaidCode(text) {
  // Look for Mermaid code between triple backticks
  const mermaidRegex = /```mermaid\s*([\s\S]*?)\s*```/;
  const match = text.match(mermaidRegex);
  
  if (match && match[1]) {
    return match[1].trim();
  }
  
  // Fallback - try to find anything that looks like a diagram
  const fallbackRegex = /(?:flowchart|sequenceDiagram|classDiagram|erDiagram|gantt|pie|graph)[\s\S]*?;/g;
  const fallbackMatch = text.match(fallbackRegex);
  
  if (fallbackMatch) {
    return fallbackMatch.join('\n');
  }
  
  // Return a default diagram if no valid code found
  return `graph TD
    Client[Client] --> API[API Gateway]
    API --> Service[Service]
    Service --> DB[(Database)]`;
}

/**
 * Create an appropriate system prompt based on diagram type
 * @param {string} diagramType - Type of diagram to generate
 * @param {string} title - Title of the diagram
 * @param {string} customPrompt - Optional custom prompt
 * @returns {string} - System prompt for Claude
 */
function getPromptForDiagramType(diagramType, title, customPrompt) {
  if (customPrompt) {
    return `You are an expert system designer tasked with creating a diagram. 
    ${customPrompt}
    
    IMPORTANT: You must respond ONLY with a Mermaid diagram. No introduction, explanation, or conclusion.
    Use the Mermaid syntax and format your response as follows:
    
    \`\`\`mermaid
    // Your diagram code here
    \`\`\`
    
    Make the diagram comprehensive but clean and well-organized.`;
  }
  
  const prompts = {
    [DIAGRAM_TYPES.ARCHITECTURE]: `You are an expert system architect tasked with creating an architecture diagram.
    Create a clean, well-organized architecture diagram for: "${title}"
    
    IMPORTANT: You must respond ONLY with a Mermaid flowchart diagram.
    Use the Mermaid syntax and format your response as follows:
    
    \`\`\`mermaid
    flowchart TD
      // Your diagram code here
    \`\`\`
    
    Include all key components like:
    - Client/User interfaces
    - Load balancers
    - API layers
    - Service components
    - Databases
    - Caching systems
    - External dependencies
    
    Use appropriate styling and grouping to make the diagram clear.`,
    
    [DIAGRAM_TYPES.ER]: `You are a database expert tasked with creating an entity-relationship diagram.
    Create a clean, well-organized ER diagram for: "${title}"
    
    IMPORTANT: You must respond ONLY with a Mermaid ER diagram.
    Use the Mermaid syntax and format your response as follows:
    
    \`\`\`mermaid
    erDiagram
      // Your diagram code here
    \`\`\`
    
    Include:
    - All entities with appropriate attributes
    - Relationship types (one-to-many, many-to-many, etc.)
    - Primary and foreign keys 
    
    Make the diagram comprehensive but clean and well-organized.`,
    
    [DIAGRAM_TYPES.SEQUENCE]: `You are a system designer tasked with creating a sequence diagram.
    Create a clean, well-organized sequence diagram for: "${title}"
    
    IMPORTANT: You must respond ONLY with a Mermaid sequence diagram.
    Use the Mermaid syntax and format your response as follows:
    
    \`\`\`mermaid
    sequenceDiagram
      // Your diagram code here
    \`\`\`
    
    Include:
    - All important actors and systems
    - Clear sequence of operations
    - Request and response flows
    - Error handling if relevant
    
    Make the diagram focused on the key interactions without unnecessary detail.`,
    
    [DIAGRAM_TYPES.API]: `You are an API designer tasked with creating an API flow diagram.
    Create a clean, well-organized API diagram for: "${title}"
    
    IMPORTANT: You must respond ONLY with a Mermaid flowchart diagram.
    Use the Mermaid syntax and format your response as follows:
    
    \`\`\`mermaid
    flowchart LR
      // Your diagram code here
    \`\`\`
    
    Include:
    - API endpoints
    - Request/response flows
    - Data models
    - Authentication flows if relevant
    
    Use appropriate styling and organization to make the API structure clear.`,
    
    [DIAGRAM_TYPES.COMPONENT]: `You are a software architect tasked with creating a component diagram.
    Create a clean, well-organized component diagram for: "${title}"
    
    IMPORTANT: You must respond ONLY with a Mermaid flowchart diagram.
    Use the Mermaid syntax and format your response as follows:
    
    \`\`\`mermaid
    flowchart TD
      // Your diagram code here
    \`\`\`
    
    Include:
    - Major software components
    - Component dependencies
    - Interfaces between components
    - Key responsibilities of each component
    
    Focus on modularity and clear dependencies.`,
    
    [DIAGRAM_TYPES.FLOW]: `You are a process designer tasked with creating a flow diagram.
    Create a clean, well-organized flow diagram for: "${title}"
    
    IMPORTANT: You must respond ONLY with a Mermaid flowchart diagram.
    Use the Mermaid syntax and format your response as follows:
    
    \`\`\`mermaid
    flowchart TD
      // Your diagram code here
    \`\`\`
    
    Include:
    - Clear start and end points
    - Decision points with conditions
    - Process steps
    - Key outcomes
    
    Focus on making the flow easy to follow and understand.`
  };
  
  return prompts[diagramType] || prompts[DIAGRAM_TYPES.ARCHITECTURE];
}

const diagramService = {
  TYPES: DIAGRAM_TYPES,
  
  /**
   * Generate diagram from conversation
   * @param {String} sessionId - ID of the interview or coaching session
   * @param {String} diagramType - Type of diagram to generate
   * @param {String} customPrompt - Optional custom request for diagram
   * @returns {Promise<Object>} - Diagram data including Mermaid code
   */
  generateDiagram: async (sessionId, diagramType, customPrompt = null) => {
    try {
      console.log(`Generating ${diagramType} diagram for session ${sessionId}`);
      
      // Find the session
      const session = await Interview.findById(sessionId);
      if (!session) {
        throw new Error('Session not found');
      }
      
      // Find associated problem
      const problem = await Problem.findOne({ id: session.problemId });
      if (!problem) {
        throw new Error('Problem not found');
      }
      
      // Extract relevant conversation content
      const sessionContent = session.conversation
        .map(msg => `${msg.role.toUpperCase()}: ${msg.content}`)
        .join('\n\n');
      
      // Add user input if provided
      const userContext = customPrompt ? `\nAdditional requirements: ${customPrompt}` : '';
      
      // Generate Mermaid code using shared AI service
      const prompt = `Here is a conversation about designing ${problem.title}:
          
      ${sessionContent}
      ${userContext}
      
      Based on this conversation, create a Mermaid diagram that captures the key components and relationships.`;
      
      const response = await aiService.generateContent(prompt, {
        system: getPromptForDiagramType(diagramType, problem.title, customPrompt),
        temperature: 0.2,
        maxTokens: 1500
      });
      
      // Extract Mermaid code from response
      const mermaidCode = extractMermaidCode(response);
      
      return {
        mermaidCode,
        type: diagramType,
        description: `${diagramType.replace(/-/g, ' ')} diagram for ${problem.title}`,
        sessionId,
        problemId: problem.id,
        timestamp: new Date()
      };
    } catch (error) {
      console.error('Error generating diagram:', error);
      
      // Return a default diagram on error
      return {
        mermaidCode: `graph TD
          Client[Client] --> API[API Gateway]
          API --> Service[Service]
          Service --> DB[(Database)]`,
        type: diagramType,
        description: `Default ${diagramType} diagram (error during generation)`,
        sessionId,
        problemId: 'unknown',
        error: error.message
      };
    }
  },
  
  /**
   * Get available diagram types
   * @returns {Object} - Available diagram types
   */
  getDiagramTypes: () => DIAGRAM_TYPES
};

module.exports = diagramService;


================================================================================
# FILE: server\services\engines\baseEngine.js
# EXTENSION: .js
================================================================================
// server/services/engines/baseEngine.js
const AIFactory = require('../ai/aiFactory');
const aiConfig = require('../../config/aiConfig');

class BaseEngine {
  constructor(engineConfig = {}) {
    this.provider = engineConfig.provider || aiConfig.defaultProvider;
    console.log('⭐ Creating AI service for engine with provider:', this.provider);
    console.log('⭐ Config available:', !!aiConfig[this.provider], aiConfig[this.provider]);
    try {
      this.aiService = AIFactory.createService(this.provider, aiConfig[this.provider]);
      console.log('⭐ AI Service created:', !!this.aiService);
    } catch (error) {
      console.error('ERROR creating AI service:', error);
      throw new Error(`Failed to create AI service: ${error.message}`);
    }
    this.config = engineConfig;
  }
  
  async processMessage(sessionId, message, options = {}) {
    throw new Error('processMessage must be implemented by subclasses');
  }
  
  async startSession(userId, contentId, options = {}) {
    throw new Error('startSession must be implemented by subclasses');
  }
  
  async generateContent(sessionId, contentType, options = {}) {
    throw new Error('generateContent must be implemented by subclasses');
  }
}

module.exports = BaseEngine;



================================================================================
# FILE: server\services\engines\coachEngine.js
# EXTENSION: .js
================================================================================
// server/services/engines/coachEngine.js
const BaseEngine = require('./baseEngine');
const Interview = require('../../models/Interview');
const Problem = require('../../models/Problem');
const knowledgeService = require('../knowledge/knowledgeService');
const PersonaService = require('./PersonaService'); // Ensure PersonaService is initialized

const sessions = {};

class CoachEngine extends BaseEngine {
  constructor(config = {}) {
    super(config);
    // Stages can be passed dynamically or left empty
    this.stages = config.stages || [];
  }
  
  async processMessage(sessionId, message, options = {}) {
    try {
      // Retrieve or create session
      let session = await Interview.findOne({ id: sessionId });
      if (!session) {
        session = sessions[sessionId] || { id: sessionId, conversation: [] };
        sessions[sessionId] = session;
      }
      
      // Append user message to conversation history
      session.conversation.push({
        role: 'user',
        content: message,
        timestamp: new Date().toISOString()
      });
      
      // Retrieve dynamic data from options
      const workbookContent = options.workbookContent || {};
      const currentSection = options.currentSection || '';
      const userLevel = options.userLevel || '';
      
      // Get problem context dynamically from the database
      const problem = await Problem.findOne({ id: session.problemId });
      const problemContext = problem
        ? `Project: ${problem.title}\nDescription: ${problem.description || ''}\nAdditional Info: ${problem.additionalInfo || ''}`
        : '';
      
      // Merge dynamic parts from Persona, problem, workbook, etc.
      const dynamicParts = [
        PersonaService.getSystemPrompt({
          currentPage: options.currentPage,
          designData: { workbookContent, currentSection }
        }),
        problemContext,
        currentSection ? `Current Section: ${currentSection}` : '',
        Object.keys(workbookContent).length ? `Workbook Data: ${JSON.stringify(workbookContent)}` : '',
        userLevel ? `User Level: ${userLevel}` : ''
      ];
      const systemPrompt = dynamicParts.filter(Boolean).join("\n\n");
      
      // Debug: Log the final system prompt
      console.log("Final system prompt for processMessage:", systemPrompt);
      
      // Prepare conversation history for AI call
      const messagesForAI = session.conversation.map(msg => ({
        role: msg.role === 'coach' ? 'assistant' : msg.role,
        content: msg.content
      }));
      
      // Call the AI service with dynamic prompt and full conversation history
      const aiResponse = await this.aiService.sendMessage(messagesForAI, {
        system: systemPrompt,
        systemPrompt: systemPrompt,
        temperature: options.temperature || 0.7
      });
      
      const responseMsg = {
        role: 'coach',
        content: aiResponse,
        timestamp: new Date().toISOString()
      };
      session.conversation.push(responseMsg);
      
      if (session.save) {
        await session.save();
      }
      
      return responseMsg;
    } catch (error) {
      console.error('Error processing coaching message:', error);
      return {
        role: 'coach',
        content: "Error processing message. Please try again.",
        timestamp: new Date().toISOString(),
        error: true
      };
    }
  }
  
  async startSession(userId, problemId, options = {}) {
    try {
      const problem = await Problem.findOne({ id: problemId });
      if (!problem) throw new Error('Problem not found');
      
      // Build dynamic problem context
      const problemContext = [
        `Project: ${problem.title}`,
        `Description: ${problem.description || ''}`,
        `Additional Info: ${problem.additionalInfo || ''}`
      ].filter(Boolean).join("\n");
      
      // Retrieve extra background info dynamically (if available)
      const contextInfo = await knowledgeService.queryKnowledge(
        `System design concepts for ${problem.title}`,
        options.knowledgeSource || ''
      );
      
      const dynamicParts = [
        PersonaService.getSystemPrompt({ currentPage: 'coach', designData: { project: problem.title } }),
        problemContext,
        contextInfo,
        options.userLevel ? `User Level: ${options.userLevel}` : ''
      ];
      let systemPrompt = dynamicParts.filter(Boolean).join("\n\n");
      
      // Append an instruction to begin the session
      systemPrompt += `\n\nBegin with an introduction to the project and initial guidance.`;
      
      console.log("Final system prompt for startSession:", systemPrompt);
      
      // Call the AI service for an initial response
      const initialResponse = await this.aiService.sendMessage(
        [{ role: 'user', content: `I need help designing a system for: ${problem.title}.` }],
        {
          system: systemPrompt,
          systemPrompt: systemPrompt,
          temperature: options.temperature || 0.7
        }
      );
      
      const session = new Interview({
        userId,
        problemId,
        status: 'in_progress',
        currentStage: 'introduction',
        type: 'coaching',
        conversation: [{
          role: 'coach',
          content: initialResponse,
          timestamp: new Date().toISOString()
        }]
      });
      
      await session.save();
      return session;
    } catch (error) {
      console.error('Coaching session start error:', error);
      throw error;
    }
  }
  
  async generateContent(sessionId, topic, options = {}) {
    try {
      const session = await Interview.findOne({ id: sessionId });
      if (!session) throw new Error('Coaching session not found');
      const problem = await Problem.findOne({ id: session.problemId });
      
      const topicKnowledge = await knowledgeService.queryKnowledge(
        `${topic} ${session.problemId}`,
        options.knowledgeSource || ''
      );
      
      const dynamicParts = [
        `You are an educational content creator specializing in system design.`,
        `Generate detailed learning materials about "${topic}" related to project ${problem ? problem.title : ''}.`,
        `Reference: ${topicKnowledge}`
      ];
      
      let systemPrompt = dynamicParts.filter(Boolean).join("\n\n");
      
      if (options.conciseMode !== false) {
        systemPrompt += `\n\nProvide a concise narrative that includes project context.`;
      }
      
      const prompt = `I'd like to learn more about ${topic} for my system design project.`;
      const content = await this.aiService.generateContent(prompt, { 
        system: systemPrompt,
        systemPrompt: systemPrompt,
        temperature: options.temperature || 0.5
      });
      
      return { topic, content };
    } catch (error) {
      console.error('Generate learning materials error:', error);
      throw error;
    }
  }
  
  // Additional methods (_generateDiagramDescription, _getGraderInsights, etc.) should use a similar dynamic merging approach.
}

module.exports = CoachEngine;



================================================================================
# FILE: server\services\engines\graderEngine.js
# EXTENSION: .js
================================================================================
// server/services/engines/graderEngine.js
const BaseEngine = require('./baseEngine');
const Interview = require('../../models/Interview');
const Problem = require('../../models/Problem');
const Evaluation = require('../../models/Evaluation');
const fs = require('fs');
const path = require('path');

class GraderEngine extends BaseEngine {
  constructor(config = {}) {
    super(config);
    this.name = 'grader';
    
    // Try to load grader prompt from file
    try {
      const graderPromptPath = path.join(__dirname, '../../data/persona/grader.js');
      if (fs.existsSync(graderPromptPath)) {
        this.graderPrompt = require(graderPromptPath);
      } else {
        console.log('Grader prompt file not found, using default prompt');
        this.graderPrompt = this._getDefaultGraderPrompt;
      }
    } catch (error) {
      console.error('Error loading grader prompt:', error);
      this.graderPrompt = this._getDefaultGraderPrompt;
    }
  }
  
  /**
   * Evaluate a workbook submission
   * @param {string} sessionId - The session ID
   * @param {object} workbookContent - The content of the workbook
   * @param {object} options - Additional options
   * @returns {object} Evaluation results
   */
  async evaluateWorkbook(sessionId, workbookContent, options = {}) {
    try {
      // Find the session
      const session = await Interview.findById(sessionId).populate('problemId');
      
      if (!session) {
        throw new Error(`Session not found: ${sessionId}`);
      }
      
      // Extract problem and user information
      const problem = session.problemId;
      const userLevel = options.userLevel || 'mid-level';
      
      // Get system prompt for grader
      const systemPrompt = this._buildGraderPrompt({
        userLevel,
        problemId: problem?.id,
        evaluationType: session.type || 'coaching',
        conciseMode: options.conciseMode !== false // Default to concise mode
      });

      // Create prompt for evaluation
      const prompt = `Evaluate this system design for ${problem?.title || 'the given problem'}:

${JSON.stringify(workbookContent, null, 2)}

Provide a concise, focused evaluation following the framework in your instructions.`;

      // Generate evaluation using AI service
      const evaluationContent = await this.aiService.sendMessage([
        { role: 'system', content: systemPrompt },
        { role: 'user', content: prompt }
      ], { 
        temperature: 0.3 // Lower temperature for more consistent evaluations
      });

      // Parse scores and create evaluation record
      const scores = this._extractScores(evaluationContent);
      
      // Create or update evaluation record
      let evaluation = await Evaluation.findOne({ sessionId });
      
      if (!evaluation) {
        evaluation = new Evaluation({
          sessionId,
          evaluationType: session.type === 'interview' ? 'interview' : 'coaching',
          userLevel,
          problemId: problem?.id,
          content: evaluationContent,
          scores,
          timestamp: new Date()
        });
      } else {
        evaluation.content = evaluationContent;
        evaluation.scores = scores;
        evaluation.userLevel = userLevel;
        evaluation.timestamp = new Date();
      }
      
      await evaluation.save();
      
      return {
        evaluation: evaluationContent,
        scores
      };
    } catch (error) {
      console.error('Error in evaluateWorkbook:', error);
      throw error;
    }
  }

  /**
   * Extract numerical scores from evaluation text
   * @private
   * @param {string} evaluationText - The evaluation text to parse
   * @returns {object} Extracted scores
   */
  _extractScores(evaluationText) {
    const scores = {};
    const scorePattern = /([A-Za-z\s&]+)\s*\((\d+)\/(\d+)\)/g;
    let match;
    
    while ((match = scorePattern.exec(evaluationText)) !== null) {
      const category = match[1].trim();
      const score = parseInt(match[2], 10);
      const maxScore = parseInt(match[3], 10);
      scores[category] = { score, maxScore };
    }
    
    // Extract overall score if present
    const overallMatch = /Overall Score:\s*(\d+)\/(\d+)/i.exec(evaluationText);
    if (overallMatch) {
      scores.overall = { 
        score: parseInt(overallMatch[1], 10), 
        maxScore: parseInt(overallMatch[2], 10) 
      };
    }
    
    return scores;
  }
  
  /**
   * Provide final assessment for an interview
   * @param {string} interviewId - The interview ID
   * @param {object} options - Additional options
   * @returns {object} Assessment results
   */
  async provideFinalAssessment(interviewId, options = {}) {
    try {
      const interview = await Interview.findById(interviewId).populate('problemId');
      
      if (!interview) {
        throw new Error(`Interview not found: ${interviewId}`);
      }
      
      // Extract necessary information
      const userLevel = options.userLevel || 'mid-level';
      const conversationText = interview.conversation
        .map(msg => `${msg.role.toUpperCase()}: ${msg.content}`)
        .join('\n\n');
      
      // Build grader system prompt
      const systemPrompt = this._buildGraderPrompt({
        userLevel,
        problemId: interview.problemId?.id,
        evaluationType: 'interview',
        isFinal: true,
        conciseMode: options.conciseMode !== false // Default to concise mode
      });
      
      const prompt = `Provide a comprehensive assessment of this completed system design interview for ${interview.problemId?.title || 'a system design problem'}.

Interview conversation:
${conversationText}

Focus on evaluating their system design skills based on this interview.`;
      
      const assessment = await this.aiService.sendMessage([
        { role: 'system', content: systemPrompt },
        { role: 'user', content: prompt }
      ], { temperature: 0.3 });
      
      // Parse and store evaluation
      const scores = this._extractScores(assessment);
      
      // Create evaluation record
      const evaluation = new Evaluation({
        sessionId: interviewId,
        evaluationType: 'interview',
        userLevel,
        problemId: interview.problemId?.id,
        content: assessment,
        scores,
        timestamp: new Date(),
        isFinal: true
      });
      
      await evaluation.save();
      
      return {
        assessment,
        scores
      };
    } catch (error) {
      console.error('Error in provideFinalAssessment:', error);
      throw error;
    }
  }
  
  /**
   * Build the grader prompt with the appropriate context
   * @private
   * @param {object} context - Context for the prompt
   * @returns {string} The formatted grader prompt
   */
  _buildGraderPrompt(context) {
    // If we have a grader prompt function, use it
    if (typeof this.graderPrompt === 'function') {
      return this.graderPrompt(context);
    }
    
    // Otherwise use the default
    return this._getDefaultGraderPrompt(context);
  }
  
  /**
   * Get the default grader prompt
   * @private
   * @param {object} context - Context for the prompt
   * @returns {string} Default grader prompt
   */
  _getDefaultGraderPrompt(context = {}) {
    const { userLevel = 'mid-level', evaluationType = 'coaching', isFinal = false, conciseMode = true } = context;
    
    let prompt = `# SYSTEM DESIGN GRADER PERSONA

## ROLE DEFINITION
You are a System Design Grader responsible for objectively evaluating system design solutions. You provide structured, comprehensive feedback based on established criteria while maintaining a neutral, analytical tone.

## USER EXPERIENCE LEVEL ASSESSMENT
The user has identified themselves as: ${userLevel}
Tailor your expectations and feedback depth according to this level.

## EVALUATION FRAMEWORK
Assess designs across these key dimensions (100 points total):
1. Requirements Analysis (0-15 points)
2. System Interface Design (0-10 points)
3. Capacity Estimation (0-10 points)
4. Data Modeling (0-15 points)
5. High-Level Architecture (0-15 points)
6. Detailed Component Design (0-15 points)
7. Scalability & Performance (0-10 points)
8. Reliability & Fault Tolerance (0-10 points)

## FEEDBACK FORMAT
1. Summary Assessment
   - User's experience level
   - Overall score
   - 1-2 sentence summary of strongest and weakest areas

2. Dimensional Breakdown
   - Score for each dimension
   - 1-2 bullet points for strengths
   - 1-2 bullet points for improvements

3. Prioritized Improvement Plan
   - 3 highest priority improvements ranked by importance
   - One-sentence explanation for each

## SCORING GUIDELINES BY LEVEL`;

    // Add level-specific guidelines
    if (userLevel === 'junior') {
      prompt += `
- Junior Level: 60-70 points meets expectations
- Key focus: Functional correctness, basic component understanding`;
    } else if (userLevel === 'mid-level') {
      prompt += `
- Mid-Level: 70-80 points meets expectations
- Key focus: Scalability, component interactions, basic trade-offs`;
    } else if (userLevel === 'senior') {
      prompt += `
- Senior Level: 80-90 points meets expectations
- Key focus: Comprehensive design, performance optimization, fault tolerance`;
    } else {
      prompt += `
- Staff+: 90-100 points meets expectations
- Key focus: System-wide optimization, elegant design patterns, forward-thinking architecture`;
    }

    // Add concise mode instructions
    if (conciseMode) {
      prompt += `

## COMMUNICATION STYLE
Be direct and focused in your evaluation:
- Use short paragraphs (2-3 sentences maximum)
- Prefer bullet points for feedback items
- Avoid explaining basic concepts
- Focus on actionable insights rather than theory
- Eliminate filler words and redundant phrases
- Format scores consistently and clearly
- Make improvement suggestions specific and concrete`;
    }

    // Add any evaluation-type specific instructions
    if (evaluationType === 'interview' && isFinal) {
      prompt += `

## INTERVIEW ASSESSMENT FOCUS
When evaluating an interview:
- Consider the candidate's thought process
- Assess how they handled probing questions
- Evaluate their communication clarity
- Consider their ability to defend design choices
- Note how they handled feedback during the interview`;
    }
    
    return prompt;
  }
}

module.exports = new GraderEngine();


================================================================================
# FILE: server\services\engines\interviewEngine.js
# EXTENSION: .js
================================================================================
// server/services/engines/interviewEngine.js
const BaseEngine = require('./baseEngine');
const Interview = require('../../models/Interview');
const Problem = require('../../models/Problem');
const diagramUtils = require('../utils/diagramUtils');
const knowledgeService = require('../knowledge/knowledgeService');

const sessions = {};

class InterviewEngine extends BaseEngine {
  constructor(config = {}) {
    super(config);
    this.evaluationThreshold = config.evaluationThreshold || 0.8;
    this.diagramStageThreshold = config.diagramStageThreshold || 2;
  }
  
  async startInterview(userId, problemId, options = {}) {
    try {
      const problem = await Problem.findOne({ id: problemId });
      if (!problem) throw new Error('Problem not found');
      
      console.log(`Starting interview for user ${userId} with problem ${problemId}`);
      
      const context = await knowledgeService.queryKnowledge(`System design interview for ${problem.title}`, options.knowledgeSource || 'facebook');
      
      let systemPrompt = options.systemPrompt || `You are an expert system design interviewer.
Use the following context:
${context}
Guide the candidate through designing ${problem.title}. Ask probing questions and challenge assumptions.`;

      // Add concise mode instructions if enabled
      if (options.conciseMode !== false) { // Default to concise mode
        systemPrompt += `\n\nUse a CONCISE communication style:
- Ask focused questions with clear intent
- Keep follow-ups brief and targeted
- Use short paragraphs (2-3 sentences maximum)
- Prioritize probing questions over explanations
- Eliminate unnecessary preambles`;
      }

      systemPrompt += `\n\nBegin with a brief introduction.`;

      const initialResponse = await this.aiService.sendMessage([], {
        system: systemPrompt,
        temperature: options.temperature || 0.7
      });
      
      const interview = new Interview({
        userId,
        problemId,
        status: 'in_progress',
        currentStage: 'introduction',
        type: 'interview',
        startedAt: new Date(),
        timeLimit: problem.timeLimit || 45,
        conversation: [{
          role: 'interviewer',
          content: initialResponse || `Welcome to your system design interview. Today I'd like you to design ${problem.title}. We have about 45 minutes for this discussion. Could you start by telling me how you understand this problem and what key requirements we should consider?`,
          stage: 'introduction',
          timestamp: new Date().toISOString()
        }]
      });
      
      await interview.save();
      console.log(`Interview created with ID: ${interview._id}`);
      return interview;
    } catch (error) {
      console.error('Interview session start error:', error);
      throw error;
    }
  }
  
  async generateContent(sessionId, contentType, options = {}) {
    try {
      const interview = await Interview.findById(sessionId);
      if (!interview) throw new Error('Interview session not found');
      
      const problem = await Problem.findOne({ id: interview.problemId });
      const prompt = `Provide detailed feedback for the interview on ${problem.title}.`;
      
      let systemPrompt = "You are an experienced interviewer providing detailed feedback.";
      
      // Add concise mode if enabled
      if (options.conciseMode !== false) {
        systemPrompt += `\n\nUse a CONCISE communication style:
- Focus on key observations
- Use bullet points for strengths and weaknesses
- Keep paragraphs short (2-3 sentences)
- Prioritize actionable feedback over general advice`;
      }
      
      const content = await this.aiService.generateContent(prompt, {
        system: systemPrompt,
        temperature: options.temperature || 0.6
      });
      
      return { type: 'feedback', content };
    } catch (error) {
      console.error('Generate content error in InterviewEngine:', error);
      throw error;
    }
  }
  
  async generateDiagram(sessionId, options = {}) {
    try {
      const interview = await Interview.findById(sessionId);
      if (!interview) throw new Error('Session not found');
      
      const problem = await Problem.findOne({ id: interview.problemId });
      const currentStage = options.stage || interview.currentStage || 'introduction';
      const entities = this._extractEntities(interview.conversation, currentStage);
      const diagramType = options.diagramType || diagramUtils.getDiagramTypeForStage(currentStage);
      const svgDiagram = diagramUtils.generateSvgDiagram(entities, diagramType, problem.title);
      
      return { diagram: svgDiagram, type: diagramType };
    } catch (error) {
      console.error('Error generating diagram in InterviewEngine:', error);
      return null;
    }
  }
  
  async processResponse(interviewId, message, options = {}) {
    console.log(`Processing interview message for interview ${interviewId}`);
    
    try {
      // Find the interview by ID - using findById instead of findOne with id
      const interview = await Interview.findById(interviewId);
      
      if (!interview) {
        console.error(`Interview not found with ID: ${interviewId}`);
        throw new Error('Interview not found');
      }
      
      console.log(`Found interview, current stage: ${interview.currentStage}`);
      
      // Add user message to conversation
      interview.conversation.push({
        role: 'candidate',
        content: message,
        stage: interview.currentStage,
        timestamp: new Date().toISOString()
      });
      
      // Prepare messages for AI
      const messagesForAI = interview.conversation.map(msg => ({
        role: msg.role === 'interviewer' ? 'assistant' : 
              msg.role === 'candidate' ? 'user' : msg.role,
        content: msg.content
      }));
      
      // Get problem context
      const problem = await Problem.findOne({ id: interview.problemId });
      if (!problem) {
        console.warn(`Problem not found for interview ${interviewId}`);
      }
      
      // User experience level
      const userLevel = options.userLevel || 'mid-level';
      
      // Add system message with interview context
      let systemMessage = {
        role: 'system',
        content: `You are conducting a system design interview for ${problem?.title || 'a system design problem'}. 
The current stage is: ${interview.currentStage}.
Respond to the candidate's last message with thoughtful questions that probe their understanding.
Be conversational and react to what they've said, don't give generic responses.
If they ask about requirements, explore them thoroughly before moving to architecture.`
      };
      
      // Add concise mode instructions if enabled
      if (options.conciseMode !== false) { // Default to concise mode
        systemMessage.content += `\n\nUse a CONCISE communication style:
- Ask focused questions with clear intent
- Keep follow-ups brief and targeted
- Use short paragraphs (2-3 sentences maximum)
- Prioritize probing questions over explanations
- Eliminate unnecessary preambles`;
      }
      
      // Add user level information
      systemMessage.content += `\n\nThe candidate has identified as a ${userLevel} engineer. Adjust your expectations accordingly.`;
      
      // Generate AI response
      console.log('Generating interviewer response...');
      const response = await this.aiService.sendMessage(
        [systemMessage, ...messagesForAI], 
        { 
          temperature: options.temperature || 0.7,
          max_tokens: options.maxTokens || 800
        }
      );
      
      // Determine if we should advance to next stage
      const shouldAdvanceStage = this._shouldAdvanceStage(
        interview.conversation, 
        interview.currentStage, 
        messagesForAI.length
      );
      
      // Add interviewer response to conversation
      const responseMsg = {
        role: 'interviewer',
        content: response || "I'm interested in your approach. Could you elaborate on that further?",
        stage: interview.currentStage,
        timestamp: new Date().toISOString()
      };
      
      interview.conversation.push(responseMsg);
      
      // Update stage if needed
      if (shouldAdvanceStage) {
        interview.currentStage = this._getNextStage(interview.currentStage);
        console.log(`Advanced to stage: ${interview.currentStage}`);
      }
      
      // Save the updated interview
      await interview.save();
      console.log('Interview updated successfully');
      
      return interview;
    } catch (error) {
      console.error('Error processing interview message:', error);
      
      // Return fallback response
      return {
        conversation: [
          {
            role: 'interviewer',
            content: "I apologize, but I'm having trouble processing your response. Could you please explain your design approach again?",
            timestamp: new Date().toISOString(),
            error: true
          }
        ]
      };
    }
  }
  
  async finalizeInterview(interview) {
    try {
      if (!interview) throw new Error('Interview not found');
      
      if (interview.status === 'completed') {
        console.log('Interview already completed');
        return interview;
      }
      
      // Add final message if the interview was in progress
      if (interview.status === 'in_progress') {
        interview.conversation.push({
          role: 'interviewer',
          content: "Thank you for participating in this system design interview. I'll now provide you with feedback on your performance.",
          stage: interview.currentStage,
          timestamp: new Date().toISOString()
        });
        
        interview.status = 'completed';
        interview.completedAt = new Date();
      }
      
      // Prepare evaluation if not already done
      if (!interview.evaluation) {
        // Get grader assessment if available
        let graderAssessment = null;
        try {
          const graderEngine = require('./graderEngine');
          const userLevel = interview.userLevel || 'mid-level';
          
          // Get assessment from grader
          const assessment = await graderEngine.provideFinalAssessment(interview._id, { userLevel });
          if (assessment) {
            graderAssessment = assessment;
          }
        } catch (graderError) {
          console.error('Error getting grader assessment:', graderError);
          // Continue with regular evaluation if grader fails
        }
        
        // If we got grader assessment, use it
        if (graderAssessment) {
          interview.evaluation = {
            score: graderAssessment.scores.overall?.score || 70,
            feedback: graderAssessment.assessment,
            strengths: [],
            weaknesses: [],
            areas_to_improve: []
          };
        } else {
          // Fall back to original evaluation logic
          const problem = await Problem.findOne({ id: interview.problemId });
          
          // Extract the conversation for evaluation
          const conversationText = interview.conversation
            .map(msg => `${msg.role.toUpperCase()}: ${msg.content}`)
            .join('\n\n');
          
          let systemPrompt = `You are an expert system design interviewer evaluating a candidate.
The problem was: ${problem?.title || 'a system design problem'}.
Provide a detailed evaluation with:
1. Overall score (0-100)
2. General feedback (2-3 paragraphs)
3. Key strengths (3-5 bullet points)
4. Areas for improvement (3-5 bullet points)
5. Specific advice for next steps`;
          
          // Add concise mode if enabled
          if (interview.conciseMode !== false) {
            systemPrompt += `\n\nUse a CONCISE communication style:
- Keep paragraphs short (2-3 sentences)
- Use bullet points for lists
- Be direct and focused
- Eliminate filler phrases and redundancy`;
          }
          
          // Generate evaluation
          const evaluationPrompt = `Based on this interview conversation, provide a detailed evaluation:\n\n${conversationText}`;
          
          const evaluationResponse = await this.aiService.sendMessage(
            [{role: 'system', content: systemPrompt}, {role: 'user', content: evaluationPrompt}],
            { temperature: 0.4, max_tokens: 1500 }
          );
          
          // Parse the evaluation
          try {
            // Extract score with regex (looking for a number from 0-100)
            const scoreMatch = evaluationResponse.match(/score:?\s*(\d{1,3})/i);
            const score = scoreMatch ? parseInt(scoreMatch[1], 10) : 70;
            
            // Basic structure for evaluation
            interview.evaluation = {
              score: Math.min(100, Math.max(0, score)), // Ensure score is between 0-100
              feedback: evaluationResponse,
              strengths: [],
              weaknesses: [],
              areas_to_improve: []
            };
          } catch (parseError) {
            console.error('Error parsing evaluation:', parseError);
            interview.evaluation = {
              score: 70,
              feedback: evaluationResponse || "Evaluation could not be generated.",
              strengths: [],
              weaknesses: [], 
              areas_to_improve: []
            };
          }
        }
      }
      
      await interview.save();
      return interview;
    } catch (error) {
      console.error('Error finalizing interview:', error);
      throw error;
    }
  }
  
  _extractEntities(messages, currentStage) {
    const userMessages = messages
      .filter(msg => msg.role === 'candidate' || msg.role === 'user')
      .map(msg => msg.content)
      .join('\n');
    
    const componentKeywords = [
      'server', 'database', 'cache', 'load balancer', 'api', 'client', 
      'service', 'queue', 'storage', 'frontend', 'backend', 'microservice'
    ];
    
    const entities = { 
      components: [], 
      relationships: [], 
      databases: [], 
      clients: [], 
      services: [] 
    };
    
    componentKeywords.forEach(keyword => {
      if (userMessages.toLowerCase().includes(keyword)) {
        const type = keyword.includes('database') ? 'databases'
          : (keyword.includes('client') || keyword.includes('frontend')) ? 'clients'
          : (keyword.includes('service') || keyword.includes('api') || keyword.includes('backend')) ? 'services'
          : 'components';
        
        entities[type].push({
          name: keyword.charAt(0).toUpperCase() + keyword.slice(1),
          type: keyword
        });
      }
    });
    
    // Add default components based on stage
    if (entities.components.length === 0 && 
        entities.databases.length === 0 && 
        entities.services.length === 0) {
      
      // If we're past the introduction/requirements stage
      if (currentStage !== 'introduction' && currentStage !== 'requirements') {
        entities.clients.push({ name: 'Client', type: 'client' });
        entities.services.push({ name: 'API Service', type: 'service' });
      }
      
      // If we're in data modeling or later stages
      if (currentStage === 'data_modeling' || 
          currentStage === 'scalability' || 
          currentStage === 'conclusion') {
        entities.databases.push({ name: 'Database', type: 'database' });
      }
    }
    
    return entities;
  }
  
  _shouldAdvanceStage(conversation, currentStage, messageCount) {
    // Only advance stage after enough messages have been exchanged
    if (messageCount < 6) return false;
    
    // Map of stages to number of message pairs required before advancing
    const stageThresholds = {
      'introduction': 3,
      'requirements': 5,
      'architecture': 7,
      'data_modeling': 5,
      'scalability': 5,
      'conclusion': 999 // Never automatically advance past conclusion
    };
    
    const threshold = stageThresholds[currentStage] || 5;
    
    // Count pairs of messages (candidate -> interviewer)
    const relevantMessages = conversation.filter(
      msg => msg.stage === currentStage
    );
    
    const pairs = Math.floor(relevantMessages.length / 2);
    return pairs >= threshold;
  }
  
  _getNextStage(currentStage) {
    const stages = [
      'introduction',
      'requirements',
      'architecture',
      'data_modeling',
      'scalability',
      'conclusion'
    ];
    
    const currentIndex = stages.indexOf(currentStage);
    if (currentIndex === -1 || currentIndex === stages.length - 1) {
      return 'conclusion';
    }
    
    return stages[currentIndex + 1];
  }
}

module.exports = InterviewEngine;


================================================================================
# FILE: server\services\engines\PersonaService.js
# EXTENSION: .js
================================================================================
// server/services/engines/PersonaService.js
class PersonaService {
  constructor() {
    this.personas = {};
    this.activePersonaId = 'coach'; // default active persona
    this.conciseMode = true; // default mode
  }
  
  initialize(config) {
    if (!config || !config.personas || !Array.isArray(config.personas)) {
      throw new Error('Invalid persona configuration');
    }
    
    config.personas.forEach(persona => {
      this.personas[persona.id] = persona;
    });
    
    // Validate that required personas exist
    ['coach', 'interviewer', 'grader'].forEach(requiredId => {
      if (!this.personas[requiredId]) {
        console.warn(`Required persona '${requiredId}' not found in configuration`);
      }
    });
    
    console.log(`Initialized ${Object.keys(this.personas).length} personas`);
    return this;
  }
  
  setActivePersona(personaId) {
    if (!this.personas[personaId]) {
      throw new Error(`Persona '${personaId}' not found`);
    }
    this.activePersonaId = personaId;
    return this.personas[personaId];
  }
  
  setConciseMode(enabled) {
    this.conciseMode = enabled;
    return this.conciseMode;
  }
  
  getActivePersona() {
    return this.personas[this.activePersonaId];
  }
  
  getPersona(personaId) {
    const persona = this.personas[personaId];
    if (!persona) {
      throw new Error(`Persona '${personaId}' not found`);
    }
    return persona;
  }
  
  getPageSuggestions(pageId) {
    const persona = this.getActivePersona();
    if (persona.pageSuggestions && persona.pageSuggestions[pageId]) {
      return persona.pageSuggestions[pageId];
    }
    return [];
  }
  
  getSystemPrompt(context = {}) {
    const persona = this.getActivePersona();
    let prompt = persona.systemPrompt || '';
    
    if (this.conciseMode) {
      prompt += `\n\nPlease provide a concise, narrative explanation that includes detailed project context when available. Avoid rigid bullet lists.`;
    } else {
      prompt += `\n\nPlease provide a detailed narrative explanation that covers all technical and project-specific details.`;
    }
    
    if (context.currentPage) {
      prompt += `\nSection: ${context.currentPage}`;
    }
    
    if (context.designData) {
      prompt += `\nProject Details: ${JSON.stringify(context.designData)}`;
    }
    
    return prompt;
  }
  
  formatResponse(patternKey, variables = {}) {
    const persona = this.getActivePersona();
    if (!persona.responsePatterns || !persona.responsePatterns[patternKey]) {
      return null;
    }
    
    let response = persona.responsePatterns[patternKey];
    Object.entries(variables).forEach(([key, value]) => {
      response = response.replace(`{${key}}`, value);
    });
    return response;
  }
  
  getAllPersonas() {
    return Object.values(this.personas).map(persona => ({
      id: persona.id,
      name: persona.name,
      role: persona.role,
      description: persona.description
    }));
  }
}

module.exports = new PersonaService();



================================================================================
# FILE: server\services\evaluation\evaluationParser.js
# EXTENSION: .js
================================================================================



================================================================================
# FILE: server\services\knowledge\knowledgeService.js
# EXTENSION: .js
================================================================================
// server/services/knowledge/knowledgeService.js
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');
const util = require('util');
const exec = util.promisify(require('child_process').exec);

class KnowledgeService {
  constructor() {
    this.initialized = false;
    this.pythonService = null;
  }

  async initialize() {
    if (this.initialized) return;
    
    try {
      // Create Python script for vector store operations
      const scriptPath = path.join(__dirname, 'vector_store.py');
      if (!fs.existsSync(scriptPath)) {
        fs.writeFileSync(scriptPath, this._getPythonScript());
      }
      
      // Start Python process
      this.pythonService = spawn('python', [scriptPath]);
      
      // Handle output
      this.pythonService.stdout.on('data', (data) => {
        console.log(`Vector store: ${data}`);
      });
      
      this.pythonService.stderr.on('data', (data) => {
        console.error(`Vector store error: ${data}`);
      });
      
      // Initialize the vector database
      await this._executeCommand('initialize');
      
      this.initialized = true;
      console.log('Knowledge base initialized successfully');
    } catch (error) {
      console.error('Error initializing knowledge base:', error);
    }
  }
  
  async queryKnowledge(query, company = 'facebook') {
    if (!this.initialized) await this.initialize();
    
    try {
      const result = await this._executeCommand('query', { query, company });
      return result;
    } catch (error) {
      console.error('Error querying knowledge base:', error);
      return '';
    }
  }
  
  async _executeCommand(command, params = {}) {
    const requestId = Date.now().toString();
    const requestFile = path.join(__dirname, `request_${requestId}.json`);
    const responseFile = path.join(__dirname, `response_${requestId}.json`);
    
    // Write request to file
    fs.writeFileSync(requestFile, JSON.stringify({
      command,
      params
    }));
    
    // Execute Python command
    await exec(`python ${path.join(__dirname, 'vector_store.py')} ${requestId}`);
    
    // Read response
    const response = JSON.parse(fs.readFileSync(responseFile, 'utf8'));
    
    // Clean up
    fs.unlinkSync(requestFile);
    fs.unlinkSync(responseFile);
    
    return response.result;
  }
  
  _getPythonScript() {
    return `
import sys
import os
import json
from langchain.document_loaders import TextLoader, DirectoryLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
import openai

# Set up OpenAI API key
openai.api_key = os.environ.get("OPENAI_API_KEY", "your-openai-key")

# Paths
KNOWLEDGE_BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../../data/knowledge_base')
VECTOR_DB_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../../data/chroma_db')

# Global variables
vector_stores = {}

def initialize_vector_store():
    """Initialize or load vector stores for each company"""
    companies = [d for d in os.listdir(KNOWLEDGE_BASE_DIR) if os.path.isdir(os.path.join(KNOWLEDGE_BASE_DIR, d))]
    
    for company in companies:
        company_dir = os.path.join(KNOWLEDGE_BASE_DIR, company)
        
        # Check if documents exist
        if not any(f.endswith('.md') for f in os.listdir(company_dir)):
            print(f"No markdown files found for {company}")
            continue
        
        # Create vector store directory
        company_vector_dir = os.path.join(VECTOR_DB_DIR, company)
        os.makedirs(company_vector_dir, exist_ok=True)
        
        # Load documents
        loader = DirectoryLoader(company_dir, glob="**/*.md", loader_cls=TextLoader)
        documents = loader.load()
        
        if not documents:
            print(f"No documents loaded for {company}")
            continue
        
        # Split documents
        text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)
        chunks = text_splitter.split_documents(documents)
        
        # Create embeddings and vector store
        embeddings = OpenAIEmbeddings()
        vector_store = Chroma.from_documents(
            chunks, 
            embeddings, 
            persist_directory=company_vector_dir
        )
        
        vector_stores[company] = vector_store
        print(f"Initialized vector store for {company} with {len(chunks)} chunks")

def query_knowledge(query, company="facebook"):
    """Query the vector store for relevant knowledge"""
    if company not in vector_stores:
        return "No knowledge available for this company"
    
    # Get relevant documents
    docs = vector_stores[company].similarity_search(query, k=3)
    
    # Combine document contents
    return "\\n\\n".join([doc.page_content for doc in docs])

if __name__ == "__main__":
    if len(sys.argv) > 1:
        request_id = sys.argv[1]
        request_file = f"request_{request_id}.json"
        response_file = f"response_{request_id}.json"
        
        # Read request
        with open(request_file, 'r') as f:
            request = json.load(f)
        
        command = request['command']
        params = request.get('params', {})
        
        result = ""
        
        # Execute command
        if command == "initialize":
            initialize_vector_store()
            result = "Vector store initialized"
        elif command == "query":
            result = query_knowledge(params.get('query', ''), params.get('company', 'facebook'))
        
        # Write response
        with open(response_file, 'w') as f:
            json.dump({"result": result}, f)
    else:
        # Initialize on startup
        initialize_vector_store()
        
        # Wait for commands
        while True:
            line = sys.stdin.readline().strip()
            if line == "exit":
                break
    `;
  }
}

module.exports = new KnowledgeService();


================================================================================
# FILE: server\services\knowledge\vector_store.py
# EXTENSION: .py
================================================================================
import sys
import os
import json
from langchain_community.document_loaders import TextLoader, DirectoryLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.embeddings import OpenAIEmbeddings
from langchain_community.vectorstores import Chroma
import openai

# Set up OpenAI API key
openai.api_key = os.environ.get("OPENAI_API_KEY", "your-openai-key")

# Paths
KNOWLEDGE_BASE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../../data/knowledge_base')
VECTOR_DB_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../../data/chroma_db')

# Global variables
vector_stores = {}

def initialize_vector_store():
    """Initialize or load vector stores for each company"""
    try:
        companies = [d for d in os.listdir(KNOWLEDGE_BASE_DIR) if os.path.isdir(os.path.join(KNOWLEDGE_BASE_DIR, d))]
        
        for company in companies:
            company_dir = os.path.join(KNOWLEDGE_BASE_DIR, company)
            
            # Check if documents exist
            if not any(f.endswith('.md') for f in os.listdir(company_dir)):
                print(f"No markdown files found for {company}")
                continue
            
            # Create vector store directory
            company_vector_dir = os.path.join(VECTOR_DB_DIR, company)
            os.makedirs(company_vector_dir, exist_ok=True)
            
            # Load documents
            loader = DirectoryLoader(company_dir, glob="**/*.md", loader_cls=TextLoader)
            documents = loader.load()
            
            if not documents:
                print(f"No documents loaded for {company}")
                continue
            
            # Split documents
            text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)
            chunks = text_splitter.split_documents(documents)
            
            # Create embeddings and vector store
            embeddings = OpenAIEmbeddings()
            vector_store = Chroma.from_documents(
                chunks, 
                embeddings, 
                persist_directory=company_vector_dir
            )
            
            vector_stores[company] = vector_store
            print(f"Initialized vector store for {company} with {len(chunks)} chunks")
    except Exception as e:
        print(f"Error initializing vector store: {str(e)}")
        return f"Error: {str(e)}"
    
    return "Vector store initialized successfully"

def query_knowledge(query, company="facebook"):
    """Query the vector store for relevant knowledge"""
    try:
        if company not in vector_stores:
            return "No knowledge available for this company"
        
        # Get relevant documents
        docs = vector_stores[company].similarity_search(query, k=3)
        
        # Combine document contents
        return "\n\n".join([doc.page_content for doc in docs])
    except Exception as e:
        print(f"Error querying knowledge: {str(e)}")
        return f"Error: {str(e)}"

if __name__ == "__main__":
    if len(sys.argv) > 1:
        request_id = sys.argv[1]
        request_file = f"request_{request_id}.json"
        response_file = f"response_{request_id}.json"
        
        try:
            # Check if request file exists
            if not os.path.exists(request_file):
                result = f"Error: Request file {request_file} not found"
                with open(response_file, 'w') as f:
                    json.dump({"result": result}, f)
                sys.exit(1)
            
            # Read request
            with open(request_file, 'r') as f:
                request = json.load(f)
            
            command = request.get('command', '')
            params = request.get('params', {})
            
            result = ""
            
            # Execute command
            if command == "initialize":
                result = initialize_vector_store()
            elif command == "query":
                result = query_knowledge(params.get('query', ''), params.get('company', 'facebook'))
            else:
                result = f"Unknown command: {command}"
            
            # Write response
            with open(response_file, 'w') as f:
                json.dump({"result": result}, f)
                
        except Exception as e:
            # Ensure we write a response file even if an error occurs
            error_message = f"Error processing request: {str(e)}"
            print(error_message)
            try:
                with open(response_file, 'w') as f:
                    json.dump({"result": error_message}, f)
            except:
                print(f"Could not write to response file {response_file}")
    else:
        # Initialize on startup
        print("Initializing vector store...")
        initialize_vector_store()
        
        # Wait for commands
        print("Ready for commands (type 'exit' to quit)")
        while True:
            try:
                line = sys.stdin.readline().strip()
                if line == "exit":
                    break
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"Error reading input: {str(e)}")


================================================================================
# FILE: server\services\utils\diagramUtils.js
# EXTENSION: .js
================================================================================
// server/services/utils/diagramUtils.js

/**
 * Determine which type of diagram to generate based on the current stage
 * @param {Number} currentStage - Current design stage
 * @returns {String} - Diagram type (architecture, er, sequence)
 */
function getDiagramTypeForStage(currentStage) {
    const stageToType = {
      0: null, // Requirements - no diagram
      1: null, // Scale estimation - no diagram
      2: 'api', // API design - API diagram
      3: 'er', // Data model - ER diagram
      4: 'architecture', // System architecture
      5: 'architecture' // Optimization - enhanced architecture
    };
    
    return stageToType[currentStage] || 'architecture';
  }
  
  /**
   * Generate an SVG diagram based on extracted entities
   * @param {Object} entities - Extracted components and relationships
   * @param {String} diagramType - Type of diagram to generate
   * @param {String} title - Diagram title
   * @returns {String} - SVG markup
   */
  function generateSvgDiagram(entities, diagramType, title) {
    if (diagramType === 'er') {
      return generateErDiagram(entities, title);
    } else if (diagramType === 'api') {
      return generateApiDiagram(entities, title);
    } else {
      return generateArchitectureDiagram(entities, title);
    }
  }
  
  /**
   * Generate an architecture diagram as SVG
   * @param {Object} entities - Extracted components and relationships
   * @param {String} title - Diagram title
   * @returns {String} - SVG markup
   */
  function generateArchitectureDiagram(entities, title) {
    const svgWidth = 800;
    const svgHeight = 600;
    
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}" width="100%" height="100%">
      <!-- Background -->
      <rect width="${svgWidth}" height="${svgHeight}" fill="#f8f9fa" rx="10" ry="10"/>
      
      <!-- Title -->
      <text x="${svgWidth/2}" y="40" font-family="Arial" font-size="24" font-weight="bold" text-anchor="middle" fill="#333">${title}</text>
      <text x="${svgWidth/2}" y="65" font-family="Arial" font-size="14" text-anchor="middle" fill="#666">System Architecture</text>
      
      <!-- Layers -->
      <rect x="50" y="100" width="${svgWidth-100}" height="80" fill="#e3f2fd" stroke="#2196f3" stroke-width="2" rx="5" ry="5" opacity="0.5"/>
      <text x="${svgWidth/2}" y="125" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#0d47a1">Client Layer</text>
      
      <rect x="50" y="200" width="${svgWidth-100}" height="80" fill="#e8f5e9" stroke="#4caf50" stroke-width="2" rx="5" ry="5" opacity="0.5"/>
      <text x="${svgWidth/2}" y="225" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#1b5e20">API Layer</text>
      
      <rect x="50" y="300" width="${svgWidth-100}" height="80" fill="#fff3e0" stroke="#ff9800" stroke-width="2" rx="5" ry="5" opacity="0.5"/>
      <text x="${svgWidth/2}" y="325" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#e65100">Service Layer</text>
      
      <rect x="50" y="400" width="${svgWidth-100}" height="80" fill="#e0f7fa" stroke="#00bcd4" stroke-width="2" rx="5" ry="5" opacity="0.5"/>
      <text x="${svgWidth/2}" y="425" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#006064">Data Layer</text>
    `;
    
    // Add clients to client layer
    const clients = entities.clients.length > 0 ? entities.clients : [{ name: 'Client Application', type: 'client' }];
    const clientWidth = Math.min(120, (svgWidth - 150) / clients.length);
    clients.forEach((client, index) => {
      const x = 100 + index * (clientWidth + 30);
      svg += `
        <rect x="${x}" y="115" width="${clientWidth}" height="50" fill="#bbdefb" stroke="#1976d2" stroke-width="2" rx="5" ry="5"/>
        <text x="${x + clientWidth/2}" y="145" font-family="Arial" font-size="14" text-anchor="middle" fill="#0d47a1">${client.name}</text>
      `;
    });
    
    // Add load balancer if present
    if (entities.components.some(c => c.type.includes('load balancer'))) {
      svg += `
        <path d="M370,215 L440,215 L470,245 L440,275 L370,275 L340,245 Z" fill="#c8e6c9" stroke="#388e3c" stroke-width="2"/>
        <text x="405" y="250" font-family="Arial" font-size="14" text-anchor="middle" fill="#1b5e20">Load Balancer</text>
      `;
    }
    
    // Add services to service layer
    const services = entities.services.length > 0 ? entities.services : [{ name: 'API Service', type: 'service' }];
    const serviceWidth = Math.min(120, (svgWidth - 150) / services.length);
    services.forEach((service, index) => {
      const x = 100 + index * (serviceWidth + 30);
      svg += `
        <rect x="${x}" y="315" width="${serviceWidth}" height="50" fill="#ffe0b2" stroke="#f57c00" stroke-width="2" rx="5" ry="5"/>
        <text x="${x + serviceWidth/2}" y="345" font-family="Arial" font-size="14" text-anchor="middle" fill="#e65100">${service.name}</text>
      `;
    });
    
    // Add databases to data layer
    const databases = entities.databases.length > 0 ? entities.databases : [{ name: 'Database', type: 'database' }];
    databases.forEach((db, index) => {
      const x = 150 + index * 200;
      svg += `
        <path d="M${x-60},430 L${x+60},430 L${x+60},450 C${x+60},470 ${x},485 ${x-60},485 L${x-60},430 Z" fill="#b2ebf2" stroke="#0097a7" stroke-width="2"/>
        <ellipse cx="${x}" cy="430" rx="60" ry="15" fill="#b2ebf2" stroke="#0097a7" stroke-width="2"/>
        <text x="${x}" y="460" font-family="Arial" font-size="14" font-weight="bold" text-anchor="middle" fill="#006064">${db.name}</text>
      `;
    });
    
    // Add cache if present
    if (entities.components.some(c => c.type.includes('cache'))) {
      svg += `
        <rect x="600" y="430" width="120" height="50" fill="#b2ebf2" stroke="#0097a7" stroke-width="2" rx="5" ry="5"/>
        <text x="660" y="460" font-family="Arial" font-size="14" font-weight="bold" text-anchor="middle" fill="#006064">Cache</text>
      `;
    }
    
    // Add connections between layers
    svg += `
      <!-- Client to API connections -->
      <line x1="160" y1="165" x2="160" y2="215" stroke="#757575" stroke-width="2" stroke-dasharray="5,5"/>
      <line x1="400" y1="165" x2="400" y2="215" stroke="#757575" stroke-width="2" stroke-dasharray="5,5"/>
      
      <!-- API to Service connections -->
      <line x1="160" y1="275" x2="160" y2="315" stroke="#757575" stroke-width="2"/>
      <line x1="400" y1="275" x2="400" y2="315" stroke="#757575" stroke-width="2"/>
      
      <!-- Service to Database connections -->
      <line x1="160" y1="365" x2="160" y2="430" stroke="#757575" stroke-width="2"/>
      <line x1="400" y1="365" x2="400" y2="430" stroke="#757575" stroke-width="2"/>
    `;
    
    svg += `</svg>`;
    return svg;
  }
  
  /**
   * Generate an ER diagram as SVG for data model
   * @param {Object} entities - Extracted entities and attributes
   * @param {String} title - Diagram title
   * @returns {String} - SVG markup
   */
  function generateErDiagram(entities, title) {
    const svgWidth = 800;
    const svgHeight = 600;
    
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}" width="100%" height="100%">
      <!-- Background -->
      <rect width="${svgWidth}" height="${svgHeight}" fill="#f8f9fa" rx="10" ry="10"/>
      
      <!-- Title -->
      <text x="${svgWidth/2}" y="40" font-family="Arial" font-size="24" font-weight="bold" text-anchor="middle" fill="#333">${title}</text>
      <text x="${svgWidth/2}" y="65" font-family="Arial" font-size="14" text-anchor="middle" fill="#666">Entity Relationship Diagram</text>
    `;
    
    // Use databases or create default entities if none exist
    const dbEntities = entities.databases.length > 0 ? 
      entities.databases : 
      [
        { name: 'User', type: 'entity', attributes: ['id', 'name', 'email'] },
        { name: 'Profile', type: 'entity', attributes: ['id', 'user_id', 'bio'] }
      ];
    
    // Add entities to the diagram
    dbEntities.forEach((entity, index) => {
      const x = 150 + (index % 3) * 250;
      const y = 150 + Math.floor(index / 3) * 200;
      
      // Add attributes if they exist or create defaults
      const attributes = entity.attributes || ['id', 'created_at', 'updated_at'];
      
      // Entity header
      svg += `
        <rect x="${x-100}" y="${y}" width="200" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2" rx="5" ry="5"/>
        <text x="${x}" y="${y+25}" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#0d47a1">${entity.name}</text>
        
        <!-- Entity attributes -->
        <rect x="${x-100}" y="${y+40}" width="200" height="${attributes.length * 25}" fill="#f5f5f5" stroke="#1976d2" stroke-width="2" rx="0" ry="0"/>
      `;
      
      // Add each attribute
      attributes.forEach((attr, attrIndex) => {
        svg += `
          <text x="${x-90}" y="${y+65+attrIndex*25}" font-family="Arial" font-size="14" text-anchor="start" fill="#333">${attr}</text>
        `;
      });
      
      // Add relationships if there are multiple entities
      if (index > 0 && index < dbEntities.length) {
        const prevX = 150 + ((index-1) % 3) * 250;
        const prevY = 150 + Math.floor((index-1) / 3) * 200;
        
        // Only connect horizontally adjacent entities
        if (Math.floor(index / 3) === Math.floor((index-1) / 3)) {
          svg += `
            <line x1="${prevX+100}" y1="${prevY+60}" x2="${x-100}" y2="${y+60}" stroke="#757575" stroke-width="2" marker-end="url(#arrowhead)"/>
          `;
        }
      }
    });
    
    // Add arrow marker
    svg += `
      <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
          <polygon points="0 0, 10 3.5, 0 7" fill="#757575" />
        </marker>
      </defs>
    `;
    
    svg += `</svg>`;
    return svg;
  }
  
  /**
   * Generate an API diagram as SVG
   * @param {Object} entities - Extracted entities
   * @param {String} title - Diagram title
   * @returns {String} - SVG markup
   */
  function generateApiDiagram(entities, title) {
    const svgWidth = 800;
    const svgHeight = 600;
    
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}" width="100%" height="100%">
      <!-- Background -->
      <rect width="${svgWidth}" height="${svgHeight}" fill="#f8f9fa" rx="10" ry="10"/>
      
      <!-- Title -->
      <text x="${svgWidth/2}" y="40" font-family="Arial" font-size="24" font-weight="bold" text-anchor="middle" fill="#333">${title}</text>
      <text x="${svgWidth/2}" y="65" font-family="Arial" font-size="14" text-anchor="middle" fill="#666">API Design</text>
      
      <!-- API Endpoints Box -->
      <rect x="50" y="100" width="${svgWidth-100}" height="${svgHeight-150}" fill="#ffffff" stroke="#2196f3" stroke-width="2" rx="5" ry="5"/>
      <text x="${svgWidth/2}" y="130" font-family="Arial" font-size="18" font-weight="bold" text-anchor="middle" fill="#0d47a1">API Endpoints</text>
    `;
    
    // Create default API endpoints based on the problem domain
    const endpoints = [
      { method: 'GET', path: '/api/resource', description: 'Get all resources' },
      { method: 'GET', path: '/api/resource/{id}', description: 'Get resource by ID' },
      { method: 'POST', path: '/api/resource', description: 'Create new resource' },
      { method: 'PUT', path: '/api/resource/{id}', description: 'Update resource' },
      { method: 'DELETE', path: '/api/resource/{id}', description: 'Delete resource' }
    ];
    
    // Draw each endpoint
    endpoints.forEach((endpoint, index) => {
      const y = 180 + index * 70;
      
      // Method box color based on HTTP method
      const methodColor = endpoint.method === 'GET' ? '#4caf50' :
                          endpoint.method === 'POST' ? '#2196f3' :
                          endpoint.method === 'PUT' ? '#ff9800' :
                          endpoint.method === 'DELETE' ? '#f44336' : '#9c27b0';
      
      svg += `
        <rect x="100" y="${y}" width="100" height="40" fill="${methodColor}" stroke="none" rx="5" ry="5"/>
        <text x="150" y="${y+25}" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="white">${endpoint.method}</text>
        
        <!-- Path -->
        <rect x="200" y="${y}" width="300" height="40" fill="#f5f5f5" stroke="none" rx="0" ry="0"/>
        <text x="210" y="${y+25}" font-family="monospace" font-size="14" text-anchor="start" fill="#333">${endpoint.path}</text>
        
        <!-- Description -->
        <text x="520" y="${y+25}" font-family="Arial" font-size="14" text-anchor="start" fill="#555">${endpoint.description}</text>
      `;
    });
    
    svg += `</svg>`;
    return svg;
  }
  
  module.exports = {
    getDiagramTypeForStage,
    generateSvgDiagram,
    generateArchitectureDiagram,
    generateErDiagram,
    generateApiDiagram
  };


================================================================================
# FILE: server\testAnthropic.js
# EXTENSION: .js
================================================================================
require('dotenv').config();
const { default: Anthropic } = require('@anthropic-ai/sdk');

async function testAnthropic() {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  if (!apiKey) {
    console.error("API key not set. Please set ANTHROPIC_API_KEY in your environment.");
    return;
  }
  
  const client = new Anthropic({ apiKey });
  
  try {
    const response = await client.messages.create({
      model: 'claude-3-5-sonnet-latest',
      system: "You are a test assistant.",
      messages: [{ role: "user", content: "Hello, how are you?" }],
      max_tokens: 100,
      temperature: 0.7,
    });
    console.log("Anthropic API response:", response.content[0].text);
  } catch (error) {
    console.error("Test API call failed:", error.response ? error.response.data : error.message);
  }
}

testAnthropic();



================================================================================
# SUMMARY
# Total files processed: 86
# Extraction completed: 2025-03-12 00:13:57
================================================================================
